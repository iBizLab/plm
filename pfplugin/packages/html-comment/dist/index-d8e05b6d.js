var zg = Object.defineProperty;
var Vg = (s, e, t) => e in s ? zg(s, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : s[e] = t;
var E = (s, e, t) => (Vg(s, typeof e != "symbol" ? e + "" : e, t), t);
import { defineComponent as me, ref as T, shallowRef as Gh, watch as Ne, onBeforeUnmount as Co, onMounted as hn, nextTick as ht, createVNode as M, resolveComponent as Ie, createTextVNode as tt, computed as Ge, Fragment as Hg, onUnmounted as or, mergeProps as Ug, reactive as Wh, withDirectives as ri, resolveDirective as ji, vModelText as fl, h as oi, createApp as ai, defineAsyncComponent as qg } from "vue";
import { ScriptFactory as Lt, Srfuf as Gg, PluginStaticResource as Wg, ControllerEvent as Jh, convertNavData as Jr, EditorController as Jg, getDeACMode as Yg, registerEditorProvider as Xg } from "@ibiz-template/runtime";
import { getHtmlProps as gl, useNamespace as we, useClickOutside as Zg, getEditorEmits as Kg, withInstall as Qg } from "@ibiz-template/vue3-util";
import { Editor as Yh, Toolbar as Xh } from "@wangeditor/editor-for-vue";
import { SlateEditor as Q, SlateElement as Ri, SlateText as de, SlateNode as ps, SlatePath as is, SlateTransforms as $e, SlateRange as st, DomEditor as fe, SlatePoint as Yr, Boot as it, createEditor as ep } from "@wangeditor/editor";
import { getCookie as pl, createUUID as rt, QXEvent as Zh } from "qx-util";
import { isNil as Kh } from "ramda";
import { CoreConst as ml, debounce as wl, getToken as tp, awaitTimeout as np, RuntimeError as rs, listenJSEvent as li, NOOP as St, strToBase64 as ka, HttpError as sp, base64ToStr as Pa, clone as Sr, downloadFileFromBlob as ip } from "@ibiz-template/core";
import Qh, { ElMessageBox as eu, ElInput as uc, ElSlider as dc, ElButton as fc } from "element-plus";
import { debounce as tu, startCase as rp, camelCase as Eo, isObject as Ci, clamp as Ct, upperFirst as gc, lowerFirst as op, isPlainObject as un, defaultsDeep as nu, cloneDeep as Ce, sortedIndex as ap, merge as Te, uniq as su, difference as lp, sortedIndexBy as cp, union as pc, isEqual as nn, defaults as hp, isEmpty as iu, sortBy as up, groupBy as mc, max as dp, has as Ar, clone as _a, isNumber as wc, throttle as fp, toNumber as gp } from "lodash-es";
import Oa from "dayjs";
class ru {
  constructor(e, t) {
    /**
     * 模态实例
     * @memberof ModalUtil
     */
    E(this, "modalOrPanel");
    /**
     * 富文本Ref
     * @memberof ModalUtil
     */
    E(this, "htmlRef");
    this.modalOrPanel = e, this.htmlRef = t, this.calcModalPosition(), window.addEventListener("resize", this.handleResize.bind(this));
  }
  /**
   * 计算模态定位
   * @memberof ModalUtil
   */
  calcModalPosition() {
    if (!["dropPanel", "selectList"].includes(this.modalOrPanel.type))
      return;
    const { $elem: t } = this.modalOrPanel, n = t[0], i = this.htmlRef.$el, r = i.querySelector(".w-e-bar"), o = n.previousElementSibling, a = o.getAttribute("data-menu-key"), l = n.parentNode.parentNode.parentNode;
    if (!["bgColor", "color", "headerSelect"].includes(a) || !i || !r || !o || l.getAttribute("data-w-e-toolbar") === "true")
      return;
    const u = n.clientWidth, f = n.clientHeight, d = r.clientHeight, g = o.getBoundingClientRect(), p = g.bottom, m = g.right, w = g.top, v = g.left, y = "".concat(w + d, "px"), b = "".concat(v, "px"), x = "".concat(p - f - d, "px"), C = "".concat(m - u, "px"), A = { position: "fixed", left: b, top: y }, P = window.innerWidth, O = window.innerHeight;
    P - v < u && Object.assign(A, { left: C }), O - w - d < f && Object.assign(A, { top: x }), Object.assign(n.style, { top: "", bottom: "", left: "", right: "" }), Object.assign(n.style, A);
  }
  /**
   * 监听窗口变化
   * @memberof ModalUtil
   */
  handleResize() {
    this.calcModalPosition();
  }
  /**
   * 销毁
   * @memberof ModalUtil
   */
  destroy() {
    window.removeEventListener("resize", this.handleResize);
  }
}
const Xr = /* @__PURE__ */ me({
  name: "IBizHtmlContent",
  props: gl(),
  emits: ["change", "blur", "focus", "enter", "infoTextChange", "link"],
  setup(s, {
    emit: e
  }) {
    const t = we("html"), n = s.controller, i = T(), r = T({});
    let o = null, a = 0;
    const l = T(), c = T(), u = Gh(), f = T(), d = T(""), g = T({
      Authorization: "Bearer ".concat(pl(ml.TOKEN))
    }), p = T(""), m = T(""), w = T(!0), v = T(!1), y = T(!1), b = T(!1), x = T(!1), C = T(""), A = T([]), P = T(!1), O = n.model;
    O.editorParams && (O.editorParams.enableEdit && (v.value = !0, y.value = !0, w.value = n.toBoolean(O.editorParams.enableEdit) && !s.readonly && !s.disabled), O.editorParams.enableFullScreen && (b.value = n.toBoolean(O.editorParams.enableFullScreen)));
    const k = (j) => {
      if (!u.value)
        return;
      const {
        eventArg: V
      } = j;
      V && (u.value.setHtml(V), ht(() => {
        u.value.focus(!0), e("focus");
      }));
    }, D = () => {
      u.value && (u.value.blur(), u.value.setHtml(""));
    }, L = () => {
      u.value && (u.value.focus(!0), e("focus"));
    };
    n.evt.on("setHtml", k), n.evt.on("clear", D), n.evt.on("onSetReply", L), Ne(() => s.data, (j) => {
      if (j) {
        const V = ibiz.util.file.calcFileUpDownUrl(n.context, n.params, j);
        p.value = V.uploadUrl, m.value = V.downloadUrl;
      }
    }, {
      immediate: !0,
      deep: !0
    });
    const B = (j, V) => {
      if (V)
        return !0;
    }, ee = (j) => j, q = {
      toolbarKeys: [{
        key: "group-add-style",
        // 必填，要以 group 开头
        title: "添加",
        // 必填
        iconSvg: '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fit="" height="1em" width="1em" preserveAspectRatio="xMidYMid meet" focusable="false"><g id="arvaction/plus-circle-fill" stroke-width="1" fill-rule="evenodd"><path d="M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16zm-.6-8.6H4v1.2h3.4V12h1.2V8.6H12V7.4H8.6V4H7.4v3.4z" id="arv形状结合"></path></g></svg>',
        // 可选
        menuKeys: ["attachments", "codesnippet", "page"]
      }, "|", {
        key: "group-inline-style",
        // 必填，要以 group 开头
        title: "文本格式",
        // 必填
        iconSvg: '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fit="" height="1em" width="1em" preserveAspectRatio="xMidYMid meet" focusable="false"><g id="ahdeditor/color-tt" stroke-width="1" fill-rule="evenodd"><path id="ahdsecondary-color" d="M1.999 15.011h11.998V13.81H1.999z"></path><path d="M6.034 7.59h4.104L8.086 2.297 6.034 7.59zm-.465 1.2l-1.437 3.707H2.845L7.301 1h1.287l-.001.004h.286l4.454 11.492h-1.288L10.603 8.79H5.569z" id="ahd合并形状"></path></g></svg>',
        // 可选
        menuKeys: ["bold", "italic", "underline", "through", "code", "numberedList", "bulletedList", "insertLink"]
      }, "codeBlock", "mention", "marker", "emoji"]
    };
    n.chatCompletion && q.toolbarKeys.push("aichart");
    const _ = {
      placeholder: n.placeHolder,
      readOnly: v.value ? y.value : s.readonly,
      MENU_CONF: {
        // 图片上传
        uploadImage: {
          // 上传地址
          server: p.value,
          // form-data fieldName ，默认值 'wangeditor-uploaded-image'
          fieldName: "file",
          // 单个文件的最大体积限制，默认为 2M
          maxFileSize: 10 * 1024 * 1024,
          // 10M
          // 最多可上传几个文件，默认为 100
          maxNumberOfFiles: 10,
          // 选择文件时的类型限制，默认为 ['image/*'] 。如不想限制，则设置为 []
          allowedFileTypes: [],
          // 自定义增加 http  header
          headers: g.value,
          // 跨域是否传递 cookie ，默认为 false
          withCredentials: !0,
          // 上传之前触发
          onBeforeUpload(j) {
            return j;
          },
          // 上传进度的回调函数
          onProgress(j) {
            console.log("progress", j);
          },
          // 单个文件上传成功之后
          onSuccess(j, V) {
            console.log("".concat(j.name, " 上传成功"), V);
          },
          // 单个文件上传失败
          onFailed(j, V) {
            console.log("".concat(j.name, " 上传失败"), V);
          },
          // 上传错误，或者触发 timeout 超时
          onError(j, V, ie) {
            console.log("".concat(j.name, " 上传出错"), V, ie);
          },
          // 自定义插入图片
          async customInsert(j, V) {
            const ie = m.value.replace("%fileId%", j.id), Oe = j.filename;
            V(ie, Oe, "");
          }
        },
        // 插入链接
        insertLink: {
          checkLink: B,
          // 也支持 async 函数
          parseLinkUrl: ee
          // 也支持 async 函数
        },
        // 更新链接
        editLink: {
          checkLink: B,
          // 也支持 async 函数
          parseLinkUrl: ee
          // 也支持 async 函数
        }
      },
      hoverbarKeys: {
        link: {
          menuKeys: ["editLink", "unLink", "customViewLink"]
        }
      }
    }, I = async (j) => {
      const V = j.src;
      if (y.value)
        H(V);
      else {
        const ie = Q.nodes(u.value, {
          match: (Oe) => !!(Ri.isElement(Oe) && Oe.type === "image"),
          universal: !0
        });
        if (ie)
          for (const Oe of ie) {
            const [et] = Oe;
            et.type === "image" && V.endsWith(et.src) && H(et.src);
          }
      }
    }, H = async (j) => {
      if (C.value = j, A.value = [j], await ht(), f.value) {
        const {
          container: V
        } = f.value.$refs;
        V && V.children[0].click();
      }
    }, oe = (j) => {
      const V = j.getEditableContainer();
      V && V.querySelectorAll("img").forEach((Oe) => {
        Oe.onclick = (et) => {
          const kt = et.target;
          kt && I(kt);
        };
      });
    }, ne = (j) => {
      if (f.value) {
        const {
          container: V
        } = f.value.$refs;
        if (V) {
          const ie = V.querySelector(".el-image-viewer__wrapper");
          ie == null || ie[j]("keydown", ye);
        }
      }
    }, ye = async (j) => {
      (j.key === "Escape" || j.keyCode === 27) && (j.stopPropagation(), j.preventDefault(), await ht(), ne("removeEventListener"), A.value = []);
    }, Se = async () => {
      await ht(), ne("addEventListener");
    };
    let Rt;
    const Wt = async () => {
      var j;
      if (n.deService) {
        const V = await import("@ibiz-template-plugin/ai-chat"), ie = V.chat || V.default.chat;
        Rt = ie;
        const Oe = ie.create({
          question: async (kt) => {
            var z;
            const N = rt();
            return await ((z = n.deService) == null ? void 0 : z.aiChatSse((W) => {
              if (ibiz.log.info("aiChatSse", W), W.actionstate === 20 && W.actionresult)
                Oe.addMessage({
                  messageid: N,
                  state: W.actionstate,
                  type: "DEFAULT",
                  role: "ASSISTANT",
                  content: W.actionresult
                });
              else if (W.actionstate === 30 && W.actionresult) {
                const ve = JSON.parse(W.actionresult), {
                  choices: Xe
                } = ve;
                Xe && Xe.length > 0 && Oe.replaceMessage({
                  messageid: N,
                  state: W.actionstate,
                  type: "DEFAULT",
                  role: "ASSISTANT",
                  content: Xe[0].content || ""
                });
              } else
                W.actionstate === 40 && Oe.replaceMessage({
                  messageid: N,
                  state: W.actionstate,
                  type: "ERROR",
                  role: "ASSISTANT",
                  content: W.actionresult
                });
            }, n.context, {}, {
              messages: kt
            })), Oe.addMessage({
              messageid: N,
              state: 10,
              type: "DEFAULT",
              role: "ASSISTANT",
              content: ""
            }), !0;
          },
          action: (kt, N) => {
            kt === "backfill" && (e("change", N.content), P.value = !0);
          },
          closed: () => {
            u.value && s.value && u.value && u.value.focus(!0);
          }
        }), et = await ((j = n.deService) == null ? void 0 : j.aiChatHistory(n.context, {}));
        et.data && Array.isArray(et.data) && et.data.forEach((kt) => {
          const N = {
            messageid: rt(),
            state: 30,
            type: "DEFAULT",
            role: kt.role,
            content: kt.content
          };
          Oe.addMessage(N);
        });
      }
    };
    Co(() => {
      Rt && Rt.close();
      const j = u.value;
      j != null && j.destroy();
    });
    const ot = (j) => {
      u.value = j;
      let V;
      j.on("modalOrPanelShow", (ie) => {
        V = new ru(ie, c.value);
      }), j.on("modalOrPanelHide", () => {
        V && V.destroy();
      }), j.setHtml(d.value), j.on("aiClick", () => {
        Wt();
      }), n.onCreated(u.value, s.data, q);
    }, Mt = (j) => {
      const V = j.getHtml();
      oe(j);
      const ie = V === "<p><br></p>" ? "" : V;
      ie === s.value || ie === "" && Kh(s.value) || v.value || (e("change", ie), n.evt.emit("onChange", {
        eventArg: ie
      }));
    }, Ke = (j) => {
      n.evt.off("setHtml", k), n.evt.off("clear", D), n.evt.off("onSetReply", L);
    }, Qe = () => {
      e("focus"), n.evt.emit("onFocus", {
        eventArg: s.value
      });
    }, mn = () => {
      e("blur"), n.evt.emit("onBlur", {
        eventArg: s.value
      });
    }, Hn = (j, V) => {
      alert("【自定义提示】".concat(V, " - ").concat(j));
    }, gt = (j, V, ie) => {
      ie(!0);
    }, vr = (j) => {
      const V = u.value;
      V != null && V.insertText(j);
    }, xr = () => {
      const j = u.value;
      j != null && console.log(j.getHtml());
    }, Un = () => {
      const j = u.value;
      j != null && j.disable();
    }, qn = () => {
      const j = u.value;
      j != null && j.enable();
    }, Cr = () => {
      if (i.value && l.value) {
        const j = i.value.offsetHeight;
        o = new ResizeObserver((V) => {
          const {
            height: ie
          } = V[0].contentRect;
          if (ie !== a) {
            const Oe = {
              height: "".concat(j - V[0].contentRect.height, "px")
            };
            r.value = t.cssVarBlock(Oe), a = ie;
          }
        }), o.observe(l.value.selector);
      }
    }, Er = () => {
      var j, V;
      if (s.value) {
        const ie = s.value.indexOf("</p>");
        if (ie >= 0) {
          const Oe = (j = u.value.selection.anchor) == null ? void 0 : j.offset, et = (V = u.value.selection.anchor) == null ? void 0 : V.path;
          Oe === 0 && et.length > 0 && et[0] === 0 && u.value.move(ie - 3);
        }
      }
    }, yi = () => {
      y.value = !y.value, y.value ? Un() : (qn(), u.value.focus(), Er());
    }, Jo = () => M("div", {
      class: t.be("message", "message-content")
    }, [M("p", null, [tt("确定要取消编辑吗？")]), M("p", {
      class: t.bem("message", "message-content", "message-tip")
    }, [tt("取消编辑将无法保存修改的内容，且不能找回。")])]), vs = () => {
      s.value !== d.value ? eu({
        title: "确认取消",
        type: "warning",
        customClass: t.b("message"),
        message: Jo(),
        showCancelButton: !0,
        cancelButtonClass: t.be("message", "message-cancel"),
        confirmButtonClass: t.be("message", "message-comfire")
      }).then(() => {
        if (s.value) {
          const j = n.parseNode(s.value);
          d.value = j;
        } else
          d.value = "";
        yi();
      }).catch(() => {
        u.value.focus();
      }) : yi();
    }, xs = () => {
      y.value = !0, u.value.disable();
      const {
        value: j
      } = d;
      e("change", j), x.value && (x.value = !1);
    }, Yo = () => v.value ? M("div", {
      class: [t.b("footer"), {
        [t.b("footer-dialog")]: x.value
      }]
    }, [M("div", {
      class: t.be("footer", "cancel"),
      onClick: () => vs()
    }, [tt("取消")]), M("div", {
      class: t.be("footer", "save"),
      onClick: () => xs()
    }, [tt("保存")])]) : null, bi = () => {
      x.value = !x.value, ht(() => {
        y.value ? Un() : (qn(), u.value.focus());
      });
    }, vi = () => b.value ? x.value ? M("i", {
      class: "fa fa-compress",
      "aria-hidden": "true",
      title: "缩小",
      onClick: () => bi()
    }, null) : M("i", {
      class: "fa fa-expand",
      "aria-hidden": "true",
      title: "放大",
      onClick: () => bi()
    }, null) : null, Xo = () => v.value || b.value ? M("div", {
      class: t.b("custom-toolbar")
    }, [v.value && w.value && y.value ? M("i", {
      class: "fa fa-edit",
      "aria-hidden": "true",
      title: "启用编辑",
      onClick: () => yi()
    }, null) : null, vi()]) : null, Zo = () => {
      if (n.reply.value) {
        const j = Lt.execScriptFn({
          value: n.reply.value
        }, n.replyScript, {
          singleRowReturn: !0,
          isAsync: !1
        });
        return M("div", {
          class: t.b("reply")
        }, [M("div", {
          class: t.be("reply", "content"),
          innerHTML: j
        }, null), M(Ie("ion-icon"), {
          name: "close-outline",
          onClick: () => n.removeReply()
        }, null)]);
      }
    }, Ko = () => n.hidden.value ? null : M("div", {
      class: t.b("content"),
      ref: "htmlContent",
      style: r.value
    }, [M(Yh, {
      ref: "htmlRef",
      class: t.b("editor"),
      modelValue: d.value,
      "onUpdate:modelValue": (j) => d.value = j,
      "default-config": _,
      mode: "default",
      onOnCreated: ot,
      onOnChange: Mt,
      onOnDestroyed: Ke,
      onOnFocus: Qe,
      onOnBlur: mn,
      oncustomAlert: Hn,
      oncustomPaste: gt
    }, null), Zo(), M(Xh, {
      ref: "toolbarRef",
      editor: u.value,
      "default-config": q,
      mode: "default",
      class: t.b("toolbar")
    }, null)]), Qo = () => M(Ie("el-image"), {
      class: t.e("preview"),
      ref: "previewRef",
      "zoom-rate": 1.1,
      src: C.value,
      "preview-src-list": A.value,
      "hide-on-click-modal": !0,
      onShow: Se,
      fit: "cover"
    }, null);
    return hn(() => {
      Cr(), Ne(() => s.value, (j, V) => {
        j !== V && (typeof s.value == "string" || j == null) && (j == null ? d.value = "" : d.value = j, P.value && (u.value && ht(() => {
          u.value.focus(!0);
        }), P.value = !1));
      }, {
        immediate: !0
      }), Ne(() => s.disabled, (j, V) => {
        j !== V && (j === !0 ? Un() : qn());
      }, {
        immediate: !0
      });
    }), {
      ns: t,
      editorRef: u,
      previewRef: f,
      mode: "default",
      valueHtml: d,
      toolbarConfig: q,
      editorConfig: _,
      handleCreated: ot,
      handleChange: Mt,
      handleDestroyed: Ke,
      handleFocus: Qe,
      handleBlur: mn,
      customAlert: Hn,
      customPaste: gt,
      insertText: vr,
      printHtml: xr,
      disable: Un,
      enable: qn,
      renderHeaserToolbar: Xo,
      renderEditorContent: Ko,
      renderFooter: Yo,
      htmlContent: i,
      hasEnableEdit: v,
      cssVars: r,
      toolbarRef: l,
      htmlRef: c,
      isFullScreen: x,
      readonlyState: y,
      changeFullScreenState: bi,
      renderPreview: Qo
    };
  },
  render() {
    return this.isFullScreen ? M(Ie("el-dialog"), {
      modelValue: this.isFullScreen,
      "onUpdate:modelValue": (s) => this.isFullScreen = s,
      width: "80%",
      top: "10vh",
      class: this.ns.b("dialog-full-screen"),
      onClose: () => this.changeFullScreenState()
    }, {
      default: () => [M("div", {
        class: [this.ns.b(), {
          [this.ns.b("editor-readonly")]: this.readonlyState
        }]
      }, [this.renderHeaserToolbar(), this.renderEditorContent(), this.hasEnableEdit && !this.readonlyState ? this.renderFooter() : null])]
    }) : M("div", {
      class: [this.ns.b(), {
        [this.ns.b("editor-readonly")]: this.readonlyState
      }]
    }, [this.renderHeaserToolbar(), this.renderEditorContent(), this.renderPreview(), this.hasEnableEdit && !this.readonlyState ? this.renderFooter() : null]);
  }
}), pp = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Xr
}, Symbol.toStringTag, { value: "Module" })), mp = [
  "insert",
  "|",
  "headerSelect",
  "blockquote",
  "|",
  "bold",
  "underline",
  "italic",
  {
    key: "group-more-style",
    title: "更多",
    iconSvg: '<svg viewBox="0 0 1024 1024"><path d="M204.8 505.6m-76.8 0a76.8 76.8 0 1 0 153.6 0 76.8 76.8 0 1 0-153.6 0Z"></path><path d="M505.6 505.6m-76.8 0a76.8 76.8 0 1 0 153.6 0 76.8 76.8 0 1 0-153.6 0Z"></path><path d="M806.4 505.6m-76.8 0a76.8 76.8 0 1 0 153.6 0 76.8 76.8 0 1 0-153.6 0Z"></path></svg>',
    menuKeys: ["through", "code", "sup", "sub", "clearStyle"]
  },
  "color",
  "bgColor",
  "|",
  "fontSize",
  "fontFamily",
  "lineHeight",
  "|",
  "bulletedList",
  "numberedList",
  "todo",
  {
    key: "group-justify",
    title: "对齐",
    iconSvg: '<svg viewBox="0 0 1024 1024"><path d="M768 793.6v102.4H51.2v-102.4h716.8z m204.8-230.4v102.4H51.2v-102.4h921.6z m-204.8-230.4v102.4H51.2v-102.4h716.8zM972.8 102.4v102.4H51.2V102.4h921.6z"></path></svg>',
    menuKeys: [
      "justifyLeft",
      "justifyRight",
      "justifyCenter",
      "justifyJustify"
    ]
  },
  {
    key: "group-indent",
    title: "缩进",
    iconSvg: '<svg viewBox="0 0 1024 1024"><path d="M0 64h1024v128H0z m384 192h640v128H384z m0 192h640v128H384z m0 192h640v128H384zM0 832h1024v128H0z m0-128V320l256 192z"></path></svg>',
    menuKeys: ["indent", "delIndent"]
  },
  "|",
  "emoji",
  "insertLink",
  {
    key: "group-image",
    title: "图片",
    iconSvg: '<svg viewBox="0 0 1024 1024"><path d="M959.877 128l0.123 0.123v767.775l-0.123 0.122H64.102l-0.122-0.122V128.123l0.122-0.123h895.775zM960 64H64C28.795 64 0 92.795 0 128v768c0 35.205 28.795 64 64 64h896c35.205 0 64-28.795 64-64V128c0-35.205-28.795-64-64-64zM832 288.01c0 53.023-42.988 96.01-96.01 96.01s-96.01-42.987-96.01-96.01S682.967 192 735.99 192 832 234.988 832 288.01zM896 832H128V704l224.01-384 256 320h64l224.01-192z"></path></svg>',
    menuKeys: ["insertImage", "uploadImage"]
  },
  {
    key: "group-video",
    title: "视频",
    iconSvg: '<svg viewBox="0 0 1024 1024"><path d="M981.184 160.096C837.568 139.456 678.848 128 512 128S186.432 139.456 42.816 160.096C15.296 267.808 0 386.848 0 512s15.264 244.16 42.816 351.904C186.464 884.544 345.152 896 512 896s325.568-11.456 469.184-32.096C1008.704 756.192 1024 637.152 1024 512s-15.264-244.16-42.816-351.904zM384 704V320l320 192-320 192z"></path></svg>',
    menuKeys: ["insertVideo", "uploadVideo"]
  },
  "insertTable",
  "codeBlock",
  "divider",
  "|",
  "undo",
  "redo"
], _t = () => /* @__PURE__ */ new Map(), Ta = (s) => {
  const e = _t();
  return s.forEach((t, n) => {
    e.set(n, t);
  }), e;
}, jn = (s, e, t) => {
  let n = s.get(e);
  return n === void 0 && s.set(e, n = t()), n;
}, wp = (s, e) => {
  const t = [];
  for (const [n, i] of s)
    t.push(e(i, n));
  return t;
}, yp = (s, e) => {
  for (const [t, n] of s)
    if (e(n, t))
      return !0;
  return !1;
}, Ns = () => /* @__PURE__ */ new Set(), ta = (s) => s[s.length - 1], bp = (s, e) => {
  for (let t = 0; t < e.length; t++)
    s.push(e[t]);
}, kn = Array.from, vp = (s, e) => {
  for (let t = 0; t < s.length; t++)
    if (e(s[t], t, s))
      return !0;
  return !1;
}, La = Array.isArray;
class ou {
  constructor() {
    this._observers = _t();
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  on(e, t) {
    return jn(
      this._observers,
      /** @type {string} */
      e,
      Ns
    ).add(t), t;
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  once(e, t) {
    const n = (...i) => {
      this.off(
        e,
        /** @type {any} */
        n
      ), t(...i);
    };
    this.on(
      e,
      /** @type {any} */
      n
    );
  }
  /**
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name
   * @param {EVENTS[NAME]} f
   */
  off(e, t) {
    const n = this._observers.get(e);
    n !== void 0 && (n.delete(t), n.size === 0 && this._observers.delete(e));
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @template {keyof EVENTS & string} NAME
   * @param {NAME} name The event name.
   * @param {Parameters<EVENTS[NAME]>} args The arguments that are applied to the event listener.
   */
  emit(e, t) {
    return kn((this._observers.get(e) || _t()).values()).forEach((n) => n(...t));
  }
  destroy() {
    this._observers = _t();
  }
}
const Pn = Math.floor, $r = Math.abs, au = (s, e) => s < e ? s : e, ms = (s, e) => s > e ? s : e, lu = (s) => s !== 0 ? s < 0 : 1 / s < 0, yc = 1, bc = 2, na = 4, sa = 8, Bi = 32, sn = 64, ut = 128, So = 31, Da = 63, Qn = 127, xp = 2147483647, cu = Number.MAX_SAFE_INTEGER, Cp = Number.isInteger || ((s) => typeof s == "number" && isFinite(s) && Pn(s) === s), Ep = (s) => s.toLowerCase(), Sp = /^\s*/g, Ap = (s) => s.replace(Sp, ""), Mp = /([A-Z])/g, vc = (s, e) => Ap(s.replace(Mp, (t) => "".concat(e).concat(Ep(t)))), kp = (s) => {
  const e = unescape(encodeURIComponent(s)), t = e.length, n = new Uint8Array(t);
  for (let i = 0; i < t; i++)
    n[i] = /** @type {number} */
    e.codePointAt(i);
  return n;
}, $i = (
  /** @type {TextEncoder} */
  typeof TextEncoder < "u" ? new TextEncoder() : null
), Pp = (s) => $i.encode(s), _p = $i ? Pp : kp;
let ki = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8", { fatal: !0, ignoreBOM: !0 });
ki && ki.decode(new Uint8Array()).length === 1 && (ki = null);
let ar = class {
  constructor() {
    this.cpos = 0, this.cbuf = new Uint8Array(100), this.bufs = [];
  }
};
const lr = () => new ar(), Op = (s) => {
  let e = s.cpos;
  for (let t = 0; t < s.bufs.length; t++)
    e += s.bufs[t].length;
  return e;
}, Pt = (s) => {
  const e = new Uint8Array(Op(s));
  let t = 0;
  for (let n = 0; n < s.bufs.length; n++) {
    const i = s.bufs[n];
    e.set(i, t), t += i.length;
  }
  return e.set(new Uint8Array(s.cbuf.buffer, 0, s.cpos), t), e;
}, Tp = (s, e) => {
  const t = s.cbuf.length;
  t - s.cpos < e && (s.bufs.push(new Uint8Array(s.cbuf.buffer, 0, s.cpos)), s.cbuf = new Uint8Array(ms(t, e) * 2), s.cpos = 0);
}, Be = (s, e) => {
  const t = s.cbuf.length;
  s.cpos === t && (s.bufs.push(s.cbuf), s.cbuf = new Uint8Array(t * 2), s.cpos = 0), s.cbuf[s.cpos++] = e;
}, Fi = Be, K = (s, e) => {
  for (; e > Qn; )
    Be(s, ut | Qn & e), e = Pn(e / 128);
  Be(s, Qn & e);
}, Ao = (s, e) => {
  const t = lu(e);
  for (t && (e = -e), Be(s, (e > Da ? ut : 0) | (t ? sn : 0) | Da & e), e = Pn(e / 64); e > 0; )
    Be(s, (e > Qn ? ut : 0) | Qn & e), e = Pn(e / 128);
}, Na = new Uint8Array(3e4), Lp = Na.length / 3, Dp = (s, e) => {
  if (e.length < Lp) {
    const t = $i.encodeInto(e, Na).written || 0;
    K(s, t);
    for (let n = 0; n < t; n++)
      Be(s, Na[n]);
  } else
    at(s, _p(e));
}, Np = (s, e) => {
  const t = unescape(encodeURIComponent(e)), n = t.length;
  K(s, n);
  for (let i = 0; i < n; i++)
    Be(
      s,
      /** @type {number} */
      t.codePointAt(i)
    );
}, es = $i && /** @type {any} */
$i.encodeInto ? Dp : Np, Mo = (s, e) => {
  const t = s.cbuf.length, n = s.cpos, i = au(t - n, e.length), r = e.length - i;
  s.cbuf.set(e.subarray(0, i), n), s.cpos += i, r > 0 && (s.bufs.push(s.cbuf), s.cbuf = new Uint8Array(ms(t * 2, r)), s.cbuf.set(e.subarray(i)), s.cpos = r);
}, at = (s, e) => {
  K(s, e.byteLength), Mo(s, e);
}, yl = (s, e) => {
  Tp(s, e);
  const t = new DataView(s.cbuf.buffer, s.cpos, e);
  return s.cpos += e, t;
}, Ip = (s, e) => yl(s, 4).setFloat32(0, e, !1), jp = (s, e) => yl(s, 8).setFloat64(0, e, !1), Rp = (s, e) => (
  /** @type {any} */
  yl(s, 8).setBigInt64(0, e, !1)
), xc = new DataView(new ArrayBuffer(4)), Bp = (s) => (xc.setFloat32(0, s), xc.getFloat32(0) === s), zi = (s, e) => {
  switch (typeof e) {
    case "string":
      Be(s, 119), es(s, e);
      break;
    case "number":
      Cp(e) && $r(e) <= xp ? (Be(s, 125), Ao(s, e)) : Bp(e) ? (Be(s, 124), Ip(s, e)) : (Be(s, 123), jp(s, e));
      break;
    case "bigint":
      Be(s, 122), Rp(s, e);
      break;
    case "object":
      if (e === null)
        Be(s, 126);
      else if (La(e)) {
        Be(s, 117), K(s, e.length);
        for (let t = 0; t < e.length; t++)
          zi(s, e[t]);
      } else if (e instanceof Uint8Array)
        Be(s, 116), at(s, e);
      else {
        Be(s, 118);
        const t = Object.keys(e);
        K(s, t.length);
        for (let n = 0; n < t.length; n++) {
          const i = t[n];
          es(s, i), zi(s, e[i]);
        }
      }
      break;
    case "boolean":
      Be(s, e ? 120 : 121);
      break;
    default:
      Be(s, 127);
  }
};
class Cc extends ar {
  /**
   * @param {function(Encoder, T):void} writer
   */
  constructor(e) {
    super(), this.w = e, this.s = null, this.count = 0;
  }
  /**
   * @param {T} v
   */
  write(e) {
    this.s === e ? this.count++ : (this.count > 0 && K(this, this.count - 1), this.count = 1, this.w(this, e), this.s = e);
  }
}
const Ec = (s) => {
  s.count > 0 && (Ao(s.encoder, s.count === 1 ? s.s : -s.s), s.count > 1 && K(s.encoder, s.count - 2));
};
class Fr {
  constructor() {
    this.encoder = new ar(), this.s = 0, this.count = 0;
  }
  /**
   * @param {number} v
   */
  write(e) {
    this.s === e ? this.count++ : (Ec(this), this.count = 1, this.s = e);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return Ec(this), Pt(this.encoder);
  }
}
const Sc = (s) => {
  if (s.count > 0) {
    const e = s.diff * 2 + (s.count === 1 ? 0 : 1);
    Ao(s.encoder, e), s.count > 1 && K(s.encoder, s.count - 2);
  }
};
class ia {
  constructor() {
    this.encoder = new ar(), this.s = 0, this.count = 0, this.diff = 0;
  }
  /**
   * @param {number} v
   */
  write(e) {
    this.diff === e - this.s ? (this.s = e, this.count++) : (Sc(this), this.count = 1, this.diff = e - this.s, this.s = e);
  }
  /**
   * Flush the encoded state and transform this to a Uint8Array.
   *
   * Note that this should only be called once.
   */
  toUint8Array() {
    return Sc(this), Pt(this.encoder);
  }
}
class $p {
  constructor() {
    this.sarr = [], this.s = "", this.lensE = new Fr();
  }
  /**
   * @param {string} string
   */
  write(e) {
    this.s += e, this.s.length > 19 && (this.sarr.push(this.s), this.s = ""), this.lensE.write(e.length);
  }
  toUint8Array() {
    const e = new ar();
    return this.sarr.push(this.s), this.s = "", es(e, this.sarr.join("")), Mo(e, this.lensE.toUint8Array()), Pt(e);
  }
}
const _n = (s) => new Error(s), Ft = () => {
  throw _n("Method unimplemented");
}, At = () => {
  throw _n("Unexpected case");
}, hu = _n("Unexpected end of array"), uu = _n("Integer out of Range");
let ko = class {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(e) {
    this.arr = e, this.pos = 0;
  }
};
const ws = (s) => new ko(s), du = (s) => s.pos !== s.arr.length, Fp = (s, e) => {
  const t = new Uint8Array(s.arr.buffer, s.pos + s.arr.byteOffset, e);
  return s.pos += e, t;
}, lt = (s) => Fp(s, Z(s)), Is = (s) => s.arr[s.pos++], Z = (s) => {
  let e = 0, t = 1;
  const n = s.arr.length;
  for (; s.pos < n; ) {
    const i = s.arr[s.pos++];
    if (e = e + (i & Qn) * t, t *= 128, i < ut)
      return e;
    if (e > cu)
      throw uu;
  }
  throw hu;
}, Po = (s) => {
  let e = s.arr[s.pos++], t = e & Da, n = 64;
  const i = (e & sn) > 0 ? -1 : 1;
  if (!(e & ut))
    return i * t;
  const r = s.arr.length;
  for (; s.pos < r; ) {
    if (e = s.arr[s.pos++], t = t + (e & Qn) * n, n *= 128, e < ut)
      return i * t;
    if (t > cu)
      throw uu;
  }
  throw hu;
}, zp = (s) => {
  let e = Z(s);
  if (e === 0)
    return "";
  {
    let t = String.fromCodePoint(Is(s));
    if (--e < 100)
      for (; e--; )
        t += String.fromCodePoint(Is(s));
    else
      for (; e > 0; ) {
        const n = e < 1e4 ? e : 1e4, i = s.arr.subarray(s.pos, s.pos + n);
        s.pos += n, t += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          i
        ), e -= n;
      }
    return decodeURIComponent(escape(t));
  }
}, Vp = (s) => (
  /** @type any */
  ki.decode(lt(s))
), ts = ki ? Vp : zp, bl = (s, e) => {
  const t = new DataView(s.arr.buffer, s.arr.byteOffset + s.pos, e);
  return s.pos += e, t;
}, Hp = (s) => bl(s, 4).getFloat32(0, !1), Up = (s) => bl(s, 8).getFloat64(0, !1), qp = (s) => (
  /** @type {any} */
  bl(s, 8).getBigInt64(0, !1)
), Gp = [
  (s) => {
  },
  // CASE 127: undefined
  (s) => null,
  // CASE 126: null
  Po,
  // CASE 125: integer
  Hp,
  // CASE 124: float32
  Up,
  // CASE 123: float64
  qp,
  // CASE 122: bigint
  (s) => !1,
  // CASE 121: boolean (false)
  (s) => !0,
  // CASE 120: boolean (true)
  ts,
  // CASE 119: string
  (s) => {
    const e = Z(s), t = {};
    for (let n = 0; n < e; n++) {
      const i = ts(s);
      t[i] = Vi(s);
    }
    return t;
  },
  (s) => {
    const e = Z(s), t = [];
    for (let n = 0; n < e; n++)
      t.push(Vi(s));
    return t;
  },
  lt
  // CASE 116: Uint8Array
], Vi = (s) => Gp[127 - Is(s)](s);
class Ac extends ko {
  /**
   * @param {Uint8Array} uint8Array
   * @param {function(Decoder):T} reader
   */
  constructor(e, t) {
    super(e), this.reader = t, this.s = null, this.count = 0;
  }
  read() {
    return this.count === 0 && (this.s = this.reader(this), du(this) ? this.count = Z(this) + 1 : this.count = -1), this.count--, /** @type {T} */
    this.s;
  }
}
class zr extends ko {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(e) {
    super(e), this.s = 0, this.count = 0;
  }
  read() {
    if (this.count === 0) {
      this.s = Po(this);
      const e = lu(this.s);
      this.count = 1, e && (this.s = -this.s, this.count = Z(this) + 2);
    }
    return this.count--, /** @type {number} */
    this.s;
  }
}
class ra extends ko {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(e) {
    super(e), this.s = 0, this.count = 0, this.diff = 0;
  }
  /**
   * @return {number}
   */
  read() {
    if (this.count === 0) {
      const e = Po(this), t = e & 1;
      this.diff = Pn(e / 2), this.count = 1, t && (this.count = Z(this) + 2);
    }
    return this.s += this.diff, this.count--, this.s;
  }
}
class Wp {
  /**
   * @param {Uint8Array} uint8Array
   */
  constructor(e) {
    this.decoder = new zr(e), this.str = ts(this.decoder), this.spos = 0;
  }
  /**
   * @return {string}
   */
  read() {
    const e = this.spos + this.decoder.read(), t = this.str.slice(this.spos, e);
    return this.spos = e, t;
  }
}
const Jp = crypto.getRandomValues.bind(crypto), fu = () => Jp(new Uint32Array(1))[0], Yp = [1e7] + -1e3 + -4e3 + -8e3 + -1e11, Xp = () => Yp.replace(
  /[018]/g,
  /** @param {number} c */
  (s) => (s ^ fu() & 15 >> s / 4).toString(16)
), Zp = Date.now, Mc = (s) => (
  /** @type {Promise<T>} */
  new Promise(s)
);
Promise.all.bind(Promise);
const kc = (s) => s === void 0 ? null : s;
let Kp = class {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(e, t) {
    this.map.set(e, t);
  }
  /**
   * @param {string} key
   */
  getItem(e) {
    return this.map.get(e);
  }
}, gu = new Kp(), Qp = !0;
try {
  typeof localStorage < "u" && localStorage && (gu = localStorage, Qp = !1);
} catch (s) {
}
const em = gu, tm = Object.assign, nm = Object.keys, sm = (s, e) => {
  for (const t in s)
    e(s[t], t);
}, Pc = (s) => nm(s).length, im = (s) => {
  for (const e in s)
    return !1;
  return !0;
}, rm = (s, e) => {
  for (const t in s)
    if (!e(s[t], t))
      return !1;
  return !0;
}, om = (s, e) => Object.prototype.hasOwnProperty.call(s, e), am = (s, e) => s === e || Pc(s) === Pc(e) && rm(s, (t, n) => (t !== void 0 || om(e, n)) && e[n] === t), vl = (s, e, t = 0) => {
  try {
    for (; t < s.length; t++)
      s[t](...e);
  } finally {
    t < s.length && vl(s, e, t + 1);
  }
}, lm = (s) => s, cm = (s, e) => e.includes(s), Hi = typeof process < "u" && process.release && /node|io\.js/.test(process.release.name) && Object.prototype.toString.call(typeof process < "u" ? process : 0) === "[object process]";
let Bt;
const hm = () => {
  if (Bt === void 0)
    if (Hi) {
      Bt = _t();
      const s = process.argv;
      let e = null;
      for (let t = 0; t < s.length; t++) {
        const n = s[t];
        n[0] === "-" ? (e !== null && Bt.set(e, ""), e = n) : e !== null && (Bt.set(e, n), e = null);
      }
      e !== null && Bt.set(e, "");
    } else
      typeof location == "object" ? (Bt = _t(), (location.search || "?").slice(1).split("&").forEach((s) => {
        if (s.length !== 0) {
          const [e, t] = s.split("=");
          Bt.set("--".concat(vc(e, "-")), t), Bt.set("-".concat(vc(e, "-")), t);
        }
      })) : Bt = _t();
  return Bt;
}, Ia = (s) => hm().has(s), ja = (s) => kc(Hi ? process.env[s.toUpperCase().replaceAll("-", "_")] : em.getItem(s)), pu = (s) => Ia("--" + s) || ja(s) !== null;
pu("production");
const um = Hi && cm(process.env.FORCE_COLOR, ["true", "1", "2"]), dm = um || !Ia("--no-colors") && // @todo deprecate --no-colors
!pu("no-color") && (!Hi || process.stdout.isTTY) && (!Hi || Ia("--color") || ja("COLORTERM") !== null || (ja("TERM") || "").includes("color")), fm = (s) => new Uint8Array(s), gm = (s) => {
  const e = fm(s.byteLength);
  return e.set(s), e;
};
class pm {
  /**
   * @param {L} left
   * @param {R} right
   */
  constructor(e, t) {
    this.left = e, this.right = t;
  }
}
const Xt = (s, e) => new pm(s, e);
typeof DOMParser < "u" && new DOMParser();
const mm = (s) => wp(s, (e, t) => "".concat(t, ":").concat(e, ";")).join(""), dn = Symbol, mu = dn(), wu = dn(), wm = dn(), ym = dn(), bm = dn(), yu = dn(), vm = dn(), xl = dn(), xm = dn(), Cm = (s) => {
  var i;
  s.length === 1 && ((i = s[0]) == null ? void 0 : i.constructor) === Function && (s = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  s[0]());
  const e = [], t = [];
  let n = 0;
  for (; n < s.length; n++) {
    const r = s[n];
    if (r === void 0)
      break;
    if (r.constructor === String || r.constructor === Number)
      e.push(r);
    else if (r.constructor === Object)
      break;
  }
  for (n > 0 && t.push(e.join("")); n < s.length; n++) {
    const r = s[n];
    r instanceof Symbol || t.push(r);
  }
  return t;
}, Em = {
  [mu]: Xt("font-weight", "bold"),
  [wu]: Xt("font-weight", "normal"),
  [wm]: Xt("color", "blue"),
  [bm]: Xt("color", "green"),
  [ym]: Xt("color", "grey"),
  [yu]: Xt("color", "red"),
  [vm]: Xt("color", "purple"),
  [xl]: Xt("color", "orange"),
  // not well supported in chrome when debugging node with inspector - TODO: deprecate
  [xm]: Xt("color", "black")
}, Sm = (s) => {
  var o;
  s.length === 1 && ((o = s[0]) == null ? void 0 : o.constructor) === Function && (s = /** @type {Array<string|Symbol|Object|number>} */
  /** @type {[function]} */
  s[0]());
  const e = [], t = [], n = _t();
  let i = [], r = 0;
  for (; r < s.length; r++) {
    const a = s[r], l = Em[a];
    if (l !== void 0)
      n.set(l.left, l.right);
    else {
      if (a === void 0)
        break;
      if (a.constructor === String || a.constructor === Number) {
        const c = mm(n);
        r > 0 || c.length > 0 ? (e.push("%c" + a), t.push(c)) : e.push(a);
      } else
        break;
    }
  }
  for (r > 0 && (i = t, i.unshift(e.join(""))); r < s.length; r++) {
    const a = s[r];
    a instanceof Symbol || i.push(a);
  }
  return i;
}, bu = dm ? Sm : Cm, Am = (...s) => {
  console.log(...bu(s)), vu.forEach((e) => e.print(s));
}, Mm = (...s) => {
  console.warn(...bu(s)), s.unshift(xl), vu.forEach((e) => e.print(s));
}, vu = Ns(), xu = (s) => ({
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return this;
  },
  // @ts-ignore
  next: s
}), km = (s, e) => xu(() => {
  let t;
  do
    t = s.next();
  while (!t.done && !e(t.value));
  return t;
}), oa = (s, e) => xu(() => {
  const { done: t, value: n } = s.next();
  return { done: t, value: t ? void 0 : e(n) };
});
class Cl {
  /**
   * @param {number} clock
   * @param {number} len
   */
  constructor(e, t) {
    this.clock = e, this.len = t;
  }
}
class ci {
  constructor() {
    this.clients = /* @__PURE__ */ new Map();
  }
}
const js = (s, e, t) => e.clients.forEach((n, i) => {
  const r = (
    /** @type {Array<GC|Item>} */
    s.doc.store.clients.get(i)
  );
  for (let o = 0; o < n.length; o++) {
    const a = n[o];
    Ru(s, r, a.clock, a.len, t);
  }
}), Pm = (s, e) => {
  let t = 0, n = s.length - 1;
  for (; t <= n; ) {
    const i = Pn((t + n) / 2), r = s[i], o = r.clock;
    if (o <= e) {
      if (e < o + r.len)
        return i;
      t = i + 1;
    } else
      n = i - 1;
  }
  return null;
}, cr = (s, e) => {
  const t = s.clients.get(e.client);
  return t !== void 0 && Pm(t, e.clock) !== null;
}, El = (s) => {
  s.clients.forEach((e) => {
    e.sort((i, r) => i.clock - r.clock);
    let t, n;
    for (t = 1, n = 1; t < e.length; t++) {
      const i = e[n - 1], r = e[t];
      i.clock + i.len >= r.clock ? i.len = ms(i.len, r.clock + r.len - i.clock) : (n < t && (e[n] = r), n++);
    }
    e.length = n;
  });
}, Ra = (s) => {
  const e = new ci();
  for (let t = 0; t < s.length; t++)
    s[t].clients.forEach((n, i) => {
      if (!e.clients.has(i)) {
        const r = n.slice();
        for (let o = t + 1; o < s.length; o++)
          bp(r, s[o].clients.get(i) || []);
        e.clients.set(i, r);
      }
    });
  return El(e), e;
}, Ui = (s, e, t, n) => {
  jn(s.clients, e, () => (
    /** @type {Array<DeleteItem>} */
    []
  )).push(new Cl(t, n));
}, _m = () => new ci(), Om = (s) => {
  const e = _m();
  return s.clients.forEach((t, n) => {
    const i = [];
    for (let r = 0; r < t.length; r++) {
      const o = t[r];
      if (o.deleted) {
        const a = o.id.clock;
        let l = o.length;
        if (r + 1 < t.length)
          for (let c = t[r + 1]; r + 1 < t.length && c.deleted; c = t[++r + 1])
            l += c.length;
        i.push(new Cl(a, l));
      }
    }
    i.length > 0 && e.clients.set(n, i);
  }), e;
}, hi = (s, e) => {
  K(s.restEncoder, e.clients.size), kn(e.clients.entries()).sort((t, n) => n[0] - t[0]).forEach(([t, n]) => {
    s.resetDsCurVal(), K(s.restEncoder, t);
    const i = n.length;
    K(s.restEncoder, i);
    for (let r = 0; r < i; r++) {
      const o = n[r];
      s.writeDsClock(o.clock), s.writeDsLen(o.len);
    }
  });
}, Sl = (s) => {
  const e = new ci(), t = Z(s.restDecoder);
  for (let n = 0; n < t; n++) {
    s.resetDsCurVal();
    const i = Z(s.restDecoder), r = Z(s.restDecoder);
    if (r > 0) {
      const o = jn(e.clients, i, () => (
        /** @type {Array<DeleteItem>} */
        []
      ));
      for (let a = 0; a < r; a++)
        o.push(new Cl(s.readDsClock(), s.readDsLen()));
    }
  }
  return e;
}, _c = (s, e, t) => {
  const n = new ci(), i = Z(s.restDecoder);
  for (let r = 0; r < i; r++) {
    s.resetDsCurVal();
    const o = Z(s.restDecoder), a = Z(s.restDecoder), l = t.clients.get(o) || [], c = Me(t, o);
    for (let u = 0; u < a; u++) {
      const f = s.readDsClock(), d = f + s.readDsLen();
      if (f < c) {
        c < d && Ui(n, o, c, d - c);
        let g = Vt(l, f), p = l[g];
        for (!p.deleted && p.id.clock < f && (l.splice(g + 1, 0, so(e, p, f - p.id.clock)), g++); g < l.length && (p = l[g++], p.id.clock < d); )
          p.deleted || (d < p.id.clock + p.length && l.splice(g, 0, so(e, p, d - p.id.clock)), p.delete(e));
      } else
        Ui(n, o, f, d - f);
    }
  }
  if (n.clients.size > 0) {
    const r = new os();
    return K(r.restEncoder, 0), hi(r, n), r.toUint8Array();
  }
  return null;
}, Cu = fu;
class ui extends ou {
  /**
   * @param {DocOpts} opts configuration
   */
  constructor({ guid: e = Xp(), collectionid: t = null, gc: n = !0, gcFilter: i = () => !0, meta: r = null, autoLoad: o = !1, shouldLoad: a = !0 } = {}) {
    super(), this.gc = n, this.gcFilter = i, this.clientID = Cu(), this.guid = e, this.collectionid = t, this.share = /* @__PURE__ */ new Map(), this.store = new Iu(), this._transaction = null, this._transactionCleanups = [], this.subdocs = /* @__PURE__ */ new Set(), this._item = null, this.shouldLoad = a, this.autoLoad = o, this.meta = r, this.isLoaded = !1, this.isSynced = !1, this.whenLoaded = Mc((c) => {
      this.on("load", () => {
        this.isLoaded = !0, c(this);
      });
    });
    const l = () => Mc((c) => {
      const u = (f) => {
        (f === void 0 || f === !0) && (this.off("sync", u), c());
      };
      this.on("sync", u);
    });
    this.on("sync", (c) => {
      c === !1 && this.isSynced && (this.whenSynced = l()), this.isSynced = c === void 0 || c === !0, this.isSynced && !this.isLoaded && this.emit("load", [this]);
    }), this.whenSynced = l();
  }
  /**
   * Notify the parent document that you request to load data into this subdocument (if it is a subdocument).
   *
   * `load()` might be used in the future to request any provider to load the most current data.
   *
   * It is safe to call `load()` multiple times.
   */
  load() {
    const e = this._item;
    e !== null && !this.shouldLoad && ae(
      /** @type {any} */
      e.parent.doc,
      (t) => {
        t.subdocsLoaded.add(this);
      },
      null,
      !0
    ), this.shouldLoad = !0;
  }
  getSubdocs() {
    return this.subdocs;
  }
  getSubdocGuids() {
    return new Set(kn(this.subdocs).map((e) => e.guid));
  }
  /**
   * Changes that happen inside of a transaction are bundled. This means that
   * the observer fires _after_ the transaction is finished and that all changes
   * that happened inside of the transaction are sent as one message to the
   * other peers.
   *
   * @template T
   * @param {function(Transaction):T} f The function that should be executed as a transaction
   * @param {any} [origin] Origin of who started the transaction. Will be stored on transaction.origin
   * @return T
   *
   * @public
   */
  transact(e, t = null) {
    return ae(this, e, t);
  }
  /**
   * Define a shared data type.
   *
   * Multiple calls of `ydoc.get(name, TypeConstructor)` yield the same result
   * and do not overwrite each other. I.e.
   * `ydoc.get(name, Y.Array) === ydoc.get(name, Y.Array)`
   *
   * After this method is called, the type is also available on `ydoc.share.get(name)`.
   *
   * *Best Practices:*
   * Define all types right after the Y.Doc instance is created and store them in a separate object.
   * Also use the typed methods `getText(name)`, `getArray(name)`, ..
   *
   * @template {typeof AbstractType<any>} Type
   * @example
   *   const ydoc = new Y.Doc(..)
   *   const appState = {
   *     document: ydoc.getText('document')
   *     comments: ydoc.getArray('comments')
   *   }
   *
   * @param {string} name
   * @param {Type} TypeConstructor The constructor of the type definition. E.g. Y.Text, Y.Array, Y.Map, ...
   * @return {InstanceType<Type>} The created type. Constructed with TypeConstructor
   *
   * @public
   */
  get(e, t = (
    /** @type {any} */
    We
  )) {
    const n = jn(this.share, e, () => {
      const r = new t();
      return r._integrate(this, null), r;
    }), i = n.constructor;
    if (t !== We && i !== t)
      if (i === We) {
        const r = new t();
        r._map = n._map, n._map.forEach(
          /** @param {Item?} n */
          (o) => {
            for (; o !== null; o = o.left)
              o.parent = r;
          }
        ), r._start = n._start;
        for (let o = r._start; o !== null; o = o.right)
          o.parent = r;
        return r._length = n._length, this.share.set(e, r), r._integrate(this, null), /** @type {InstanceType<Type>} */
        r;
      } else
        throw new Error("Type with the name ".concat(e, " has already been defined with a different constructor"));
    return (
      /** @type {InstanceType<Type>} */
      n
    );
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YArray<T>}
   *
   * @public
   */
  getArray(e = "") {
    return (
      /** @type {YArray<T>} */
      this.get(e, _s)
    );
  }
  /**
   * @param {string} [name]
   * @return {YText}
   *
   * @public
   */
  getText(e = "") {
    return this.get(e, $s);
  }
  /**
   * @template T
   * @param {string} [name]
   * @return {YMap<T>}
   *
   * @public
   */
  getMap(e = "") {
    return (
      /** @type {YMap<T>} */
      this.get(e, Bs)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlElement}
   *
   * @public
   */
  getXmlElement(e = "") {
    return (
      /** @type {YXmlElement<{[key:string]:string}>} */
      this.get(e, Fs)
    );
  }
  /**
   * @param {string} [name]
   * @return {YXmlFragment}
   *
   * @public
   */
  getXmlFragment(e = "") {
    return this.get(e, as);
  }
  /**
   * Converts the entire document into a js object, recursively traversing each yjs type
   * Doesn't log types that have not been defined (using ydoc.getType(..)).
   *
   * @deprecated Do not use this method and rather call toJSON directly on the shared types.
   *
   * @return {Object<string, any>}
   */
  toJSON() {
    const e = {};
    return this.share.forEach((t, n) => {
      e[n] = t.toJSON();
    }), e;
  }
  /**
   * Emit `destroy` event and unregister all event handlers.
   */
  destroy() {
    kn(this.subdocs).forEach((t) => t.destroy());
    const e = this._item;
    if (e !== null) {
      this._item = null;
      const t = (
        /** @type {ContentDoc} */
        e.content
      );
      t.doc = new ui({ guid: this.guid, ...t.opts, shouldLoad: !1 }), t.doc._item = e, ae(
        /** @type {any} */
        e.parent.doc,
        (n) => {
          const i = t.doc;
          e.deleted || n.subdocsAdded.add(i), n.subdocsRemoved.add(this);
        },
        null,
        !0
      );
    }
    this.emit("destroyed", [!0]), this.emit("destroy", [this]), super.destroy();
  }
}
class Eu {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(e) {
    this.restDecoder = e;
  }
  resetDsCurVal() {
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return Z(this.restDecoder);
  }
  /**
   * @return {number}
   */
  readDsLen() {
    return Z(this.restDecoder);
  }
}
class Su extends Eu {
  /**
   * @return {ID}
   */
  readLeftID() {
    return X(Z(this.restDecoder), Z(this.restDecoder));
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return X(Z(this.restDecoder), Z(this.restDecoder));
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return Z(this.restDecoder);
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return Is(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readString() {
    return ts(this.restDecoder);
  }
  /**
   * @return {boolean} isKey
   */
  readParentInfo() {
    return Z(this.restDecoder) === 1;
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readTypeRef() {
    return Z(this.restDecoder);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number} len
   */
  readLen() {
    return Z(this.restDecoder);
  }
  /**
   * @return {any}
   */
  readAny() {
    return Vi(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return gm(lt(this.restDecoder));
  }
  /**
   * Legacy implementation uses JSON parse. We use any-decoding in v2.
   *
   * @return {any}
   */
  readJSON() {
    return JSON.parse(ts(this.restDecoder));
  }
  /**
   * @return {string}
   */
  readKey() {
    return ts(this.restDecoder);
  }
}
class Tm {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(e) {
    this.dsCurrVal = 0, this.restDecoder = e;
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @return {number}
   */
  readDsClock() {
    return this.dsCurrVal += Z(this.restDecoder), this.dsCurrVal;
  }
  /**
   * @return {number}
   */
  readDsLen() {
    const e = Z(this.restDecoder) + 1;
    return this.dsCurrVal += e, e;
  }
}
class Rs extends Tm {
  /**
   * @param {decoding.Decoder} decoder
   */
  constructor(e) {
    super(e), this.keys = [], Z(e), this.keyClockDecoder = new ra(lt(e)), this.clientDecoder = new zr(lt(e)), this.leftClockDecoder = new ra(lt(e)), this.rightClockDecoder = new ra(lt(e)), this.infoDecoder = new Ac(lt(e), Is), this.stringDecoder = new Wp(lt(e)), this.parentInfoDecoder = new Ac(lt(e), Is), this.typeRefDecoder = new zr(lt(e)), this.lenDecoder = new zr(lt(e));
  }
  /**
   * @return {ID}
   */
  readLeftID() {
    return new ks(this.clientDecoder.read(), this.leftClockDecoder.read());
  }
  /**
   * @return {ID}
   */
  readRightID() {
    return new ks(this.clientDecoder.read(), this.rightClockDecoder.read());
  }
  /**
   * Read the next client id.
   * Use this in favor of readID whenever possible to reduce the number of objects created.
   */
  readClient() {
    return this.clientDecoder.read();
  }
  /**
   * @return {number} info An unsigned 8-bit integer
   */
  readInfo() {
    return (
      /** @type {number} */
      this.infoDecoder.read()
    );
  }
  /**
   * @return {string}
   */
  readString() {
    return this.stringDecoder.read();
  }
  /**
   * @return {boolean}
   */
  readParentInfo() {
    return this.parentInfoDecoder.read() === 1;
  }
  /**
   * @return {number} An unsigned 8-bit integer
   */
  readTypeRef() {
    return this.typeRefDecoder.read();
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @return {number}
   */
  readLen() {
    return this.lenDecoder.read();
  }
  /**
   * @return {any}
   */
  readAny() {
    return Vi(this.restDecoder);
  }
  /**
   * @return {Uint8Array}
   */
  readBuf() {
    return lt(this.restDecoder);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @return {any}
   */
  readJSON() {
    return Vi(this.restDecoder);
  }
  /**
   * @return {string}
   */
  readKey() {
    const e = this.keyClockDecoder.read();
    if (e < this.keys.length)
      return this.keys[e];
    {
      const t = this.stringDecoder.read();
      return this.keys.push(t), t;
    }
  }
}
class Au {
  constructor() {
    this.restEncoder = lr();
  }
  toUint8Array() {
    return Pt(this.restEncoder);
  }
  resetDsCurVal() {
  }
  /**
   * @param {number} clock
   */
  writeDsClock(e) {
    K(this.restEncoder, e);
  }
  /**
   * @param {number} len
   */
  writeDsLen(e) {
    K(this.restEncoder, e);
  }
}
class hr extends Au {
  /**
   * @param {ID} id
   */
  writeLeftID(e) {
    K(this.restEncoder, e.client), K(this.restEncoder, e.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(e) {
    K(this.restEncoder, e.client), K(this.restEncoder, e.clock);
  }
  /**
   * Use writeClient and writeClock instead of writeID if possible.
   * @param {number} client
   */
  writeClient(e) {
    K(this.restEncoder, e);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(e) {
    Fi(this.restEncoder, e);
  }
  /**
   * @param {string} s
   */
  writeString(e) {
    es(this.restEncoder, e);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(e) {
    K(this.restEncoder, e ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(e) {
    K(this.restEncoder, e);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(e) {
    K(this.restEncoder, e);
  }
  /**
   * @param {any} any
   */
  writeAny(e) {
    zi(this.restEncoder, e);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(e) {
    at(this.restEncoder, e);
  }
  /**
   * @param {any} embed
   */
  writeJSON(e) {
    es(this.restEncoder, JSON.stringify(e));
  }
  /**
   * @param {string} key
   */
  writeKey(e) {
    es(this.restEncoder, e);
  }
}
class Mu {
  constructor() {
    this.restEncoder = lr(), this.dsCurrVal = 0;
  }
  toUint8Array() {
    return Pt(this.restEncoder);
  }
  resetDsCurVal() {
    this.dsCurrVal = 0;
  }
  /**
   * @param {number} clock
   */
  writeDsClock(e) {
    const t = e - this.dsCurrVal;
    this.dsCurrVal = e, K(this.restEncoder, t);
  }
  /**
   * @param {number} len
   */
  writeDsLen(e) {
    e === 0 && At(), K(this.restEncoder, e - 1), this.dsCurrVal += e;
  }
}
class os extends Mu {
  constructor() {
    super(), this.keyMap = /* @__PURE__ */ new Map(), this.keyClock = 0, this.keyClockEncoder = new ia(), this.clientEncoder = new Fr(), this.leftClockEncoder = new ia(), this.rightClockEncoder = new ia(), this.infoEncoder = new Cc(Fi), this.stringEncoder = new $p(), this.parentInfoEncoder = new Cc(Fi), this.typeRefEncoder = new Fr(), this.lenEncoder = new Fr();
  }
  toUint8Array() {
    const e = lr();
    return K(e, 0), at(e, this.keyClockEncoder.toUint8Array()), at(e, this.clientEncoder.toUint8Array()), at(e, this.leftClockEncoder.toUint8Array()), at(e, this.rightClockEncoder.toUint8Array()), at(e, Pt(this.infoEncoder)), at(e, this.stringEncoder.toUint8Array()), at(e, Pt(this.parentInfoEncoder)), at(e, this.typeRefEncoder.toUint8Array()), at(e, this.lenEncoder.toUint8Array()), Mo(e, Pt(this.restEncoder)), Pt(e);
  }
  /**
   * @param {ID} id
   */
  writeLeftID(e) {
    this.clientEncoder.write(e.client), this.leftClockEncoder.write(e.clock);
  }
  /**
   * @param {ID} id
   */
  writeRightID(e) {
    this.clientEncoder.write(e.client), this.rightClockEncoder.write(e.clock);
  }
  /**
   * @param {number} client
   */
  writeClient(e) {
    this.clientEncoder.write(e);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeInfo(e) {
    this.infoEncoder.write(e);
  }
  /**
   * @param {string} s
   */
  writeString(e) {
    this.stringEncoder.write(e);
  }
  /**
   * @param {boolean} isYKey
   */
  writeParentInfo(e) {
    this.parentInfoEncoder.write(e ? 1 : 0);
  }
  /**
   * @param {number} info An unsigned 8-bit integer
   */
  writeTypeRef(e) {
    this.typeRefEncoder.write(e);
  }
  /**
   * Write len of a struct - well suited for Opt RLE encoder.
   *
   * @param {number} len
   */
  writeLen(e) {
    this.lenEncoder.write(e);
  }
  /**
   * @param {any} any
   */
  writeAny(e) {
    zi(this.restEncoder, e);
  }
  /**
   * @param {Uint8Array} buf
   */
  writeBuf(e) {
    at(this.restEncoder, e);
  }
  /**
   * This is mainly here for legacy purposes.
   *
   * Initial we incoded objects using JSON. Now we use the much faster lib0/any-encoder. This method mainly exists for legacy purposes for the v1 encoder.
   *
   * @param {any} embed
   */
  writeJSON(e) {
    zi(this.restEncoder, e);
  }
  /**
   * Property keys are often reused. For example, in y-prosemirror the key `bold` might
   * occur very often. For a 3d application, the key `position` might occur very often.
   *
   * We cache these keys in a Map and refer to them via a unique number.
   *
   * @param {string} key
   */
  writeKey(e) {
    const t = this.keyMap.get(e);
    t === void 0 ? (this.keyClockEncoder.write(this.keyClock++), this.stringEncoder.write(e)) : this.keyClockEncoder.write(t);
  }
}
const Lm = (s, e, t, n) => {
  n = ms(n, e[0].id.clock);
  const i = Vt(e, n);
  K(s.restEncoder, e.length - i), s.writeClient(t), K(s.restEncoder, n);
  const r = e[i];
  r.write(s, n - r.id.clock);
  for (let o = i + 1; o < e.length; o++)
    e[o].write(s, 0);
}, Al = (s, e, t) => {
  const n = /* @__PURE__ */ new Map();
  t.forEach((i, r) => {
    Me(e, r) > i && n.set(r, i);
  }), _o(e).forEach((i, r) => {
    t.has(r) || n.set(r, 0);
  }), K(s.restEncoder, n.size), kn(n.entries()).sort((i, r) => r[0] - i[0]).forEach(([i, r]) => {
    Lm(
      s,
      /** @type {Array<GC|Item>} */
      e.clients.get(i),
      i,
      r
    );
  });
}, Dm = (s, e) => {
  const t = _t(), n = Z(s.restDecoder);
  for (let i = 0; i < n; i++) {
    const r = Z(s.restDecoder), o = new Array(r), a = s.readClient();
    let l = Z(s.restDecoder);
    t.set(a, { i: 0, refs: o });
    for (let c = 0; c < r; c++) {
      const u = s.readInfo();
      switch (So & u) {
        case 0: {
          const f = s.readLen();
          o[c] = new vt(X(a, l), f), l += f;
          break;
        }
        case 10: {
          const f = Z(s.restDecoder);
          o[c] = new xt(X(a, l), f), l += f;
          break;
        }
        default: {
          const f = (u & (sn | ut)) === 0, d = new he(
            X(a, l),
            null,
            // left
            (u & ut) === ut ? s.readLeftID() : null,
            // origin
            null,
            // right
            (u & sn) === sn ? s.readRightID() : null,
            // right origin
            f ? s.readParentInfo() ? e.get(s.readString()) : s.readLeftID() : null,
            // parent
            f && (u & Bi) === Bi ? s.readString() : null,
            // parentSub
            id(s, u)
            // item content
          );
          o[c] = d, l += d.length;
        }
      }
    }
  }
  return t;
}, Nm = (s, e, t) => {
  const n = [];
  let i = kn(t.keys()).sort((g, p) => g - p);
  if (i.length === 0)
    return null;
  const r = () => {
    if (i.length === 0)
      return null;
    let g = (
      /** @type {{i:number,refs:Array<GC|Item>}} */
      t.get(i[i.length - 1])
    );
    for (; g.refs.length === g.i; )
      if (i.pop(), i.length > 0)
        g = /** @type {{i:number,refs:Array<GC|Item>}} */
        t.get(i[i.length - 1]);
      else
        return null;
    return g;
  };
  let o = r();
  if (o === null)
    return null;
  const a = new Iu(), l = /* @__PURE__ */ new Map(), c = (g, p) => {
    const m = l.get(g);
    (m == null || m > p) && l.set(g, p);
  };
  let u = (
    /** @type {any} */
    o.refs[
      /** @type {any} */
      o.i++
    ]
  );
  const f = /* @__PURE__ */ new Map(), d = () => {
    for (const g of n) {
      const p = g.id.client, m = t.get(p);
      m ? (m.i--, a.clients.set(p, m.refs.slice(m.i)), t.delete(p), m.i = 0, m.refs = []) : a.clients.set(p, [g]), i = i.filter((w) => w !== p);
    }
    n.length = 0;
  };
  for (; ; ) {
    if (u.constructor !== xt) {
      const p = jn(f, u.id.client, () => Me(e, u.id.client)) - u.id.clock;
      if (p < 0)
        n.push(u), c(u.id.client, u.id.clock - 1), d();
      else {
        const m = u.getMissing(s, e);
        if (m !== null) {
          n.push(u);
          const w = t.get(
            /** @type {number} */
            m
          ) || { refs: [], i: 0 };
          if (w.refs.length === w.i)
            c(
              /** @type {number} */
              m,
              Me(e, m)
            ), d();
          else {
            u = w.refs[w.i++];
            continue;
          }
        } else
          (p === 0 || p < u.length) && (u.integrate(s, p), f.set(u.id.client, u.id.clock + u.length));
      }
    }
    if (n.length > 0)
      u = /** @type {GC|Item} */
      n.pop();
    else if (o !== null && o.i < o.refs.length)
      u = /** @type {GC|Item} */
      o.refs[o.i++];
    else {
      if (o = r(), o === null)
        break;
      u = /** @type {GC|Item} */
      o.refs[o.i++];
    }
  }
  if (a.clients.size > 0) {
    const g = new os();
    return Al(g, a, /* @__PURE__ */ new Map()), K(g.restEncoder, 0), { missing: l, update: g.toUint8Array() };
  }
  return null;
}, Im = (s, e) => Al(s, e.doc.store, e.beforeState), jm = (s, e, t, n = new Rs(s)) => ae(e, (i) => {
  i.local = !1;
  let r = !1;
  const o = i.doc, a = o.store, l = Dm(n, o), c = Nm(i, a, l), u = a.pendingStructs;
  if (u) {
    for (const [d, g] of u.missing)
      if (g < Me(a, d)) {
        r = !0;
        break;
      }
    if (c) {
      for (const [d, g] of c.missing) {
        const p = u.missing.get(d);
        (p == null || p > g) && u.missing.set(d, g);
      }
      u.update = Kr([u.update, c.update]);
    }
  } else
    a.pendingStructs = c;
  const f = _c(n, i, a);
  if (a.pendingDs) {
    const d = new Rs(ws(a.pendingDs));
    Z(d.restDecoder);
    const g = _c(d, i, a);
    f && g ? a.pendingDs = Kr([f, g]) : a.pendingDs = f || g;
  } else
    a.pendingDs = f;
  if (r) {
    const d = (
      /** @type {{update: Uint8Array}} */
      a.pendingStructs.update
    );
    a.pendingStructs = null, ku(i.doc, d);
  }
}, t, !1), ku = (s, e, t, n = Rs) => {
  const i = ws(e);
  jm(i, s, t, new n(i));
}, Rm = (s, e, t) => ku(s, e, t, Su), Bm = (s, e, t = /* @__PURE__ */ new Map()) => {
  Al(s, e.store, t), hi(s, Om(e.store));
}, $m = (s, e = new Uint8Array([0]), t = new os()) => {
  const n = Pu(e);
  Bm(t, s, n);
  const i = [t.toUint8Array()];
  if (s.store.pendingDs && i.push(s.store.pendingDs), s.store.pendingStructs && i.push(l1(s.store.pendingStructs.update, e)), i.length > 1) {
    if (t.constructor === hr)
      return o1(i.map((r, o) => o === 0 ? r : h1(r)));
    if (t.constructor === os)
      return Kr(i);
  }
  return i[0];
}, Fm = (s, e) => $m(s, e, new hr()), zm = (s) => {
  const e = /* @__PURE__ */ new Map(), t = Z(s.restDecoder);
  for (let n = 0; n < t; n++) {
    const i = Z(s.restDecoder), r = Z(s.restDecoder);
    e.set(i, r);
  }
  return e;
}, Pu = (s) => zm(new Eu(ws(s))), _u = (s, e) => (K(s.restEncoder, e.size), kn(e.entries()).sort((t, n) => n[0] - t[0]).forEach(([t, n]) => {
  K(s.restEncoder, t), K(s.restEncoder, n);
}), s), Vm = (s, e) => _u(s, _o(e.store)), Hm = (s, e = new Mu()) => (s instanceof Map ? _u(e, s) : Vm(e, s), e.toUint8Array()), Um = (s) => Hm(s, new Au());
class qm {
  constructor() {
    this.l = [];
  }
}
const Oc = () => new qm(), Tc = (s, e) => s.l.push(e), Lc = (s, e) => {
  const t = s.l, n = t.length;
  s.l = t.filter((i) => e !== i), n === s.l.length && console.error("[yjs] Tried to remove event handler that doesn't exist.");
}, Ou = (s, e, t) => vl(s.l, [e, t]);
class ks {
  /**
   * @param {number} client client id
   * @param {number} clock unique per client id, continuous number
   */
  constructor(e, t) {
    this.client = e, this.clock = t;
  }
}
const Ms = (s, e) => s === e || s !== null && e !== null && s.client === e.client && s.clock === e.clock, X = (s, e) => new ks(s, e), Dc = (s, e) => {
  K(s, e.client), K(s, e.clock);
}, Nc = (s) => X(Z(s), Z(s)), Tu = (s) => {
  for (const [e, t] of s.doc.share.entries())
    if (t === s)
      return e;
  throw At();
}, Zr = (s, e) => {
  for (; e !== null; ) {
    if (e.parent === s)
      return !0;
    e = /** @type {AbstractType<any>} */
    e.parent._item;
  }
  return !1;
};
class Ml {
  /**
   * @param {ID|null} type
   * @param {string|null} tname
   * @param {ID|null} item
   * @param {number} assoc
   */
  constructor(e, t, n, i = 0) {
    this.type = e, this.tname = t, this.item = n, this.assoc = i;
  }
}
const Gm = (s) => {
  var e;
  return new Ml(s.type == null ? null : X(s.type.client, s.type.clock), (e = s.tname) != null ? e : null, s.item == null ? null : X(s.item.client, s.item.clock), s.assoc == null ? 0 : s.assoc);
};
class Wm {
  /**
   * @param {AbstractType<any>} type
   * @param {number} index
   * @param {number} [assoc]
   */
  constructor(e, t, n = 0) {
    this.type = e, this.index = t, this.assoc = n;
  }
}
const Jm = (s, e, t = 0) => new Wm(s, e, t), Mr = (s, e, t) => {
  let n = null, i = null;
  return s._item === null ? i = Tu(s) : n = X(s._item.id.client, s._item.id.clock), new Ml(n, i, e, t);
}, Lu = (s, e, t = 0) => {
  let n = s._start;
  if (t < 0) {
    if (e === 0)
      return Mr(s, null, t);
    e--;
  }
  for (; n !== null; ) {
    if (!n.deleted && n.countable) {
      if (n.length > e)
        return Mr(s, X(n.id.client, n.id.clock + e), t);
      e -= n.length;
    }
    if (n.right === null && t < 0)
      return Mr(s, n.lastId, t);
    n = n.right;
  }
  return Mr(s, null, t);
}, Ym = (s, e) => {
  const { type: t, tname: n, item: i, assoc: r } = e;
  if (i !== null)
    K(s, 0), Dc(s, i);
  else if (n !== null)
    Fi(s, 1), es(s, n);
  else if (t !== null)
    Fi(s, 2), Dc(s, t);
  else
    throw At();
  return Ao(s, r), s;
}, Xm = (s) => {
  const e = lr();
  return Ym(e, s), Pt(e);
}, Zm = (s) => {
  let e = null, t = null, n = null;
  switch (Z(s)) {
    case 0:
      n = Nc(s);
      break;
    case 1:
      t = ts(s);
      break;
    case 2:
      e = Nc(s);
  }
  const i = du(s) ? Po(s) : 0;
  return new Ml(e, t, n, i);
}, Du = (s) => Zm(ws(s)), Nu = (s, e, t = !0) => {
  const n = e.store, i = s.item, r = s.type, o = s.tname, a = s.assoc;
  let l = null, c = 0;
  if (i !== null) {
    if (Me(n, i.client) <= i.clock)
      return null;
    const u = t ? za(n, i) : { item: Ps(n, i), diff: 0 }, f = u.item;
    if (!(f instanceof he))
      return null;
    if (l = /** @type {AbstractType<any>} */
    f.parent, l._item === null || !l._item.deleted) {
      c = f.deleted || !f.countable ? 0 : u.diff + (a >= 0 ? 0 : 1);
      let d = f.left;
      for (; d !== null; )
        !d.deleted && d.countable && (c += d.length), d = d.left;
    }
  } else {
    if (o !== null)
      l = e.get(o);
    else if (r !== null) {
      if (Me(n, r.client) <= r.clock)
        return null;
      const { item: u } = t ? za(n, r) : { item: Ps(n, r) };
      if (u instanceof he && u.content instanceof Gt)
        l = u.content.type;
      else
        return null;
    } else
      throw At();
    a >= 0 ? c = l._length : c = 0;
  }
  return Jm(l, c, s.assoc);
}, Ic = (s, e) => s === e || s !== null && e !== null && s.tname === e.tname && Ms(s.item, e.item) && Ms(s.type, e.type) && s.assoc === e.assoc, Ss = (s, e) => e === void 0 ? !s.deleted : e.sv.has(s.id.client) && (e.sv.get(s.id.client) || 0) > s.id.clock && !cr(e.ds, s.id), Ba = (s, e) => {
  const t = jn(s.meta, Ba, Ns), n = s.doc.store;
  t.has(e) || (e.sv.forEach((i, r) => {
    i < Me(n, r) && nt(s, X(r, i));
  }), js(s, e.ds, (i) => {
  }), t.add(e));
};
class Iu {
  constructor() {
    this.clients = /* @__PURE__ */ new Map(), this.pendingStructs = null, this.pendingDs = null;
  }
}
const _o = (s) => {
  const e = /* @__PURE__ */ new Map();
  return s.clients.forEach((t, n) => {
    const i = t[t.length - 1];
    e.set(n, i.id.clock + i.length);
  }), e;
}, Me = (s, e) => {
  const t = s.clients.get(e);
  if (t === void 0)
    return 0;
  const n = t[t.length - 1];
  return n.id.clock + n.length;
}, ju = (s, e) => {
  let t = s.clients.get(e.id.client);
  if (t === void 0)
    t = [], s.clients.set(e.id.client, t);
  else {
    const n = t[t.length - 1];
    if (n.id.clock + n.length !== e.id.clock)
      throw At();
  }
  t.push(e);
}, Vt = (s, e) => {
  let t = 0, n = s.length - 1, i = s[n], r = i.id.clock;
  if (r === e)
    return n;
  let o = Pn(e / (r + i.length - 1) * n);
  for (; t <= n; ) {
    if (i = s[o], r = i.id.clock, r <= e) {
      if (e < r + i.length)
        return o;
      t = o + 1;
    } else
      n = o - 1;
    o = Pn((t + n) / 2);
  }
  throw At();
}, Km = (s, e) => {
  const t = s.clients.get(e.client);
  return t[Vt(t, e.clock)];
}, Ps = (
  /** @type {function(StructStore,ID):Item} */
  Km
), $a = (s, e, t) => {
  const n = Vt(e, t), i = e[n];
  return i.id.clock < t && i instanceof he ? (e.splice(n + 1, 0, so(s, i, t - i.id.clock)), n + 1) : n;
}, nt = (s, e) => {
  const t = (
    /** @type {Array<Item>} */
    s.doc.store.clients.get(e.client)
  );
  return t[$a(s, t, e.clock)];
}, jc = (s, e, t) => {
  const n = e.clients.get(t.client), i = Vt(n, t.clock), r = n[i];
  return t.clock !== r.id.clock + r.length - 1 && r.constructor !== vt && n.splice(i + 1, 0, so(s, r, t.clock - r.id.clock + 1)), r;
}, Qm = (s, e, t) => {
  const n = (
    /** @type {Array<GC|Item>} */
    s.clients.get(e.id.client)
  );
  n[Vt(n, e.id.clock)] = t;
}, Ru = (s, e, t, n, i) => {
  if (n === 0)
    return;
  const r = t + n;
  let o = $a(s, e, t), a;
  do
    a = e[o++], r < a.id.clock + a.length && $a(s, e, r), i(a);
  while (o < e.length && e[o].id.clock < r);
};
class e1 {
  /**
   * @param {Doc} doc
   * @param {any} origin
   * @param {boolean} local
   */
  constructor(e, t, n) {
    this.doc = e, this.deleteSet = new ci(), this.beforeState = _o(e.store), this.afterState = /* @__PURE__ */ new Map(), this.changed = /* @__PURE__ */ new Map(), this.changedParentTypes = /* @__PURE__ */ new Map(), this._mergeStructs = [], this.origin = t, this.meta = /* @__PURE__ */ new Map(), this.local = n, this.subdocsAdded = /* @__PURE__ */ new Set(), this.subdocsRemoved = /* @__PURE__ */ new Set(), this.subdocsLoaded = /* @__PURE__ */ new Set(), this._needFormattingCleanup = !1;
  }
}
const Rc = (s, e) => e.deleteSet.clients.size === 0 && !yp(e.afterState, (t, n) => e.beforeState.get(n) !== t) ? !1 : (El(e.deleteSet), Im(s, e), hi(s, e.deleteSet), !0), Bc = (s, e, t) => {
  const n = e._item;
  (n === null || n.id.clock < (s.beforeState.get(n.id.client) || 0) && !n.deleted) && jn(s.changed, e, Ns).add(t);
}, Vr = (s, e) => {
  let t = s[e], n = s[e - 1], i = e;
  for (; i > 0; t = n, n = s[--i - 1]) {
    if (n.deleted === t.deleted && n.constructor === t.constructor && n.mergeWith(t)) {
      t instanceof he && t.parentSub !== null && /** @type {AbstractType<any>} */
      t.parent._map.get(t.parentSub) === t && t.parent._map.set(
        t.parentSub,
        /** @type {Item} */
        n
      );
      continue;
    }
    break;
  }
  const r = e - i;
  return r && s.splice(e + 1 - r, r), r;
}, t1 = (s, e, t) => {
  for (const [n, i] of s.clients.entries()) {
    const r = (
      /** @type {Array<GC|Item>} */
      e.clients.get(n)
    );
    for (let o = i.length - 1; o >= 0; o--) {
      const a = i[o], l = a.clock + a.len;
      for (let c = Vt(r, a.clock), u = r[c]; c < r.length && u.id.clock < l; u = r[++c]) {
        const f = r[c];
        if (a.clock + a.len <= f.id.clock)
          break;
        f instanceof he && f.deleted && !f.keep && t(f) && f.gc(e, !1);
      }
    }
  }
}, n1 = (s, e) => {
  s.clients.forEach((t, n) => {
    const i = (
      /** @type {Array<GC|Item>} */
      e.clients.get(n)
    );
    for (let r = t.length - 1; r >= 0; r--) {
      const o = t[r], a = au(i.length - 1, 1 + Vt(i, o.clock + o.len - 1));
      for (let l = a, c = i[l]; l > 0 && c.id.clock >= o.clock; c = i[l])
        l -= 1 + Vr(i, l);
    }
  });
}, Bu = (s, e) => {
  if (e < s.length) {
    const t = s[e], n = t.doc, i = n.store, r = t.deleteSet, o = t._mergeStructs;
    try {
      El(r), t.afterState = _o(t.doc.store), n.emit("beforeObserverCalls", [t, n]);
      const a = [];
      t.changed.forEach(
        (l, c) => a.push(() => {
          (c._item === null || !c._item.deleted) && c._callObserver(t, l);
        })
      ), a.push(() => {
        t.changedParentTypes.forEach((l, c) => {
          c._dEH.l.length > 0 && (c._item === null || !c._item.deleted) && (l = l.filter(
            (u) => u.target._item === null || !u.target._item.deleted
          ), l.forEach((u) => {
            u.currentTarget = c, u._path = null;
          }), l.sort((u, f) => u.path.length - f.path.length), Ou(c._dEH, l, t));
        });
      }), a.push(() => n.emit("afterTransaction", [t, n])), vl(a, []), t._needFormattingCleanup && S1(t);
    } finally {
      n.gc && t1(r, i, n.gcFilter), n1(r, i), t.afterState.forEach((u, f) => {
        const d = t.beforeState.get(f) || 0;
        if (d !== u) {
          const g = (
            /** @type {Array<GC|Item>} */
            i.clients.get(f)
          ), p = ms(Vt(g, d), 1);
          for (let m = g.length - 1; m >= p; )
            m -= 1 + Vr(g, m);
        }
      });
      for (let u = o.length - 1; u >= 0; u--) {
        const { client: f, clock: d } = o[u].id, g = (
          /** @type {Array<GC|Item>} */
          i.clients.get(f)
        ), p = Vt(g, d);
        p + 1 < g.length && Vr(g, p + 1) > 1 || p > 0 && Vr(g, p);
      }
      if (!t.local && t.afterState.get(n.clientID) !== t.beforeState.get(n.clientID) && (Am(xl, mu, "[yjs] ", wu, yu, "Changed the client-id because another client seems to be using it."), n.clientID = Cu()), n.emit("afterTransactionCleanup", [t, n]), n._observers.has("update")) {
        const u = new hr();
        Rc(u, t) && n.emit("update", [u.toUint8Array(), t.origin, n, t]);
      }
      if (n._observers.has("updateV2")) {
        const u = new os();
        Rc(u, t) && n.emit("updateV2", [u.toUint8Array(), t.origin, n, t]);
      }
      const { subdocsAdded: a, subdocsLoaded: l, subdocsRemoved: c } = t;
      (a.size > 0 || c.size > 0 || l.size > 0) && (a.forEach((u) => {
        u.clientID = n.clientID, u.collectionid == null && (u.collectionid = n.collectionid), n.subdocs.add(u);
      }), c.forEach((u) => n.subdocs.delete(u)), n.emit("subdocs", [{ loaded: l, added: a, removed: c }, n, t]), c.forEach((u) => u.destroy())), s.length <= e + 1 ? (n._transactionCleanups = [], n.emit("afterAllTransactions", [n, s])) : Bu(s, e + 1);
    }
  }
}, ae = (s, e, t = null, n = !0) => {
  const i = s._transactionCleanups;
  let r = !1, o = null;
  s._transaction === null && (r = !0, s._transaction = new e1(s, t, n), i.push(s._transaction), i.length === 1 && s.emit("beforeAllTransactions", [s]), s.emit("beforeTransaction", [s._transaction, s]));
  try {
    o = e(s._transaction);
  } finally {
    if (r) {
      const a = s._transaction === i[0];
      s._transaction = null, a && Bu(i, 0);
    }
  }
  return o;
};
class s1 {
  /**
   * @param {DeleteSet} deletions
   * @param {DeleteSet} insertions
   */
  constructor(e, t) {
    this.insertions = t, this.deletions = e, this.meta = /* @__PURE__ */ new Map();
  }
}
const $c = (s, e, t) => {
  js(s, t.deletions, (n) => {
    n instanceof he && e.scope.some((i) => Zr(i, n)) && Nl(n, !1);
  });
}, Fc = (s, e, t) => {
  let n = null;
  const i = s.doc, r = s.scope;
  ae(i, (a) => {
    for (; e.length > 0 && s.currStackItem === null; ) {
      const l = i.store, c = (
        /** @type {StackItem} */
        e.pop()
      ), u = /* @__PURE__ */ new Set(), f = [];
      let d = !1;
      js(a, c.insertions, (g) => {
        if (g instanceof he) {
          if (g.redone !== null) {
            let { item: p, diff: m } = za(l, g.id);
            m > 0 && (p = nt(a, X(p.id.client, p.id.clock + m))), g = p;
          }
          !g.deleted && r.some((p) => Zr(
            p,
            /** @type {Item} */
            g
          )) && f.push(g);
        }
      }), js(a, c.deletions, (g) => {
        g instanceof he && r.some((p) => Zr(p, g)) && // Never redo structs in stackItem.insertions because they were created and deleted in the same capture interval.
        !cr(c.insertions, g.id) && u.add(g);
      }), u.forEach((g) => {
        d = sd(a, g, u, c.insertions, s.ignoreRemoteMapChanges, s) !== null || d;
      });
      for (let g = f.length - 1; g >= 0; g--) {
        const p = f[g];
        s.deleteFilter(p) && (p.delete(a), d = !0);
      }
      s.currStackItem = d ? c : null;
    }
    a.changed.forEach((l, c) => {
      l.has(null) && c._searchMarker && (c._searchMarker.length = 0);
    }), n = a;
  }, s);
  const o = s.currStackItem;
  if (o != null) {
    const a = n.changedParentTypes;
    s.emit("stack-item-popped", [{ stackItem: o, type: t, changedParentTypes: a, origin: s }, s]), s.currStackItem = null;
  }
  return o;
};
class i1 extends ou {
  /**
   * @param {AbstractType<any>|Array<AbstractType<any>>} typeScope Accepts either a single type, or an array of types
   * @param {UndoManagerOptions} options
   */
  constructor(e, {
    captureTimeout: t = 500,
    captureTransaction: n = (l) => !0,
    deleteFilter: i = () => !0,
    trackedOrigins: r = /* @__PURE__ */ new Set([null]),
    ignoreRemoteMapChanges: o = !1,
    doc: a = (
      /** @type {Doc} */
      La(e) ? e[0].doc : e.doc
    )
  } = {}) {
    super(), this.scope = [], this.doc = a, this.addToScope(e), this.deleteFilter = i, r.add(this), this.trackedOrigins = r, this.captureTransaction = n, this.undoStack = [], this.redoStack = [], this.undoing = !1, this.redoing = !1, this.currStackItem = null, this.lastChange = 0, this.ignoreRemoteMapChanges = o, this.captureTimeout = t, this.afterTransactionHandler = (l) => {
      if (!this.captureTransaction(l) || !this.scope.some((w) => l.changedParentTypes.has(w)) || !this.trackedOrigins.has(l.origin) && (!l.origin || !this.trackedOrigins.has(l.origin.constructor)))
        return;
      const c = this.undoing, u = this.redoing, f = c ? this.redoStack : this.undoStack;
      c ? this.stopCapturing() : u || this.clear(!1, !0);
      const d = new ci();
      l.afterState.forEach((w, v) => {
        const y = l.beforeState.get(v) || 0, b = w - y;
        b > 0 && Ui(d, v, y, b);
      });
      const g = Zp();
      let p = !1;
      if (this.lastChange > 0 && g - this.lastChange < this.captureTimeout && f.length > 0 && !c && !u) {
        const w = f[f.length - 1];
        w.deletions = Ra([w.deletions, l.deleteSet]), w.insertions = Ra([w.insertions, d]);
      } else
        f.push(new s1(l.deleteSet, d)), p = !0;
      !c && !u && (this.lastChange = g), js(
        l,
        l.deleteSet,
        /** @param {Item|GC} item */
        (w) => {
          w instanceof he && this.scope.some((v) => Zr(v, w)) && Nl(w, !0);
        }
      );
      const m = [{ stackItem: f[f.length - 1], origin: l.origin, type: c ? "redo" : "undo", changedParentTypes: l.changedParentTypes }, this];
      p ? this.emit("stack-item-added", m) : this.emit("stack-item-updated", m);
    }, this.doc.on("afterTransaction", this.afterTransactionHandler), this.doc.on("destroy", () => {
      this.destroy();
    });
  }
  /**
   * @param {Array<AbstractType<any>> | AbstractType<any>} ytypes
   */
  addToScope(e) {
    e = La(e) ? e : [e], e.forEach((t) => {
      this.scope.every((n) => n !== t) && (t.doc !== this.doc && Mm("[yjs#509] Not same Y.Doc"), this.scope.push(t));
    });
  }
  /**
   * @param {any} origin
   */
  addTrackedOrigin(e) {
    this.trackedOrigins.add(e);
  }
  /**
   * @param {any} origin
   */
  removeTrackedOrigin(e) {
    this.trackedOrigins.delete(e);
  }
  clear(e = !0, t = !0) {
    (e && this.canUndo() || t && this.canRedo()) && this.doc.transact((n) => {
      e && (this.undoStack.forEach((i) => $c(n, this, i)), this.undoStack = []), t && (this.redoStack.forEach((i) => $c(n, this, i)), this.redoStack = []), this.emit("stack-cleared", [{ undoStackCleared: e, redoStackCleared: t }]);
    });
  }
  /**
   * UndoManager merges Undo-StackItem if they are created within time-gap
   * smaller than `options.captureTimeout`. Call `um.stopCapturing()` so that the next
   * StackItem won't be merged.
   *
   *
   * @example
   *     // without stopCapturing
   *     ytext.insert(0, 'a')
   *     ytext.insert(1, 'b')
   *     um.undo()
   *     ytext.toString() // => '' (note that 'ab' was removed)
   *     // with stopCapturing
   *     ytext.insert(0, 'a')
   *     um.stopCapturing()
   *     ytext.insert(0, 'b')
   *     um.undo()
   *     ytext.toString() // => 'a' (note that only 'b' was removed)
   *
   */
  stopCapturing() {
    this.lastChange = 0;
  }
  /**
   * Undo last changes on type.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  undo() {
    this.undoing = !0;
    let e;
    try {
      e = Fc(this, this.undoStack, "undo");
    } finally {
      this.undoing = !1;
    }
    return e;
  }
  /**
   * Redo last undo operation.
   *
   * @return {StackItem?} Returns StackItem if a change was applied
   */
  redo() {
    this.redoing = !0;
    let e;
    try {
      e = Fc(this, this.redoStack, "redo");
    } finally {
      this.redoing = !1;
    }
    return e;
  }
  /**
   * Are undo steps available?
   *
   * @return {boolean} `true` if undo is possible
   */
  canUndo() {
    return this.undoStack.length > 0;
  }
  /**
   * Are redo steps available?
   *
   * @return {boolean} `true` if redo is possible
   */
  canRedo() {
    return this.redoStack.length > 0;
  }
  destroy() {
    this.trackedOrigins.delete(this), this.doc.off("afterTransaction", this.afterTransactionHandler), super.destroy();
  }
}
function* r1(s) {
  const e = Z(s.restDecoder);
  for (let t = 0; t < e; t++) {
    const n = Z(s.restDecoder), i = s.readClient();
    let r = Z(s.restDecoder);
    for (let o = 0; o < n; o++) {
      const a = s.readInfo();
      if (a === 10) {
        const l = Z(s.restDecoder);
        yield new xt(X(i, r), l), r += l;
      } else if (So & a) {
        const l = (a & (sn | ut)) === 0, c = new he(
          X(i, r),
          null,
          // left
          (a & ut) === ut ? s.readLeftID() : null,
          // origin
          null,
          // right
          (a & sn) === sn ? s.readRightID() : null,
          // right origin
          // @ts-ignore Force writing a string here.
          l ? s.readParentInfo() ? s.readString() : s.readLeftID() : null,
          // parent
          l && (a & Bi) === Bi ? s.readString() : null,
          // parentSub
          id(s, a)
          // item content
        );
        yield c, r += c.length;
      } else {
        const l = s.readLen();
        yield new vt(X(i, r), l), r += l;
      }
    }
  }
}
class kl {
  /**
   * @param {UpdateDecoderV1 | UpdateDecoderV2} decoder
   * @param {boolean} filterSkips
   */
  constructor(e, t) {
    this.gen = r1(e), this.curr = null, this.done = !1, this.filterSkips = t, this.next();
  }
  /**
   * @return {Item | GC | Skip |null}
   */
  next() {
    do
      this.curr = this.gen.next().value || null;
    while (this.filterSkips && this.curr !== null && this.curr.constructor === xt);
    return this.curr;
  }
}
class Pl {
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  constructor(e) {
    this.currClient = 0, this.startClock = 0, this.written = 0, this.encoder = e, this.clientStructs = [];
  }
}
const o1 = (s) => Kr(s, Su, hr), a1 = (s, e) => {
  if (s.constructor === vt) {
    const { client: t, clock: n } = s.id;
    return new vt(X(t, n + e), s.length - e);
  } else if (s.constructor === xt) {
    const { client: t, clock: n } = s.id;
    return new xt(X(t, n + e), s.length - e);
  } else {
    const t = (
      /** @type {Item} */
      s
    ), { client: n, clock: i } = t.id;
    return new he(
      X(n, i + e),
      null,
      X(n, i + e - 1),
      null,
      t.rightOrigin,
      t.parent,
      t.parentSub,
      t.content.splice(e)
    );
  }
}, Kr = (s, e = Rs, t = os) => {
  if (s.length === 1)
    return s[0];
  const n = s.map((u) => new e(ws(u)));
  let i = n.map((u) => new kl(u, !0)), r = null;
  const o = new t(), a = new Pl(o);
  for (; i = i.filter((d) => d.curr !== null), i.sort(
    /** @type {function(any,any):number} */
    (d, g) => {
      if (d.curr.id.client === g.curr.id.client) {
        const p = d.curr.id.clock - g.curr.id.clock;
        return p === 0 ? d.curr.constructor === g.curr.constructor ? 0 : d.curr.constructor === xt ? 1 : -1 : p;
      } else
        return g.curr.id.client - d.curr.id.client;
    }
  ), i.length !== 0; ) {
    const u = i[0], f = (
      /** @type {Item | GC} */
      u.curr.id.client
    );
    if (r !== null) {
      let d = (
        /** @type {Item | GC | null} */
        u.curr
      ), g = !1;
      for (; d !== null && d.id.clock + d.length <= r.struct.id.clock + r.struct.length && d.id.client >= r.struct.id.client; )
        d = u.next(), g = !0;
      if (d === null || // current decoder is empty
      d.id.client !== f || // check whether there is another decoder that has has updates from `firstClient`
      g && d.id.clock > r.struct.id.clock + r.struct.length)
        continue;
      if (f !== r.struct.id.client)
        bn(a, r.struct, r.offset), r = { struct: d, offset: 0 }, u.next();
      else if (r.struct.id.clock + r.struct.length < d.id.clock)
        if (r.struct.constructor === xt)
          r.struct.length = d.id.clock + d.length - r.struct.id.clock;
        else {
          bn(a, r.struct, r.offset);
          const p = d.id.clock - r.struct.id.clock - r.struct.length;
          r = { struct: new xt(X(f, r.struct.id.clock + r.struct.length), p), offset: 0 };
        }
      else {
        const p = r.struct.id.clock + r.struct.length - d.id.clock;
        p > 0 && (r.struct.constructor === xt ? r.struct.length -= p : d = a1(d, p)), r.struct.mergeWith(
          /** @type {any} */
          d
        ) || (bn(a, r.struct, r.offset), r = { struct: d, offset: 0 }, u.next());
      }
    } else
      r = { struct: (
        /** @type {Item | GC} */
        u.curr
      ), offset: 0 }, u.next();
    for (let d = u.curr; d !== null && d.id.client === f && d.id.clock === r.struct.id.clock + r.struct.length && d.constructor !== xt; d = u.next())
      bn(a, r.struct, r.offset), r = { struct: d, offset: 0 };
  }
  r !== null && (bn(a, r.struct, r.offset), r = null), _l(a);
  const l = n.map((u) => Sl(u)), c = Ra(l);
  return hi(o, c), o.toUint8Array();
}, l1 = (s, e, t = Rs, n = os) => {
  const i = Pu(e), r = new n(), o = new Pl(r), a = new t(ws(s)), l = new kl(a, !1);
  for (; l.curr; ) {
    const u = l.curr, f = u.id.client, d = i.get(f) || 0;
    if (l.curr.constructor === xt) {
      l.next();
      continue;
    }
    if (u.id.clock + u.length > d)
      for (bn(o, u, ms(d - u.id.clock, 0)), l.next(); l.curr && l.curr.id.client === f; )
        bn(o, l.curr, 0), l.next();
    else
      for (; l.curr && l.curr.id.client === f && l.curr.id.clock + l.curr.length <= d; )
        l.next();
  }
  _l(o);
  const c = Sl(a);
  return hi(r, c), r.toUint8Array();
}, $u = (s) => {
  s.written > 0 && (s.clientStructs.push({ written: s.written, restEncoder: Pt(s.encoder.restEncoder) }), s.encoder.restEncoder = lr(), s.written = 0);
}, bn = (s, e, t) => {
  s.written > 0 && s.currClient !== e.id.client && $u(s), s.written === 0 && (s.currClient = e.id.client, s.encoder.writeClient(e.id.client), K(s.encoder.restEncoder, e.id.clock + t)), e.write(s.encoder, t), s.written++;
}, _l = (s) => {
  $u(s);
  const e = s.encoder.restEncoder;
  K(e, s.clientStructs.length);
  for (let t = 0; t < s.clientStructs.length; t++) {
    const n = s.clientStructs[t];
    K(e, n.written), Mo(e, n.restEncoder);
  }
}, c1 = (s, e, t, n) => {
  const i = new t(ws(s)), r = new kl(i, !1), o = new n(), a = new Pl(o);
  for (let c = r.curr; c !== null; c = r.next())
    bn(a, e(c), 0);
  _l(a);
  const l = Sl(i);
  return hi(o, l), o.toUint8Array();
}, h1 = (s) => c1(s, lm, Rs, hr), zc = "You must not compute changes after the event-handler fired.";
class Oo {
  /**
   * @param {T} target The changed type.
   * @param {Transaction} transaction
   */
  constructor(e, t) {
    this.target = e, this.currentTarget = e, this.transaction = t, this._changes = null, this._keys = null, this._delta = null, this._path = null;
  }
  /**
   * Computes the path from `y` to the changed type.
   *
   * @todo v14 should standardize on path: Array<{parent, index}> because that is easier to work with.
   *
   * The following property holds:
   * @example
   *   let type = y
   *   event.path.forEach(dir => {
   *     type = type.get(dir)
   *   })
   *   type === event.target // => true
   */
  get path() {
    return this._path || (this._path = u1(this.currentTarget, this.target));
  }
  /**
   * Check if a struct is deleted by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  deletes(e) {
    return cr(this.transaction.deleteSet, e.id);
  }
  /**
   * @type {Map<string, { action: 'add' | 'update' | 'delete', oldValue: any, newValue: any }>}
   */
  get keys() {
    if (this._keys === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw _n(zc);
      const e = /* @__PURE__ */ new Map(), t = this.target;
      /** @type Set<string|null> */
      this.transaction.changed.get(t).forEach((i) => {
        if (i !== null) {
          const r = (
            /** @type {Item} */
            t._map.get(i)
          );
          let o, a;
          if (this.adds(r)) {
            let l = r.left;
            for (; l !== null && this.adds(l); )
              l = l.left;
            if (this.deletes(r))
              if (l !== null && this.deletes(l))
                o = "delete", a = ta(l.content.getContent());
              else
                return;
            else
              l !== null && this.deletes(l) ? (o = "update", a = ta(l.content.getContent())) : (o = "add", a = void 0);
          } else if (this.deletes(r))
            o = "delete", a = ta(
              /** @type {Item} */
              r.content.getContent()
            );
          else
            return;
          e.set(i, { action: o, oldValue: a });
        }
      }), this._keys = e;
    }
    return this._keys;
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {Array<{insert?: string | Array<any> | object | AbstractType<any>, retain?: number, delete?: number, attributes?: Object<string, any>}>}
   */
  get delta() {
    return this.changes.delta;
  }
  /**
   * Check if a struct is added by this event.
   *
   * In contrast to change.deleted, this method also returns true if the struct was added and then deleted.
   *
   * @param {AbstractStruct} struct
   * @return {boolean}
   */
  adds(e) {
    return e.id.clock >= (this.transaction.beforeState.get(e.id.client) || 0);
  }
  /**
   * This is a computed property. Note that this can only be safely computed during the
   * event call. Computing this property after other changes happened might result in
   * unexpected behavior (incorrect computation of deltas). A safe way to collect changes
   * is to store the `changes` or the `delta` object. Avoid storing the `transaction` object.
   *
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    let e = this._changes;
    if (e === null) {
      if (this.transaction.doc._transactionCleanups.length === 0)
        throw _n(zc);
      const t = this.target, n = Ns(), i = Ns(), r = [];
      if (e = {
        added: n,
        deleted: i,
        delta: r,
        keys: this.keys
      }, /** @type Set<string|null> */
      this.transaction.changed.get(t).has(null)) {
        let a = null;
        const l = () => {
          a && r.push(a);
        };
        for (let c = t._start; c !== null; c = c.right)
          c.deleted ? this.deletes(c) && !this.adds(c) && ((a === null || a.delete === void 0) && (l(), a = { delete: 0 }), a.delete += c.length, i.add(c)) : this.adds(c) ? ((a === null || a.insert === void 0) && (l(), a = { insert: [] }), a.insert = a.insert.concat(c.content.getContent()), n.add(c)) : ((a === null || a.retain === void 0) && (l(), a = { retain: 0 }), a.retain += c.length);
        a !== null && a.retain === void 0 && l();
      }
      this._changes = e;
    }
    return (
      /** @type {any} */
      e
    );
  }
}
const u1 = (s, e) => {
  const t = [];
  for (; e._item !== null && e !== s; ) {
    if (e._item.parentSub !== null)
      t.unshift(e._item.parentSub);
    else {
      let n = 0, i = (
        /** @type {AbstractType<any>} */
        e._item.parent._start
      );
      for (; i !== e._item && i !== null; )
        !i.deleted && i.countable && (n += i.length), i = i.right;
      t.unshift(n);
    }
    e = /** @type {AbstractType<any>} */
    e._item.parent;
  }
  return t;
}, Fu = 80;
let Ol = 0;
class d1 {
  /**
   * @param {Item} p
   * @param {number} index
   */
  constructor(e, t) {
    e.marker = !0, this.p = e, this.index = t, this.timestamp = Ol++;
  }
}
const f1 = (s) => {
  s.timestamp = Ol++;
}, zu = (s, e, t) => {
  s.p.marker = !1, s.p = e, e.marker = !0, s.index = t, s.timestamp = Ol++;
}, g1 = (s, e, t) => {
  if (s.length >= Fu) {
    const n = s.reduce((i, r) => i.timestamp < r.timestamp ? i : r);
    return zu(n, e, t), n;
  } else {
    const n = new d1(e, t);
    return s.push(n), n;
  }
}, To = (s, e) => {
  if (s._start === null || e === 0 || s._searchMarker === null)
    return null;
  const t = s._searchMarker.length === 0 ? null : s._searchMarker.reduce((r, o) => $r(e - r.index) < $r(e - o.index) ? r : o);
  let n = s._start, i = 0;
  for (t !== null && (n = t.p, i = t.index, f1(t)); n.right !== null && i < e; ) {
    if (!n.deleted && n.countable) {
      if (e < i + n.length)
        break;
      i += n.length;
    }
    n = n.right;
  }
  for (; n.left !== null && i > e; )
    n = n.left, !n.deleted && n.countable && (i -= n.length);
  for (; n.left !== null && n.left.id.client === n.id.client && n.left.id.clock + n.left.length === n.id.clock; )
    n = n.left, !n.deleted && n.countable && (i -= n.length);
  return t !== null && $r(t.index - i) < /** @type {YText|YArray<any>} */
  n.parent.length / Fu ? (zu(t, n, i), t) : g1(s._searchMarker, n, i);
}, qi = (s, e, t) => {
  for (let n = s.length - 1; n >= 0; n--) {
    const i = s[n];
    if (t > 0) {
      let r = i.p;
      for (r.marker = !1; r && (r.deleted || !r.countable); )
        r = r.left, r && !r.deleted && r.countable && (i.index -= r.length);
      if (r === null || r.marker === !0) {
        s.splice(n, 1);
        continue;
      }
      i.p = r, r.marker = !0;
    }
    (e < i.index || t > 0 && e === i.index) && (i.index = ms(e, i.index + t));
  }
}, Lo = (s, e, t) => {
  const n = s, i = e.changedParentTypes;
  for (; jn(i, s, () => []).push(t), s._item !== null; )
    s = /** @type {AbstractType<any>} */
    s._item.parent;
  Ou(n._eH, t, e);
};
class We {
  constructor() {
    this._item = null, this._map = /* @__PURE__ */ new Map(), this._start = null, this.doc = null, this._length = 0, this._eH = Oc(), this._dEH = Oc(), this._searchMarker = null;
  }
  /**
   * @return {AbstractType<any>|null}
   */
  get parent() {
    return this._item ? (
      /** @type {AbstractType<any>} */
      this._item.parent
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item|null} item
   */
  _integrate(e, t) {
    this.doc = e, this._item = t;
  }
  /**
   * @return {AbstractType<EventType>}
   */
  _copy() {
    throw Ft();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {AbstractType<EventType>}
   */
  clone() {
    throw Ft();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} _encoder
   */
  _write(e) {
  }
  /**
   * The first non-deleted item
   */
  get _first() {
    let e = this._start;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  /**
   * Creates YEvent and calls all type observers.
   * Must be implemented by each type.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} _parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, t) {
    !e.local && this._searchMarker && (this._searchMarker.length = 0);
  }
  /**
   * Observe all events that are created on this type.
   *
   * @param {function(EventType, Transaction):void} f Observer function
   */
  observe(e) {
    Tc(this._eH, e);
  }
  /**
   * Observe all events that are created by this type and its children.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  observeDeep(e) {
    Tc(this._dEH, e);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(EventType,Transaction):void} f Observer function
   */
  unobserve(e) {
    Lc(this._eH, e);
  }
  /**
   * Unregister an observer function.
   *
   * @param {function(Array<YEvent<any>>,Transaction):void} f Observer function
   */
  unobserveDeep(e) {
    Lc(this._dEH, e);
  }
  /**
   * @abstract
   * @return {any}
   */
  toJSON() {
  }
}
const Vu = (s, e, t) => {
  e < 0 && (e = s._length + e), t < 0 && (t = s._length + t);
  let n = t - e;
  const i = [];
  let r = s._start;
  for (; r !== null && n > 0; ) {
    if (r.countable && !r.deleted) {
      const o = r.content.getContent();
      if (o.length <= e)
        e -= o.length;
      else {
        for (let a = e; a < o.length && n > 0; a++)
          i.push(o[a]), n--;
        e = 0;
      }
    }
    r = r.right;
  }
  return i;
}, Hu = (s) => {
  const e = [];
  let t = s._start;
  for (; t !== null; ) {
    if (t.countable && !t.deleted) {
      const n = t.content.getContent();
      for (let i = 0; i < n.length; i++)
        e.push(n[i]);
    }
    t = t.right;
  }
  return e;
}, Gi = (s, e) => {
  let t = 0, n = s._start;
  for (; n !== null; ) {
    if (n.countable && !n.deleted) {
      const i = n.content.getContent();
      for (let r = 0; r < i.length; r++)
        e(i[r], t++, s);
    }
    n = n.right;
  }
}, Uu = (s, e) => {
  const t = [];
  return Gi(s, (n, i) => {
    t.push(e(n, i, s));
  }), t;
}, p1 = (s) => {
  let e = s._start, t = null, n = 0;
  return {
    [Symbol.iterator]() {
      return this;
    },
    next: () => {
      if (t === null) {
        for (; e !== null && e.deleted; )
          e = e.right;
        if (e === null)
          return {
            done: !0,
            value: void 0
          };
        t = e.content.getContent(), n = 0, e = e.right;
      }
      const i = t[n++];
      return t.length <= n && (t = null), {
        done: !1,
        value: i
      };
    }
  };
}, qu = (s, e) => {
  const t = To(s, e);
  let n = s._start;
  for (t !== null && (n = t.p, e -= t.index); n !== null; n = n.right)
    if (!n.deleted && n.countable) {
      if (e < n.length)
        return n.content.getContent()[e];
      e -= n.length;
    }
}, Qr = (s, e, t, n) => {
  let i = t;
  const r = s.doc, o = r.clientID, a = r.store, l = t === null ? e._start : t.right;
  let c = [];
  const u = () => {
    c.length > 0 && (i = new he(X(o, Me(a, o)), i, i && i.lastId, l, l && l.id, e, null, new ls(c)), i.integrate(s, 0), c = []);
  };
  n.forEach((f) => {
    if (f === null)
      c.push(f);
    else
      switch (f.constructor) {
        case Number:
        case Object:
        case Boolean:
        case Array:
        case String:
          c.push(f);
          break;
        default:
          switch (u(), f.constructor) {
            case Uint8Array:
            case ArrayBuffer:
              i = new he(X(o, Me(a, o)), i, i && i.lastId, l, l && l.id, e, null, new ur(new Uint8Array(
                /** @type {Uint8Array} */
                f
              ))), i.integrate(s, 0);
              break;
            case ui:
              i = new he(X(o, Me(a, o)), i, i && i.lastId, l, l && l.id, e, null, new dr(
                /** @type {Doc} */
                f
              )), i.integrate(s, 0);
              break;
            default:
              if (f instanceof We)
                i = new he(X(o, Me(a, o)), i, i && i.lastId, l, l && l.id, e, null, new Gt(f)), i.integrate(s, 0);
              else
                throw new Error("Unexpected content type in insert operation");
          }
      }
  }), u();
}, Gu = () => _n("Length exceeded!"), Wu = (s, e, t, n) => {
  if (t > e._length)
    throw Gu();
  if (t === 0)
    return e._searchMarker && qi(e._searchMarker, t, n.length), Qr(s, e, null, n);
  const i = t, r = To(e, t);
  let o = e._start;
  for (r !== null && (o = r.p, t -= r.index, t === 0 && (o = o.prev, t += o && o.countable && !o.deleted ? o.length : 0)); o !== null; o = o.right)
    if (!o.deleted && o.countable) {
      if (t <= o.length) {
        t < o.length && nt(s, X(o.id.client, o.id.clock + t));
        break;
      }
      t -= o.length;
    }
  return e._searchMarker && qi(e._searchMarker, i, n.length), Qr(s, e, o, n);
}, m1 = (s, e, t) => {
  let i = (e._searchMarker || []).reduce((r, o) => o.index > r.index ? o : r, { index: 0, p: e._start }).p;
  if (i)
    for (; i.right; )
      i = i.right;
  return Qr(s, e, i, t);
}, Ju = (s, e, t, n) => {
  if (n === 0)
    return;
  const i = t, r = n, o = To(e, t);
  let a = e._start;
  for (o !== null && (a = o.p, t -= o.index); a !== null && t > 0; a = a.right)
    !a.deleted && a.countable && (t < a.length && nt(s, X(a.id.client, a.id.clock + t)), t -= a.length);
  for (; n > 0 && a !== null; )
    a.deleted || (n < a.length && nt(s, X(a.id.client, a.id.clock + n)), a.delete(s), n -= a.length), a = a.right;
  if (n > 0)
    throw Gu();
  e._searchMarker && qi(
    e._searchMarker,
    i,
    -r + n
    /* in case we remove the above exception */
  );
}, eo = (s, e, t) => {
  const n = e._map.get(t);
  n !== void 0 && n.delete(s);
}, Tl = (s, e, t, n) => {
  const i = e._map.get(t) || null, r = s.doc, o = r.clientID;
  let a;
  if (n == null)
    a = new ls([n]);
  else
    switch (n.constructor) {
      case Number:
      case Object:
      case Boolean:
      case Array:
      case String:
        a = new ls([n]);
        break;
      case Uint8Array:
        a = new ur(
          /** @type {Uint8Array} */
          n
        );
        break;
      case ui:
        a = new dr(
          /** @type {Doc} */
          n
        );
        break;
      default:
        if (n instanceof We)
          a = new Gt(n);
        else
          throw new Error("Unexpected content type");
    }
  new he(X(o, Me(r.store, o)), i, i && i.lastId, null, null, e, t, a).integrate(s, 0);
}, Ll = (s, e) => {
  const t = s._map.get(e);
  return t !== void 0 && !t.deleted ? t.content.getContent()[t.length - 1] : void 0;
}, Yu = (s) => {
  const e = {};
  return s._map.forEach((t, n) => {
    t.deleted || (e[n] = t.content.getContent()[t.length - 1]);
  }), e;
}, Xu = (s, e) => {
  const t = s._map.get(e);
  return t !== void 0 && !t.deleted;
}, w1 = (s, e) => {
  const t = {};
  return s._map.forEach((n, i) => {
    let r = n;
    for (; r !== null && (!e.sv.has(r.id.client) || r.id.clock >= (e.sv.get(r.id.client) || 0)); )
      r = r.left;
    r !== null && Ss(r, e) && (t[i] = r.content.getContent()[r.length - 1]);
  }), t;
}, kr = (s) => km(
  s.entries(),
  /** @param {any} entry */
  (e) => !e[1].deleted
);
class y1 extends Oo {
}
class _s extends We {
  constructor() {
    super(), this._prelimContent = [], this._searchMarker = [];
  }
  /**
   * Construct a new YArray containing the specified items.
   * @template {Object<string,any>|Array<any>|number|null|string|Uint8Array} T
   * @param {Array<T>} items
   * @return {YArray<T>}
   */
  static from(e) {
    const t = new _s();
    return t.push(e), t;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, t) {
    super._integrate(e, t), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  /**
   * @return {YArray<T>}
   */
  _copy() {
    return new _s();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YArray<T>}
   */
  clone() {
    const e = new _s();
    return e.insert(0, this.toArray().map(
      (t) => t instanceof We ? (
        /** @type {typeof el} */
        t.clone()
      ) : t
    )), e;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Creates YArrayEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, t) {
    super._callObserver(e, t), Lo(this, e, new y1(this, e));
  }
  /**
   * Inserts new content at an index.
   *
   * Important: This function expects an array of content. Not just a content
   * object. The reason for this "weirdness" is that inserting several elements
   * is very efficient when it is done as a single operation.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  yarray.insert(0, ['a'])
   *  // Insert numbers 1, 2 at position 1
   *  yarray.insert(1, [1, 2])
   *
   * @param {number} index The index to insert content at.
   * @param {Array<T>} content The array of content
   */
  insert(e, t) {
    this.doc !== null ? ae(this.doc, (n) => {
      Wu(
        n,
        this,
        e,
        /** @type {any} */
        t
      );
    }) : this._prelimContent.splice(e, 0, ...t);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<T>} content Array of content to append.
   *
   * @todo Use the following implementation in all types.
   */
  push(e) {
    this.doc !== null ? ae(this.doc, (t) => {
      m1(
        t,
        this,
        /** @type {any} */
        e
      );
    }) : this._prelimContent.push(...e);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<T>} content Array of content to prepend.
   */
  unshift(e) {
    this.insert(0, e);
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} length The number of elements to remove. Defaults to 1.
   */
  delete(e, t = 1) {
    this.doc !== null ? ae(this.doc, (n) => {
      Ju(n, this, e, t);
    }) : this._prelimContent.splice(e, t);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {T}
   */
  get(e) {
    return qu(this, e);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<T>}
   */
  toArray() {
    return Hu(this);
  }
  /**
   * Returns a portion of this YArray into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<T>}
   */
  slice(e = 0, t = this.length) {
    return Vu(this, e, t);
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Array<any>}
   */
  toJSON() {
    return this.map((e) => e instanceof We ? e.toJSON() : e);
  }
  /**
   * Returns an Array with the result of calling a provided function on every
   * element of this YArray.
   *
   * @template M
   * @param {function(T,number,YArray<T>):M} f Function that produces an element of the new Array
   * @return {Array<M>} A new array with each element being the result of the
   *                 callback function
   */
  map(e) {
    return Uu(
      this,
      /** @type {any} */
      e
    );
  }
  /**
   * Executes a provided function once on every element of this YArray.
   *
   * @param {function(T,number,YArray<T>):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    Gi(this, e);
  }
  /**
   * @return {IterableIterator<T>}
   */
  [Symbol.iterator]() {
    return p1(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(z1);
  }
}
const b1 = (s) => new _s();
class v1 extends Oo {
  /**
   * @param {YMap<T>} ymap The YArray that changed.
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed.
   */
  constructor(e, t, n) {
    super(e, t), this.keysChanged = n;
  }
}
class Bs extends We {
  /**
   *
   * @param {Iterable<readonly [string, any]>=} entries - an optional iterable to initialize the YMap
   */
  constructor(e) {
    super(), this._prelimContent = null, e === void 0 ? this._prelimContent = /* @__PURE__ */ new Map() : this._prelimContent = new Map(e);
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, t) {
    super._integrate(e, t), this._prelimContent.forEach((n, i) => {
      this.set(i, n);
    }), this._prelimContent = null;
  }
  /**
   * @return {YMap<MapType>}
   */
  _copy() {
    return new Bs();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YMap<MapType>}
   */
  clone() {
    const e = new Bs();
    return this.forEach((t, n) => {
      e.set(n, t instanceof We ? (
        /** @type {typeof value} */
        t.clone()
      ) : t);
    }), e;
  }
  /**
   * Creates YMapEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, t) {
    Lo(this, e, new v1(this, e, t));
  }
  /**
   * Transforms this Shared Type to a JSON object.
   *
   * @return {Object<string,any>}
   */
  toJSON() {
    const e = {};
    return this._map.forEach((t, n) => {
      if (!t.deleted) {
        const i = t.content.getContent()[t.length - 1];
        e[n] = i instanceof We ? i.toJSON() : i;
      }
    }), e;
  }
  /**
   * Returns the size of the YMap (count of key/value pairs)
   *
   * @return {number}
   */
  get size() {
    return [...kr(this._map)].length;
  }
  /**
   * Returns the keys for each element in the YMap Type.
   *
   * @return {IterableIterator<string>}
   */
  keys() {
    return oa(
      kr(this._map),
      /** @param {any} v */
      (e) => e[0]
    );
  }
  /**
   * Returns the values for each element in the YMap Type.
   *
   * @return {IterableIterator<MapType>}
   */
  values() {
    return oa(
      kr(this._map),
      /** @param {any} v */
      (e) => e[1].content.getContent()[e[1].length - 1]
    );
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  entries() {
    return oa(
      kr(this._map),
      /** @param {any} v */
      (e) => (
        /** @type {any} */
        [e[0], e[1].content.getContent()[e[1].length - 1]]
      )
    );
  }
  /**
   * Executes a provided function on once on every key-value pair.
   *
   * @param {function(MapType,string,YMap<MapType>):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    this._map.forEach((t, n) => {
      t.deleted || e(t.content.getContent()[t.length - 1], n, this);
    });
  }
  /**
   * Returns an Iterator of [key, value] pairs
   *
   * @return {IterableIterator<[string, MapType]>}
   */
  [Symbol.iterator]() {
    return this.entries();
  }
  /**
   * Remove a specified element from this YMap.
   *
   * @param {string} key The key of the element to remove.
   */
  delete(e) {
    this.doc !== null ? ae(this.doc, (t) => {
      eo(t, this, e);
    }) : this._prelimContent.delete(e);
  }
  /**
   * Adds or updates an element with a specified key and value.
   * @template {MapType} VAL
   *
   * @param {string} key The key of the element to add to this YMap
   * @param {VAL} value The value of the element to add
   * @return {VAL}
   */
  set(e, t) {
    return this.doc !== null ? ae(this.doc, (n) => {
      Tl(
        n,
        this,
        e,
        /** @type {any} */
        t
      );
    }) : this._prelimContent.set(e, t), t;
  }
  /**
   * Returns a specified element from this YMap.
   *
   * @param {string} key
   * @return {MapType|undefined}
   */
  get(e) {
    return (
      /** @type {any} */
      Ll(this, e)
    );
  }
  /**
   * Returns a boolean indicating whether the specified key exists or not.
   *
   * @param {string} key The key to test.
   * @return {boolean}
   */
  has(e) {
    return Xu(this, e);
  }
  /**
   * Removes all elements from this YMap.
   */
  clear() {
    this.doc !== null ? ae(this.doc, (e) => {
      this.forEach(function(t, n, i) {
        eo(e, i, n);
      });
    }) : this._prelimContent.clear();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(V1);
  }
}
const x1 = (s) => new Bs(), Cn = (s, e) => s === e || typeof s == "object" && typeof e == "object" && s && e && am(s, e);
class Fa {
  /**
   * @param {Item|null} left
   * @param {Item|null} right
   * @param {number} index
   * @param {Map<string,any>} currentAttributes
   */
  constructor(e, t, n, i) {
    this.left = e, this.right = t, this.index = n, this.currentAttributes = i;
  }
  /**
   * Only call this if you know that this.right is defined
   */
  forward() {
    switch (this.right === null && At(), this.right.content.constructor) {
      case je:
        this.right.deleted || di(
          this.currentAttributes,
          /** @type {ContentFormat} */
          this.right.content
        );
        break;
      default:
        this.right.deleted || (this.index += this.right.length);
        break;
    }
    this.left = this.right, this.right = this.right.right;
  }
}
const Vc = (s, e, t) => {
  for (; e.right !== null && t > 0; ) {
    switch (e.right.content.constructor) {
      case je:
        e.right.deleted || di(
          e.currentAttributes,
          /** @type {ContentFormat} */
          e.right.content
        );
        break;
      default:
        e.right.deleted || (t < e.right.length && nt(s, X(e.right.id.client, e.right.id.clock + t)), e.index += e.right.length, t -= e.right.length);
        break;
    }
    e.left = e.right, e.right = e.right.right;
  }
  return e;
}, Pr = (s, e, t, n) => {
  const i = /* @__PURE__ */ new Map(), r = n ? To(e, t) : null;
  if (r) {
    const o = new Fa(r.p.left, r.p, r.index, i);
    return Vc(s, o, t - r.index);
  } else {
    const o = new Fa(null, e._start, 0, i);
    return Vc(s, o, t);
  }
}, Zu = (s, e, t, n) => {
  for (; t.right !== null && (t.right.deleted === !0 || t.right.content.constructor === je && Cn(
    n.get(
      /** @type {ContentFormat} */
      t.right.content.key
    ),
    /** @type {ContentFormat} */
    t.right.content.value
  )); )
    t.right.deleted || n.delete(
      /** @type {ContentFormat} */
      t.right.content.key
    ), t.forward();
  const i = s.doc, r = i.clientID;
  n.forEach((o, a) => {
    const l = t.left, c = t.right, u = new he(X(r, Me(i.store, r)), l, l && l.lastId, c, c && c.id, e, null, new je(a, o));
    u.integrate(s, 0), t.right = u, t.forward();
  });
}, di = (s, e) => {
  const { key: t, value: n } = e;
  n === null ? s.delete(t) : s.set(t, n);
}, Ku = (s, e) => {
  var t;
  for (; s.right !== null; ) {
    if (!(s.right.deleted || s.right.content.constructor === je && Cn(
      (t = e[
        /** @type {ContentFormat} */
        s.right.content.key
      ]) != null ? t : null,
      /** @type {ContentFormat} */
      s.right.content.value
    )))
      break;
    s.forward();
  }
}, Qu = (s, e, t, n) => {
  var a;
  const i = s.doc, r = i.clientID, o = /* @__PURE__ */ new Map();
  for (const l in n) {
    const c = n[l], u = (a = t.currentAttributes.get(l)) != null ? a : null;
    if (!Cn(u, c)) {
      o.set(l, u);
      const { left: f, right: d } = t;
      t.right = new he(X(r, Me(i.store, r)), f, f && f.lastId, d, d && d.id, e, null, new je(l, c)), t.right.integrate(s, 0), t.forward();
    }
  }
  return o;
}, aa = (s, e, t, n, i) => {
  t.currentAttributes.forEach((d, g) => {
    i[g] === void 0 && (i[g] = null);
  });
  const r = s.doc, o = r.clientID;
  Ku(t, i);
  const a = Qu(s, e, t, i), l = n.constructor === String ? new Ht(
    /** @type {string} */
    n
  ) : n instanceof We ? new Gt(n) : new ys(n);
  let { left: c, right: u, index: f } = t;
  e._searchMarker && qi(e._searchMarker, t.index, l.getLength()), u = new he(X(o, Me(r.store, o)), c, c && c.lastId, u, u && u.id, e, null, l), u.integrate(s, 0), t.right = u, t.index = f, t.forward(), Zu(s, e, t, a);
}, Hc = (s, e, t, n, i) => {
  const r = s.doc, o = r.clientID;
  Ku(t, i);
  const a = Qu(s, e, t, i);
  e:
    for (; t.right !== null && (n > 0 || a.size > 0 && (t.right.deleted || t.right.content.constructor === je)); ) {
      if (!t.right.deleted)
        switch (t.right.content.constructor) {
          case je: {
            const { key: l, value: c } = (
              /** @type {ContentFormat} */
              t.right.content
            ), u = i[l];
            if (u !== void 0) {
              if (Cn(u, c))
                a.delete(l);
              else {
                if (n === 0)
                  break e;
                a.set(l, c);
              }
              t.right.delete(s);
            } else
              t.currentAttributes.set(l, c);
            break;
          }
          default:
            n < t.right.length && nt(s, X(t.right.id.client, t.right.id.clock + n)), n -= t.right.length;
            break;
        }
      t.forward();
    }
  if (n > 0) {
    let l = "";
    for (; n > 0; n--)
      l += "\n";
    t.right = new he(X(o, Me(r.store, o)), t.left, t.left && t.left.lastId, t.right, t.right && t.right.id, e, null, new Ht(l)), t.right.integrate(s, 0), t.forward();
  }
  Zu(s, e, t, a);
}, ed = (s, e, t, n, i) => {
  var c, u;
  let r = e;
  const o = _t();
  for (; r && (!r.countable || r.deleted); ) {
    if (!r.deleted && r.content.constructor === je) {
      const f = (
        /** @type {ContentFormat} */
        r.content
      );
      o.set(f.key, f);
    }
    r = r.right;
  }
  let a = 0, l = !1;
  for (; e !== r; ) {
    if (t === e && (l = !0), !e.deleted) {
      const f = e.content;
      switch (f.constructor) {
        case je: {
          const { key: d, value: g } = (
            /** @type {ContentFormat} */
            f
          ), p = (c = n.get(d)) != null ? c : null;
          (o.get(d) !== f || p === g) && (e.delete(s), a++, !l && ((u = i.get(d)) != null ? u : null) === g && p !== g && (p === null ? i.delete(d) : i.set(d, p))), !l && !e.deleted && di(
            i,
            /** @type {ContentFormat} */
            f
          );
          break;
        }
      }
    }
    e = /** @type {Item} */
    e.right;
  }
  return a;
}, C1 = (s, e) => {
  for (; e && e.right && (e.right.deleted || !e.right.countable); )
    e = e.right;
  const t = /* @__PURE__ */ new Set();
  for (; e && (e.deleted || !e.countable); ) {
    if (!e.deleted && e.content.constructor === je) {
      const n = (
        /** @type {ContentFormat} */
        e.content.key
      );
      t.has(n) ? e.delete(s) : t.add(n);
    }
    e = e.left;
  }
}, E1 = (s) => {
  let e = 0;
  return ae(
    /** @type {Doc} */
    s.doc,
    (t) => {
      let n = (
        /** @type {Item} */
        s._start
      ), i = s._start, r = _t();
      const o = Ta(r);
      for (; i; ) {
        if (i.deleted === !1)
          switch (i.content.constructor) {
            case je:
              di(
                o,
                /** @type {ContentFormat} */
                i.content
              );
              break;
            default:
              e += ed(t, n, i, r, o), r = Ta(o), n = i;
              break;
          }
        i = i.right;
      }
    }
  ), e;
}, S1 = (s) => {
  const e = /* @__PURE__ */ new Set(), t = s.doc;
  for (const [n, i] of s.afterState.entries()) {
    const r = s.beforeState.get(n) || 0;
    i !== r && Ru(
      s,
      /** @type {Array<Item|GC>} */
      t.store.clients.get(n),
      r,
      i,
      (o) => {
        !o.deleted && /** @type {Item} */
        o.content.constructor === je && o.constructor !== vt && e.add(
          /** @type {any} */
          o.parent
        );
      }
    );
  }
  ae(t, (n) => {
    js(s, s.deleteSet, (i) => {
      if (i instanceof vt || !/** @type {YText} */
      i.parent._hasFormatting || e.has(
        /** @type {YText} */
        i.parent
      ))
        return;
      const r = (
        /** @type {YText} */
        i.parent
      );
      i.content.constructor === je ? e.add(r) : C1(n, i);
    });
    for (const i of e)
      E1(i);
  });
}, Uc = (s, e, t) => {
  const n = t, i = Ta(e.currentAttributes), r = e.right;
  for (; t > 0 && e.right !== null; ) {
    if (e.right.deleted === !1)
      switch (e.right.content.constructor) {
        case Gt:
        case ys:
        case Ht:
          t < e.right.length && nt(s, X(e.right.id.client, e.right.id.clock + t)), t -= e.right.length, e.right.delete(s);
          break;
      }
    e.forward();
  }
  r && ed(s, r, e.right, i, e.currentAttributes);
  const o = (
    /** @type {AbstractType<any>} */
    /** @type {Item} */
    (e.left || e.right).parent
  );
  return o._searchMarker && qi(o._searchMarker, e.index, -n + t), e;
};
class td extends Oo {
  /**
   * @param {YText} ytext
   * @param {Transaction} transaction
   * @param {Set<any>} subs The keys that changed
   */
  constructor(e, t, n) {
    super(e, t), this.childListChanged = !1, this.keysChanged = /* @__PURE__ */ new Set(), n.forEach((i) => {
      i === null ? this.childListChanged = !0 : this.keysChanged.add(i);
    });
  }
  /**
   * @type {{added:Set<Item>,deleted:Set<Item>,keys:Map<string,{action:'add'|'update'|'delete',oldValue:any}>,delta:Array<{insert?:Array<any>|string, delete?:number, retain?:number}>}}
   */
  get changes() {
    if (this._changes === null) {
      const e = {
        keys: this.keys,
        delta: this.delta,
        added: /* @__PURE__ */ new Set(),
        deleted: /* @__PURE__ */ new Set()
      };
      this._changes = e;
    }
    return (
      /** @type {any} */
      this._changes
    );
  }
  /**
   * Compute the changes in the delta format.
   * A {@link https://quilljs.com/docs/delta/|Quill Delta}) that represents the changes on the document.
   *
   * @type {Array<{insert?:string|object|AbstractType<any>, delete?:number, retain?:number, attributes?: Object<string,any>}>}
   *
   * @public
   */
  get delta() {
    if (this._delta === null) {
      const e = (
        /** @type {Doc} */
        this.target.doc
      ), t = [];
      ae(e, (n) => {
        var g, p, m;
        const i = /* @__PURE__ */ new Map(), r = /* @__PURE__ */ new Map();
        let o = this.target._start, a = null;
        const l = {};
        let c = "", u = 0, f = 0;
        const d = () => {
          if (a !== null) {
            let w = null;
            switch (a) {
              case "delete":
                f > 0 && (w = { delete: f }), f = 0;
                break;
              case "insert":
                (typeof c == "object" || c.length > 0) && (w = { insert: c }, i.size > 0 && (w.attributes = {}, i.forEach((v, y) => {
                  v !== null && (w.attributes[y] = v);
                }))), c = "";
                break;
              case "retain":
                u > 0 && (w = { retain: u }, im(l) || (w.attributes = tm({}, l))), u = 0;
                break;
            }
            w && t.push(w), a = null;
          }
        };
        for (; o !== null; ) {
          switch (o.content.constructor) {
            case Gt:
            case ys:
              this.adds(o) ? this.deletes(o) || (d(), a = "insert", c = o.content.getContent()[0], d()) : this.deletes(o) ? (a !== "delete" && (d(), a = "delete"), f += 1) : o.deleted || (a !== "retain" && (d(), a = "retain"), u += 1);
              break;
            case Ht:
              this.adds(o) ? this.deletes(o) || (a !== "insert" && (d(), a = "insert"), c += /** @type {ContentString} */
              o.content.str) : this.deletes(o) ? (a !== "delete" && (d(), a = "delete"), f += o.length) : o.deleted || (a !== "retain" && (d(), a = "retain"), u += o.length);
              break;
            case je: {
              const { key: w, value: v } = (
                /** @type {ContentFormat} */
                o.content
              );
              if (this.adds(o)) {
                if (!this.deletes(o)) {
                  const y = (g = i.get(w)) != null ? g : null;
                  Cn(y, v) ? v !== null && o.delete(n) : (a === "retain" && d(), Cn(v, (p = r.get(w)) != null ? p : null) ? delete l[w] : l[w] = v);
                }
              } else if (this.deletes(o)) {
                r.set(w, v);
                const y = (m = i.get(w)) != null ? m : null;
                Cn(y, v) || (a === "retain" && d(), l[w] = y);
              } else if (!o.deleted) {
                r.set(w, v);
                const y = l[w];
                y !== void 0 && (Cn(y, v) ? y !== null && o.delete(n) : (a === "retain" && d(), v === null ? delete l[w] : l[w] = v));
              }
              o.deleted || (a === "insert" && d(), di(
                i,
                /** @type {ContentFormat} */
                o.content
              ));
              break;
            }
          }
          o = o.right;
        }
        for (d(); t.length > 0; ) {
          const w = t[t.length - 1];
          if (w.retain !== void 0 && w.attributes === void 0)
            t.pop();
          else
            break;
        }
      }), this._delta = t;
    }
    return (
      /** @type {any} */
      this._delta
    );
  }
}
class $s extends We {
  /**
   * @param {String} [string] The initial value of the YText.
   */
  constructor(e) {
    super(), this._pending = e !== void 0 ? [() => this.insert(0, e)] : [], this._searchMarker = [], this._hasFormatting = !1;
  }
  /**
   * Number of characters of this text type.
   *
   * @type {number}
   */
  get length() {
    return this._length;
  }
  /**
   * @param {Doc} y
   * @param {Item} item
   */
  _integrate(e, t) {
    super._integrate(e, t);
    try {
      this._pending.forEach((n) => n());
    } catch (n) {
      console.error(n);
    }
    this._pending = null;
  }
  _copy() {
    return new $s();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YText}
   */
  clone() {
    const e = new $s();
    return e.applyDelta(this.toDelta()), e;
  }
  /**
   * Creates YTextEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, t) {
    super._callObserver(e, t);
    const n = new td(this, e, t);
    Lo(this, e, n), !e.local && this._hasFormatting && (e._needFormattingCleanup = !0);
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @public
   */
  toString() {
    let e = "", t = this._start;
    for (; t !== null; )
      !t.deleted && t.countable && t.content.constructor === Ht && (e += /** @type {ContentString} */
      t.content.str), t = t.right;
    return e;
  }
  /**
   * Returns the unformatted string representation of this YText type.
   *
   * @return {string}
   * @public
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Apply a {@link Delta} on this shared YText type.
   *
   * @param {any} delta The changes to apply on this element.
   * @param {object}  opts
   * @param {boolean} [opts.sanitize] Sanitize input delta. Removes ending newlines if set to true.
   *
   *
   * @public
   */
  applyDelta(e, { sanitize: t = !0 } = {}) {
    this.doc !== null ? ae(this.doc, (n) => {
      const i = new Fa(null, this._start, 0, /* @__PURE__ */ new Map());
      for (let r = 0; r < e.length; r++) {
        const o = e[r];
        if (o.insert !== void 0) {
          const a = !t && typeof o.insert == "string" && r === e.length - 1 && i.right === null && o.insert.slice(-1) === "\n" ? o.insert.slice(0, -1) : o.insert;
          (typeof a != "string" || a.length > 0) && aa(n, this, i, a, o.attributes || {});
        } else
          o.retain !== void 0 ? Hc(n, this, i, o.retain, o.attributes || {}) : o.delete !== void 0 && Uc(n, i, o.delete);
      }
    }) : this._pending.push(() => this.applyDelta(e));
  }
  /**
   * Returns the Delta representation of this YText type.
   *
   * @param {Snapshot} [snapshot]
   * @param {Snapshot} [prevSnapshot]
   * @param {function('removed' | 'added', ID):any} [computeYChange]
   * @return {any} The Delta representation of this type.
   *
   * @public
   */
  toDelta(e, t, n) {
    const i = [], r = /* @__PURE__ */ new Map(), o = (
      /** @type {Doc} */
      this.doc
    );
    let a = "", l = this._start;
    function c() {
      if (a.length > 0) {
        const f = {};
        let d = !1;
        r.forEach((p, m) => {
          d = !0, f[m] = p;
        });
        const g = { insert: a };
        d && (g.attributes = f), i.push(g), a = "";
      }
    }
    const u = () => {
      for (; l !== null; ) {
        if (Ss(l, e) || t !== void 0 && Ss(l, t))
          switch (l.content.constructor) {
            case Ht: {
              const f = r.get("ychange");
              e !== void 0 && !Ss(l, e) ? (f === void 0 || f.user !== l.id.client || f.type !== "removed") && (c(), r.set("ychange", n ? n("removed", l.id) : { type: "removed" })) : t !== void 0 && !Ss(l, t) ? (f === void 0 || f.user !== l.id.client || f.type !== "added") && (c(), r.set("ychange", n ? n("added", l.id) : { type: "added" })) : f !== void 0 && (c(), r.delete("ychange")), a += /** @type {ContentString} */
              l.content.str;
              break;
            }
            case Gt:
            case ys: {
              c();
              const f = {
                insert: l.content.getContent()[0]
              };
              if (r.size > 0) {
                const d = (
                  /** @type {Object<string,any>} */
                  {}
                );
                f.attributes = d, r.forEach((g, p) => {
                  d[p] = g;
                });
              }
              i.push(f);
              break;
            }
            case je:
              Ss(l, e) && (c(), di(
                r,
                /** @type {ContentFormat} */
                l.content
              ));
              break;
          }
        l = l.right;
      }
      c();
    };
    return e || t ? ae(o, (f) => {
      e && Ba(f, e), t && Ba(f, t), u();
    }, "cleanup") : u(), i;
  }
  /**
   * Insert text at a given index.
   *
   * @param {number} index The index at which to start inserting.
   * @param {String} text The text to insert at the specified position.
   * @param {TextAttributes} [attributes] Optionally define some formatting
   *                                    information to apply on the inserted
   *                                    Text.
   * @public
   */
  insert(e, t, n) {
    if (t.length <= 0)
      return;
    const i = this.doc;
    i !== null ? ae(i, (r) => {
      const o = Pr(r, this, e, !n);
      n || (n = {}, o.currentAttributes.forEach((a, l) => {
        n[l] = a;
      })), aa(r, this, o, t, n);
    }) : this._pending.push(() => this.insert(e, t, n));
  }
  /**
   * Inserts an embed at a index.
   *
   * @param {number} index The index to insert the embed at.
   * @param {Object | AbstractType<any>} embed The Object that represents the embed.
   * @param {TextAttributes} [attributes] Attribute information to apply on the
   *                                    embed
   *
   * @public
   */
  insertEmbed(e, t, n) {
    const i = this.doc;
    i !== null ? ae(i, (r) => {
      const o = Pr(r, this, e, !n);
      aa(r, this, o, t, n || {});
    }) : this._pending.push(() => this.insertEmbed(e, t, n || {}));
  }
  /**
   * Deletes text starting from an index.
   *
   * @param {number} index Index at which to start deleting.
   * @param {number} length The number of characters to remove. Defaults to 1.
   *
   * @public
   */
  delete(e, t) {
    if (t === 0)
      return;
    const n = this.doc;
    n !== null ? ae(n, (i) => {
      Uc(i, Pr(i, this, e, !0), t);
    }) : this._pending.push(() => this.delete(e, t));
  }
  /**
   * Assigns properties to a range of text.
   *
   * @param {number} index The position where to start formatting.
   * @param {number} length The amount of characters to assign properties to.
   * @param {TextAttributes} attributes Attribute information to apply on the
   *                                    text.
   *
   * @public
   */
  format(e, t, n) {
    if (t === 0)
      return;
    const i = this.doc;
    i !== null ? ae(i, (r) => {
      const o = Pr(r, this, e, !1);
      o.right !== null && Hc(r, this, o, t, n);
    }) : this._pending.push(() => this.format(e, t, n));
  }
  /**
   * Removes an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(e) {
    this.doc !== null ? ae(this.doc, (t) => {
      eo(t, this, e);
    }) : this._pending.push(() => this.removeAttribute(e));
  }
  /**
   * Sets or updates an attribute.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that is to be set.
   * @param {any} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(e, t) {
    this.doc !== null ? ae(this.doc, (n) => {
      Tl(n, this, e, t);
    }) : this._pending.push(() => this.setAttribute(e, t));
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @param {String} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {any} The queried attribute value.
   *
   * @public
   */
  getAttribute(e) {
    return (
      /** @type {any} */
      Ll(this, e)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @note Xml-Text nodes don't have attributes. You can use this feature to assign properties to complete text-blocks.
   *
   * @return {Object<string, any>} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes() {
    return Yu(this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(H1);
  }
}
const A1 = (s) => new $s();
class la {
  /**
   * @param {YXmlFragment | YXmlElement} root
   * @param {function(AbstractType<any>):boolean} [f]
   */
  constructor(e, t = () => !0) {
    this._filter = t, this._root = e, this._currentNode = /** @type {Item} */
    e._start, this._firstCall = !0;
  }
  [Symbol.iterator]() {
    return this;
  }
  /**
   * Get the next node.
   *
   * @return {IteratorResult<YXmlElement|YXmlText|YXmlHook>} The next node.
   *
   * @public
   */
  next() {
    let e = this._currentNode, t = e && e.content && /** @type {any} */
    e.content.type;
    if (e !== null && (!this._firstCall || e.deleted || !this._filter(t)))
      do
        if (t = /** @type {any} */
        e.content.type, !e.deleted && (t.constructor === Fs || t.constructor === as) && t._start !== null)
          e = t._start;
        else
          for (; e !== null; )
            if (e.right !== null) {
              e = e.right;
              break;
            } else
              e.parent === this._root ? e = null : e = /** @type {AbstractType<any>} */
              e.parent._item;
      while (e !== null && (e.deleted || !this._filter(
        /** @type {ContentType} */
        e.content.type
      )));
    return this._firstCall = !1, e === null ? { value: void 0, done: !0 } : (this._currentNode = e, { value: (
      /** @type {any} */
      e.content.type
    ), done: !1 });
  }
}
class as extends We {
  constructor() {
    super(), this._prelimContent = [];
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get firstChild() {
    const e = this._first;
    return e ? e.content.getContent()[0] : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, t) {
    super._integrate(e, t), this.insert(
      0,
      /** @type {Array<any>} */
      this._prelimContent
    ), this._prelimContent = null;
  }
  _copy() {
    return new as();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlFragment}
   */
  clone() {
    const e = new as();
    return e.insert(0, this.toArray().map((t) => t instanceof We ? t.clone() : t)), e;
  }
  get length() {
    return this._prelimContent === null ? this._length : this._prelimContent.length;
  }
  /**
   * Create a subtree of childNodes.
   *
   * @example
   * const walker = elem.createTreeWalker(dom => dom.nodeName === 'div')
   * for (let node in walker) {
   *   // `node` is a div node
   *   nop(node)
   * }
   *
   * @param {function(AbstractType<any>):boolean} filter Function that is called on each child element and
   *                          returns a Boolean indicating whether the child
   *                          is to be included in the subtree.
   * @return {YXmlTreeWalker} A subtree and a position within it.
   *
   * @public
   */
  createTreeWalker(e) {
    return new la(this, e);
  }
  /**
   * Returns the first YXmlElement that matches the query.
   * Similar to DOM's {@link querySelector}.
   *
   * Query support:
   *   - tagname
   * TODO:
   *   - id
   *   - attribute
   *
   * @param {CSS_Selector} query The query on the children.
   * @return {YXmlElement|YXmlText|YXmlHook|null} The first element that matches the query or null.
   *
   * @public
   */
  querySelector(e) {
    e = e.toUpperCase();
    const n = new la(this, (i) => i.nodeName && i.nodeName.toUpperCase() === e).next();
    return n.done ? null : n.value;
  }
  /**
   * Returns all YXmlElements that match the query.
   * Similar to Dom's {@link querySelectorAll}.
   *
   * @todo Does not yet support all queries. Currently only query by tagName.
   *
   * @param {CSS_Selector} query The query on the children
   * @return {Array<YXmlElement|YXmlText|YXmlHook|null>} The elements that match this query.
   *
   * @public
   */
  querySelectorAll(e) {
    return e = e.toUpperCase(), kn(new la(this, (t) => t.nodeName && t.nodeName.toUpperCase() === e));
  }
  /**
   * Creates YXmlEvent and calls observers.
   *
   * @param {Transaction} transaction
   * @param {Set<null|string>} parentSubs Keys changed on this type. `null` if list was modified.
   */
  _callObserver(e, t) {
    Lo(this, e, new P1(this, t, e));
  }
  /**
   * Get the string representation of all the children of this YXmlFragment.
   *
   * @return {string} The string representation of all children.
   */
  toString() {
    return Uu(this, (e) => e.toString()).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, t = {}, n) {
    const i = e.createDocumentFragment();
    return n !== void 0 && n._createAssociation(i, this), Gi(this, (r) => {
      i.insertBefore(r.toDOM(e, t, n), null);
    }), i;
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {number} index The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insert(e, t) {
    this.doc !== null ? ae(this.doc, (n) => {
      Wu(n, this, e, t);
    }) : this._prelimContent.splice(e, 0, ...t);
  }
  /**
   * Inserts new content at an index.
   *
   * @example
   *  // Insert character 'a' at position 0
   *  xml.insert(0, [new Y.XmlText('text')])
   *
   * @param {null|Item|YXmlElement|YXmlText} ref The index to insert content at
   * @param {Array<YXmlElement|YXmlText>} content The array of content
   */
  insertAfter(e, t) {
    if (this.doc !== null)
      ae(this.doc, (n) => {
        const i = e && e instanceof We ? e._item : e;
        Qr(n, this, i, t);
      });
    else {
      const n = (
        /** @type {Array<any>} */
        this._prelimContent
      ), i = e === null ? 0 : n.findIndex((r) => r === e) + 1;
      if (i === 0 && e !== null)
        throw _n("Reference item not found");
      n.splice(i, 0, ...t);
    }
  }
  /**
   * Deletes elements starting from an index.
   *
   * @param {number} index Index at which to start deleting elements
   * @param {number} [length=1] The number of elements to remove. Defaults to 1.
   */
  delete(e, t = 1) {
    this.doc !== null ? ae(this.doc, (n) => {
      Ju(n, this, e, t);
    }) : this._prelimContent.splice(e, t);
  }
  /**
   * Transforms this YArray to a JavaScript Array.
   *
   * @return {Array<YXmlElement|YXmlText|YXmlHook>}
   */
  toArray() {
    return Hu(this);
  }
  /**
   * Appends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to append.
   */
  push(e) {
    this.insert(this.length, e);
  }
  /**
   * Prepends content to this YArray.
   *
   * @param {Array<YXmlElement|YXmlText>} content Array of content to prepend.
   */
  unshift(e) {
    this.insert(0, e);
  }
  /**
   * Returns the i-th element from a YArray.
   *
   * @param {number} index The index of the element to return from the YArray
   * @return {YXmlElement|YXmlText}
   */
  get(e) {
    return qu(this, e);
  }
  /**
   * Returns a portion of this YXmlFragment into a JavaScript Array selected
   * from start to end (end not included).
   *
   * @param {number} [start]
   * @param {number} [end]
   * @return {Array<YXmlElement|YXmlText>}
   */
  slice(e = 0, t = this.length) {
    return Vu(this, e, t);
  }
  /**
   * Executes a provided function on once on every child element.
   *
   * @param {function(YXmlElement|YXmlText,number, typeof self):void} f A function to execute on every element of this YArray.
   */
  forEach(e) {
    Gi(this, e);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(q1);
  }
}
const M1 = (s) => new as();
class Fs extends as {
  constructor(e = "UNDEFINED") {
    super(), this.nodeName = e, this._prelimAttrs = /* @__PURE__ */ new Map();
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const e = this._item ? this._item.next : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const e = this._item ? this._item.prev : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * Integrate this type into the Yjs instance.
   *
   * * Save this struct in the os
   * * This type is sent to other client
   * * Observer functions are fired
   *
   * @param {Doc} y The Yjs instance
   * @param {Item} item
   */
  _integrate(e, t) {
    super._integrate(e, t), /** @type {Map<string, any>} */
    this._prelimAttrs.forEach((n, i) => {
      this.setAttribute(i, n);
    }), this._prelimAttrs = null;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   *
   * @return {YXmlElement}
   */
  _copy() {
    return new Fs(this.nodeName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlElement<KV>}
   */
  clone() {
    const e = new Fs(this.nodeName), t = this.getAttributes();
    return sm(t, (n, i) => {
      typeof n == "string" && e.setAttribute(i, n);
    }), e.insert(0, this.toArray().map((n) => n instanceof We ? n.clone() : n)), e;
  }
  /**
   * Returns the XML serialization of this YXmlElement.
   * The attributes are ordered by attribute-name, so you can easily use this
   * method to compare YXmlElements
   *
   * @return {string} The string representation of this type.
   *
   * @public
   */
  toString() {
    const e = this.getAttributes(), t = [], n = [];
    for (const a in e)
      n.push(a);
    n.sort();
    const i = n.length;
    for (let a = 0; a < i; a++) {
      const l = n[a];
      t.push(l + '="' + e[l] + '"');
    }
    const r = this.nodeName.toLocaleLowerCase(), o = t.length > 0 ? " " + t.join(" ") : "";
    return "<".concat(r).concat(o, ">").concat(super.toString(), "</").concat(r, ">");
  }
  /**
   * Removes an attribute from this YXmlElement.
   *
   * @param {string} attributeName The attribute name that is to be removed.
   *
   * @public
   */
  removeAttribute(e) {
    this.doc !== null ? ae(this.doc, (t) => {
      eo(t, this, e);
    }) : this._prelimAttrs.delete(e);
  }
  /**
   * Sets or updates an attribute.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that is to be set.
   * @param {KV[KEY]} attributeValue The attribute value that is to be set.
   *
   * @public
   */
  setAttribute(e, t) {
    this.doc !== null ? ae(this.doc, (n) => {
      Tl(n, this, e, t);
    }) : this._prelimAttrs.set(e, t);
  }
  /**
   * Returns an attribute value that belongs to the attribute name.
   *
   * @template {keyof KV & string} KEY
   *
   * @param {KEY} attributeName The attribute name that identifies the
   *                               queried value.
   * @return {KV[KEY]|undefined} The queried attribute value.
   *
   * @public
   */
  getAttribute(e) {
    return (
      /** @type {any} */
      Ll(this, e)
    );
  }
  /**
   * Returns whether an attribute exists
   *
   * @param {string} attributeName The attribute name to check for existence.
   * @return {boolean} whether the attribute exists.
   *
   * @public
   */
  hasAttribute(e) {
    return (
      /** @type {any} */
      Xu(this, e)
    );
  }
  /**
   * Returns all attribute name/value pairs in a JSON Object.
   *
   * @param {Snapshot} [snapshot]
   * @return {{ [Key in Extract<keyof KV,string>]?: KV[Key]}} A JSON Object that describes the attributes.
   *
   * @public
   */
  getAttributes(e) {
    return (
      /** @type {any} */
      e ? w1(this, e) : Yu(this)
    );
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks={}] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Node} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, t = {}, n) {
    const i = e.createElement(this.nodeName), r = this.getAttributes();
    for (const o in r) {
      const a = r[o];
      typeof a == "string" && i.setAttribute(o, a);
    }
    return Gi(this, (o) => {
      i.appendChild(o.toDOM(e, t, n));
    }), n !== void 0 && n._createAssociation(i, this), i;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(U1), e.writeKey(this.nodeName);
  }
}
const k1 = (s) => new Fs(s.readKey());
class P1 extends Oo {
  /**
   * @param {YXmlElement|YXmlText|YXmlFragment} target The target on which the event is created.
   * @param {Set<string|null>} subs The set of changed attributes. `null` is included if the
   *                   child list changed.
   * @param {Transaction} transaction The transaction instance with wich the
   *                                  change was created.
   */
  constructor(e, t, n) {
    super(e, n), this.childListChanged = !1, this.attributesChanged = /* @__PURE__ */ new Set(), t.forEach((i) => {
      i === null ? this.childListChanged = !0 : this.attributesChanged.add(i);
    });
  }
}
class to extends Bs {
  /**
   * @param {string} hookName nodeName of the Dom Node.
   */
  constructor(e) {
    super(), this.hookName = e;
  }
  /**
   * Creates an Item with the same effect as this Item (without position effect)
   */
  _copy() {
    return new to(this.hookName);
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlHook}
   */
  clone() {
    const e = new to(this.hookName);
    return this.forEach((t, n) => {
      e.set(n, t);
    }), e;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlElement.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object.<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type
   * @return {Element} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, t = {}, n) {
    const i = t[this.hookName];
    let r;
    return i !== void 0 ? r = i.createDom(this) : r = document.createElement(this.hookName), r.setAttribute("data-yjs-hook", this.hookName), n !== void 0 && n._createAssociation(r, this), r;
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   */
  _write(e) {
    e.writeTypeRef(G1), e.writeKey(this.hookName);
  }
}
const _1 = (s) => new to(s.readKey());
class Je extends $s {
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get nextSibling() {
    const e = this._item ? this._item.next : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  /**
   * @type {YXmlElement|YXmlText|null}
   */
  get prevSibling() {
    const e = this._item ? this._item.prev : null;
    return e ? (
      /** @type {YXmlElement|YXmlText} */
      /** @type {ContentType} */
      e.content.type
    ) : null;
  }
  _copy() {
    return new Je();
  }
  /**
   * Makes a copy of this data type that can be included somewhere else.
   *
   * Note that the content is only readable _after_ it has been included somewhere in the Ydoc.
   *
   * @return {YXmlText}
   */
  clone() {
    const e = new Je();
    return e.applyDelta(this.toDelta()), e;
  }
  /**
   * Creates a Dom Element that mirrors this YXmlText.
   *
   * @param {Document} [_document=document] The document object (you must define
   *                                        this when calling this method in
   *                                        nodejs)
   * @param {Object<string, any>} [hooks] Optional property to customize how hooks
   *                                             are presented in the DOM
   * @param {any} [binding] You should not set this property. This is
   *                               used if DomBinding wants to create a
   *                               association to the created DOM type.
   * @return {Text} The {@link https://developer.mozilla.org/en-US/docs/Web/API/Element|Dom Element}
   *
   * @public
   */
  toDOM(e = document, t, n) {
    const i = e.createTextNode(this.toString());
    return n !== void 0 && n._createAssociation(i, this), i;
  }
  toString() {
    return this.toDelta().map((e) => {
      const t = [];
      for (const i in e.attributes) {
        const r = [];
        for (const o in e.attributes[i])
          r.push({ key: o, value: e.attributes[i][o] });
        r.sort((o, a) => o.key < a.key ? -1 : 1), t.push({ nodeName: i, attrs: r });
      }
      t.sort((i, r) => i.nodeName < r.nodeName ? -1 : 1);
      let n = "";
      for (let i = 0; i < t.length; i++) {
        const r = t[i];
        n += "<".concat(r.nodeName);
        for (let o = 0; o < r.attrs.length; o++) {
          const a = r.attrs[o];
          n += " ".concat(a.key, '="').concat(a.value, '"');
        }
        n += ">";
      }
      n += e.insert;
      for (let i = t.length - 1; i >= 0; i--)
        n += "</".concat(t[i].nodeName, ">");
      return n;
    }).join("");
  }
  /**
   * @return {string}
   */
  toJSON() {
    return this.toString();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   */
  _write(e) {
    e.writeTypeRef(W1);
  }
}
const O1 = (s) => new Je();
class Dl {
  /**
   * @param {ID} id
   * @param {number} length
   */
  constructor(e, t) {
    this.id = e, this.length = t;
  }
  /**
   * @type {boolean}
   */
  get deleted() {
    throw Ft();
  }
  /**
   * Merge this struct with the item to the right.
   * This method is already assuming that `this.id.clock + this.length === this.id.clock`.
   * Also this method does *not* remove right from StructStore!
   * @param {AbstractStruct} right
   * @return {boolean} wether this merged with right
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   * @param {number} encodingRef
   */
  write(e, t, n) {
    throw Ft();
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, t) {
    throw Ft();
  }
}
const T1 = 0;
class vt extends Dl {
  get deleted() {
    return !0;
  }
  delete() {
  }
  /**
   * @param {GC} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.constructor !== e.constructor ? !1 : (this.length += e.length, !0);
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, t) {
    t > 0 && (this.id.clock += t, this.length -= t), ju(e.doc.store, this);
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeInfo(T1), e.writeLen(this.length - t);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, t) {
    return null;
  }
}
class ur {
  /**
   * @param {Uint8Array} content
   */
  constructor(e) {
    this.content = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.content];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentBinary}
   */
  copy() {
    return new ur(this.content);
  }
  /**
   * @param {number} offset
   * @return {ContentBinary}
   */
  splice(e) {
    throw Ft();
  }
  /**
   * @param {ContentBinary} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeBuf(this.content);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 3;
  }
}
const L1 = (s) => new ur(s.readBuf());
class Wi {
  /**
   * @param {number} len
   */
  constructor(e) {
    this.len = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.len;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentDeleted}
   */
  copy() {
    return new Wi(this.len);
  }
  /**
   * @param {number} offset
   * @return {ContentDeleted}
   */
  splice(e) {
    const t = new Wi(this.len - e);
    return this.len = e, t;
  }
  /**
   * @param {ContentDeleted} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.len += e.len, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
    Ui(e.deleteSet, t.id.client, t.id.clock, this.len), t.markDeleted();
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeLen(this.len - t);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 1;
  }
}
const D1 = (s) => new Wi(s.readLen()), nd = (s, e) => new ui({ guid: s, ...e, shouldLoad: e.shouldLoad || e.autoLoad || !1 });
class dr {
  /**
   * @param {Doc} doc
   */
  constructor(e) {
    e._item && console.error("This document was already integrated as a sub-document. You should create a second instance instead with the same guid."), this.doc = e;
    const t = {};
    this.opts = t, e.gc || (t.gc = !1), e.autoLoad && (t.autoLoad = !0), e.meta !== null && (t.meta = e.meta);
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.doc];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentDoc}
   */
  copy() {
    return new dr(nd(this.doc.guid, this.opts));
  }
  /**
   * @param {number} offset
   * @return {ContentDoc}
   */
  splice(e) {
    throw Ft();
  }
  /**
   * @param {ContentDoc} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
    this.doc._item = t, e.subdocsAdded.add(this.doc), this.doc.shouldLoad && e.subdocsLoaded.add(this.doc);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
    e.subdocsAdded.has(this.doc) ? e.subdocsAdded.delete(this.doc) : e.subdocsRemoved.add(this.doc);
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeString(this.doc.guid), e.writeAny(this.opts);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 9;
  }
}
const N1 = (s) => new dr(nd(s.readString(), s.readAny()));
class ys {
  /**
   * @param {Object} embed
   */
  constructor(e) {
    this.embed = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.embed];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentEmbed}
   */
  copy() {
    return new ys(this.embed);
  }
  /**
   * @param {number} offset
   * @return {ContentEmbed}
   */
  splice(e) {
    throw Ft();
  }
  /**
   * @param {ContentEmbed} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeJSON(this.embed);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 5;
  }
}
const I1 = (s) => new ys(s.readJSON());
class je {
  /**
   * @param {string} key
   * @param {Object} value
   */
  constructor(e, t) {
    this.key = e, this.value = t;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !1;
  }
  /**
   * @return {ContentFormat}
   */
  copy() {
    return new je(this.key, this.value);
  }
  /**
   * @param {number} _offset
   * @return {ContentFormat}
   */
  splice(e) {
    throw Ft();
  }
  /**
   * @param {ContentFormat} _right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} _transaction
   * @param {Item} item
   */
  integrate(e, t) {
    const n = (
      /** @type {YText} */
      t.parent
    );
    n._searchMarker = null, n._hasFormatting = !0;
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeKey(this.key), e.writeJSON(this.value);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 6;
  }
}
const j1 = (s) => new je(s.readKey(), s.readJSON());
class no {
  /**
   * @param {Array<any>} arr
   */
  constructor(e) {
    this.arr = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentJSON}
   */
  copy() {
    return new no(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentJSON}
   */
  splice(e) {
    const t = new no(this.arr.slice(e));
    return this.arr = this.arr.slice(0, e), t;
  }
  /**
   * @param {ContentJSON} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.arr = this.arr.concat(e.arr), !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    const n = this.arr.length;
    e.writeLen(n - t);
    for (let i = t; i < n; i++) {
      const r = this.arr[i];
      e.writeString(r === void 0 ? "undefined" : JSON.stringify(r));
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 2;
  }
}
const R1 = (s) => {
  const e = s.readLen(), t = [];
  for (let n = 0; n < e; n++) {
    const i = s.readString();
    i === "undefined" ? t.push(void 0) : t.push(JSON.parse(i));
  }
  return new no(t);
};
class ls {
  /**
   * @param {Array<any>} arr
   */
  constructor(e) {
    this.arr = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.arr.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.arr;
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentAny}
   */
  copy() {
    return new ls(this.arr);
  }
  /**
   * @param {number} offset
   * @return {ContentAny}
   */
  splice(e) {
    const t = new ls(this.arr.slice(e));
    return this.arr = this.arr.slice(0, e), t;
  }
  /**
   * @param {ContentAny} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.arr = this.arr.concat(e.arr), !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    const n = this.arr.length;
    e.writeLen(n - t);
    for (let i = t; i < n; i++) {
      const r = this.arr[i];
      e.writeAny(r);
    }
  }
  /**
   * @return {number}
   */
  getRef() {
    return 8;
  }
}
const B1 = (s) => {
  const e = s.readLen(), t = [];
  for (let n = 0; n < e; n++)
    t.push(s.readAny());
  return new ls(t);
};
class Ht {
  /**
   * @param {string} str
   */
  constructor(e) {
    this.str = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return this.str.length;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return this.str.split("");
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentString}
   */
  copy() {
    return new Ht(this.str);
  }
  /**
   * @param {number} offset
   * @return {ContentString}
   */
  splice(e) {
    const t = new Ht(this.str.slice(e));
    this.str = this.str.slice(0, e);
    const n = this.str.charCodeAt(e - 1);
    return n >= 55296 && n <= 56319 && (this.str = this.str.slice(0, e - 1) + "�", t.str = "�" + t.str.slice(1)), t;
  }
  /**
   * @param {ContentString} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.str += e.str, !0;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeString(t === 0 ? this.str : this.str.slice(t));
  }
  /**
   * @return {number}
   */
  getRef() {
    return 4;
  }
}
const $1 = (s) => new Ht(s.readString()), F1 = [
  b1,
  x1,
  A1,
  k1,
  M1,
  _1,
  O1
], z1 = 0, V1 = 1, H1 = 2, U1 = 3, q1 = 4, G1 = 5, W1 = 6;
class Gt {
  /**
   * @param {AbstractType<any>} type
   */
  constructor(e) {
    this.type = e;
  }
  /**
   * @return {number}
   */
  getLength() {
    return 1;
  }
  /**
   * @return {Array<any>}
   */
  getContent() {
    return [this.type];
  }
  /**
   * @return {boolean}
   */
  isCountable() {
    return !0;
  }
  /**
   * @return {ContentType}
   */
  copy() {
    return new Gt(this.type._copy());
  }
  /**
   * @param {number} offset
   * @return {ContentType}
   */
  splice(e) {
    throw Ft();
  }
  /**
   * @param {ContentType} right
   * @return {boolean}
   */
  mergeWith(e) {
    return !1;
  }
  /**
   * @param {Transaction} transaction
   * @param {Item} item
   */
  integrate(e, t) {
    this.type._integrate(e.doc, t);
  }
  /**
   * @param {Transaction} transaction
   */
  delete(e) {
    let t = this.type._start;
    for (; t !== null; )
      t.deleted ? t.id.clock < (e.beforeState.get(t.id.client) || 0) && e._mergeStructs.push(t) : t.delete(e), t = t.right;
    this.type._map.forEach((n) => {
      n.deleted ? n.id.clock < (e.beforeState.get(n.id.client) || 0) && e._mergeStructs.push(n) : n.delete(e);
    }), e.changed.delete(this.type);
  }
  /**
   * @param {StructStore} store
   */
  gc(e) {
    let t = this.type._start;
    for (; t !== null; )
      t.gc(e, !0), t = t.right;
    this.type._start = null, this.type._map.forEach(
      /** @param {Item | null} item */
      (n) => {
        for (; n !== null; )
          n.gc(e, !0), n = n.left;
      }
    ), this.type._map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    this.type._write(e);
  }
  /**
   * @return {number}
   */
  getRef() {
    return 7;
  }
}
const J1 = (s) => new Gt(F1[s.readTypeRef()](s)), za = (s, e) => {
  let t = e, n = 0, i;
  do
    n > 0 && (t = X(t.client, t.clock + n)), i = Ps(s, t), n = t.clock - i.id.clock, t = i.redone;
  while (t !== null && i instanceof he);
  return {
    item: i,
    diff: n
  };
}, Nl = (s, e) => {
  for (; s !== null && s.keep !== e; )
    s.keep = e, s = /** @type {AbstractType<any>} */
    s.parent._item;
}, so = (s, e, t) => {
  const { client: n, clock: i } = e.id, r = new he(
    X(n, i + t),
    e,
    X(n, i + t - 1),
    e.right,
    e.rightOrigin,
    e.parent,
    e.parentSub,
    e.content.splice(t)
  );
  return e.deleted && r.markDeleted(), e.keep && (r.keep = !0), e.redone !== null && (r.redone = X(e.redone.client, e.redone.clock + t)), e.right = r, r.right !== null && (r.right.left = r), s._mergeStructs.push(r), r.parentSub !== null && r.right === null && r.parent._map.set(r.parentSub, r), e.length = t, r;
}, qc = (s, e) => vp(
  s,
  /** @param {StackItem} s */
  (t) => cr(t.deletions, e)
), sd = (s, e, t, n, i, r) => {
  const o = s.doc, a = o.store, l = o.clientID, c = e.redone;
  if (c !== null)
    return nt(s, c);
  let u = (
    /** @type {AbstractType<any>} */
    e.parent._item
  ), f = null, d;
  if (u !== null && u.deleted === !0) {
    if (u.redone === null && (!t.has(u) || sd(s, u, t, n, i, r) === null))
      return null;
    for (; u.redone !== null; )
      u = nt(s, u.redone);
  }
  const g = u === null ? (
    /** @type {AbstractType<any>} */
    e.parent
  ) : (
    /** @type {ContentType} */
    u.content.type
  );
  if (e.parentSub === null) {
    for (f = e.left, d = e; f !== null; ) {
      let v = f;
      for (; v !== null && /** @type {AbstractType<any>} */
      v.parent._item !== u; )
        v = v.redone === null ? null : nt(s, v.redone);
      if (v !== null && /** @type {AbstractType<any>} */
      v.parent._item === u) {
        f = v;
        break;
      }
      f = f.left;
    }
    for (; d !== null; ) {
      let v = d;
      for (; v !== null && /** @type {AbstractType<any>} */
      v.parent._item !== u; )
        v = v.redone === null ? null : nt(s, v.redone);
      if (v !== null && /** @type {AbstractType<any>} */
      v.parent._item === u) {
        d = v;
        break;
      }
      d = d.right;
    }
  } else if (d = null, e.right && !i) {
    for (f = e; f !== null && f.right !== null && (f.right.redone || cr(n, f.right.id) || qc(r.undoStack, f.right.id) || qc(r.redoStack, f.right.id)); )
      for (f = f.right; f.redone; )
        f = nt(s, f.redone);
    if (f && f.right !== null)
      return null;
  } else
    f = g._map.get(e.parentSub) || null;
  const p = Me(a, l), m = X(l, p), w = new he(
    m,
    f,
    f && f.lastId,
    d,
    d && d.id,
    g,
    e.parentSub,
    e.content.copy()
  );
  return e.redone = m, Nl(w, !0), w.integrate(s, 0), w;
};
class he extends Dl {
  /**
   * @param {ID} id
   * @param {Item | null} left
   * @param {ID | null} origin
   * @param {Item | null} right
   * @param {ID | null} rightOrigin
   * @param {AbstractType<any>|ID|null} parent Is a type if integrated, is null if it is possible to copy parent from left or right, is ID before integration to search for it.
   * @param {string | null} parentSub
   * @param {AbstractContent} content
   */
  constructor(e, t, n, i, r, o, a, l) {
    super(e, l.getLength()), this.origin = n, this.left = t, this.right = i, this.rightOrigin = r, this.parent = o, this.parentSub = a, this.redone = null, this.content = l, this.info = this.content.isCountable() ? bc : 0;
  }
  /**
   * This is used to mark the item as an indexed fast-search marker
   *
   * @type {boolean}
   */
  set marker(e) {
    (this.info & sa) > 0 !== e && (this.info ^= sa);
  }
  get marker() {
    return (this.info & sa) > 0;
  }
  /**
   * If true, do not garbage collect this Item.
   */
  get keep() {
    return (this.info & yc) > 0;
  }
  set keep(e) {
    this.keep !== e && (this.info ^= yc);
  }
  get countable() {
    return (this.info & bc) > 0;
  }
  /**
   * Whether this item was deleted or not.
   * @type {Boolean}
   */
  get deleted() {
    return (this.info & na) > 0;
  }
  set deleted(e) {
    this.deleted !== e && (this.info ^= na);
  }
  markDeleted() {
    this.info |= na;
  }
  /**
   * Return the creator clientID of the missing op or define missing items and return null.
   *
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, t) {
    if (this.origin && this.origin.client !== this.id.client && this.origin.clock >= Me(t, this.origin.client))
      return this.origin.client;
    if (this.rightOrigin && this.rightOrigin.client !== this.id.client && this.rightOrigin.clock >= Me(t, this.rightOrigin.client))
      return this.rightOrigin.client;
    if (this.parent && this.parent.constructor === ks && this.id.client !== this.parent.client && this.parent.clock >= Me(t, this.parent.client))
      return this.parent.client;
    if (this.origin && (this.left = jc(e, t, this.origin), this.origin = this.left.lastId), this.rightOrigin && (this.right = nt(e, this.rightOrigin), this.rightOrigin = this.right.id), this.left && this.left.constructor === vt || this.right && this.right.constructor === vt)
      this.parent = null;
    else if (!this.parent)
      this.left && this.left.constructor === he && (this.parent = this.left.parent, this.parentSub = this.left.parentSub), this.right && this.right.constructor === he && (this.parent = this.right.parent, this.parentSub = this.right.parentSub);
    else if (this.parent.constructor === ks) {
      const n = Ps(t, this.parent);
      n.constructor === vt ? this.parent = null : this.parent = /** @type {ContentType} */
      n.content.type;
    }
    return null;
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, t) {
    if (t > 0 && (this.id.clock += t, this.left = jc(e, e.doc.store, X(this.id.client, this.id.clock - 1)), this.origin = this.left.lastId, this.content = this.content.splice(t), this.length -= t), this.parent) {
      if (!this.left && (!this.right || this.right.left !== null) || this.left && this.left.right !== this.right) {
        let n = this.left, i;
        if (n !== null)
          i = n.right;
        else if (this.parentSub !== null)
          for (i = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; i !== null && i.left !== null; )
            i = i.left;
        else
          i = /** @type {AbstractType<any>} */
          this.parent._start;
        const r = /* @__PURE__ */ new Set(), o = /* @__PURE__ */ new Set();
        for (; i !== null && i !== this.right; ) {
          if (o.add(i), r.add(i), Ms(this.origin, i.origin)) {
            if (i.id.client < this.id.client)
              n = i, r.clear();
            else if (Ms(this.rightOrigin, i.rightOrigin))
              break;
          } else if (i.origin !== null && o.has(Ps(e.doc.store, i.origin)))
            r.has(Ps(e.doc.store, i.origin)) || (n = i, r.clear());
          else
            break;
          i = i.right;
        }
        this.left = n;
      }
      if (this.left !== null) {
        const n = this.left.right;
        this.right = n, this.left.right = this;
      } else {
        let n;
        if (this.parentSub !== null)
          for (n = /** @type {AbstractType<any>} */
          this.parent._map.get(this.parentSub) || null; n !== null && n.left !== null; )
            n = n.left;
        else
          n = /** @type {AbstractType<any>} */
          this.parent._start, this.parent._start = this;
        this.right = n;
      }
      this.right !== null ? this.right.left = this : this.parentSub !== null && (this.parent._map.set(this.parentSub, this), this.left !== null && this.left.delete(e)), this.parentSub === null && this.countable && !this.deleted && (this.parent._length += this.length), ju(e.doc.store, this), this.content.integrate(e, this), Bc(
        e,
        /** @type {AbstractType<any>} */
        this.parent,
        this.parentSub
      ), /** @type {AbstractType<any>} */
      (this.parent._item !== null && /** @type {AbstractType<any>} */
      this.parent._item.deleted || this.parentSub !== null && this.right !== null) && this.delete(e);
    } else
      new vt(this.id, this.length).integrate(e, 0);
  }
  /**
   * Returns the next non-deleted item
   */
  get next() {
    let e = this.right;
    for (; e !== null && e.deleted; )
      e = e.right;
    return e;
  }
  /**
   * Returns the previous non-deleted item
   */
  get prev() {
    let e = this.left;
    for (; e !== null && e.deleted; )
      e = e.left;
    return e;
  }
  /**
   * Computes the last content address of this Item.
   */
  get lastId() {
    return this.length === 1 ? this.id : X(this.id.client, this.id.clock + this.length - 1);
  }
  /**
   * Try to merge two items
   *
   * @param {Item} right
   * @return {boolean}
   */
  mergeWith(e) {
    if (this.constructor === e.constructor && Ms(e.origin, this.lastId) && this.right === e && Ms(this.rightOrigin, e.rightOrigin) && this.id.client === e.id.client && this.id.clock + this.length === e.id.clock && this.deleted === e.deleted && this.redone === null && e.redone === null && this.content.constructor === e.content.constructor && this.content.mergeWith(e.content)) {
      const t = (
        /** @type {AbstractType<any>} */
        this.parent._searchMarker
      );
      return t && t.forEach((n) => {
        n.p === e && (n.p = this, !this.deleted && this.countable && (n.index -= this.length));
      }), e.keep && (this.keep = !0), this.right = e.right, this.right !== null && (this.right.left = this), this.length += e.length, !0;
    }
    return !1;
  }
  /**
   * Mark this Item as deleted.
   *
   * @param {Transaction} transaction
   */
  delete(e) {
    if (!this.deleted) {
      const t = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      this.countable && this.parentSub === null && (t._length -= this.length), this.markDeleted(), Ui(e.deleteSet, this.id.client, this.id.clock, this.length), Bc(e, t, this.parentSub), this.content.delete(e);
    }
  }
  /**
   * @param {StructStore} store
   * @param {boolean} parentGCd
   */
  gc(e, t) {
    if (!this.deleted)
      throw At();
    this.content.gc(e), t ? Qm(e, this, new vt(this.id, this.length)) : this.content = new Wi(this.length);
  }
  /**
   * Transform the properties of this type to binary and write it to an
   * BinaryEncoder.
   *
   * This is called when this Item is sent to a remote peer.
   *
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder The encoder to write data to.
   * @param {number} offset
   */
  write(e, t) {
    const n = t > 0 ? X(this.id.client, this.id.clock + t - 1) : this.origin, i = this.rightOrigin, r = this.parentSub, o = this.content.getRef() & So | (n === null ? 0 : ut) | // origin is defined
    (i === null ? 0 : sn) | // right origin is defined
    (r === null ? 0 : Bi);
    if (e.writeInfo(o), n !== null && e.writeLeftID(n), i !== null && e.writeRightID(i), n === null && i === null) {
      const a = (
        /** @type {AbstractType<any>} */
        this.parent
      );
      if (a._item !== void 0) {
        const l = a._item;
        if (l === null) {
          const c = Tu(a);
          e.writeParentInfo(!0), e.writeString(c);
        } else
          e.writeParentInfo(!1), e.writeLeftID(l.id);
      } else
        a.constructor === String ? (e.writeParentInfo(!0), e.writeString(a)) : a.constructor === ks ? (e.writeParentInfo(!1), e.writeLeftID(a)) : At();
      r !== null && e.writeString(r);
    }
    this.content.write(e, t);
  }
}
const id = (s, e) => Y1[e & So](s), Y1 = [
  () => {
    At();
  },
  // GC is not ItemContent
  D1,
  // 1
  R1,
  // 2
  L1,
  // 3
  $1,
  // 4
  I1,
  // 5
  j1,
  // 6
  J1,
  // 7
  B1,
  // 8
  N1,
  // 9
  () => {
    At();
  }
  // 10 - Skip is not ItemContent
], X1 = 10;
class xt extends Dl {
  get deleted() {
    return !0;
  }
  delete() {
  }
  /**
   * @param {Skip} right
   * @return {boolean}
   */
  mergeWith(e) {
    return this.constructor !== e.constructor ? !1 : (this.length += e.length, !0);
  }
  /**
   * @param {Transaction} transaction
   * @param {number} offset
   */
  integrate(e, t) {
    At();
  }
  /**
   * @param {UpdateEncoderV1 | UpdateEncoderV2} encoder
   * @param {number} offset
   */
  write(e, t) {
    e.writeInfo(X1), K(e.restEncoder, this.length - t);
  }
  /**
   * @param {Transaction} transaction
   * @param {StructStore} store
   * @return {null | number}
   */
  getMissing(e, t) {
    return null;
  }
}
const rd = (
  /** @type {any} */
  typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : {}
), od = "__ $YJS$ __";
rd[od] === !0 && console.error("Yjs was already imported. This breaks constructor checks and will lead to issues! - https://github.com/yjs/yjs/issues/438");
rd[od] = !0;
function Gc(s) {
  return Object.prototype.toString.call(s) === "[object Object]";
}
function Wc(s) {
  if (!Gc(s))
    return !1;
  const e = s.constructor;
  if (e === void 0)
    return !0;
  const t = e.prototype;
  return !(Gc(t) === !1 || t.hasOwnProperty("isPrototypeOf") === !1);
}
function Il(s, e) {
  for (const t in s) {
    const n = s[t], i = e[t];
    if (Wc(n) && Wc(i)) {
      if (!Il(n, i))
        return !1;
    } else if (Array.isArray(n) && Array.isArray(i)) {
      if (n.length !== i.length)
        return !1;
      for (let r = 0; r < n.length; r++)
        if (n[r] !== i[r])
          return !1;
    } else if (n !== i)
      return !1;
  }
  for (const t in e)
    if (s[t] === void 0 && e[t] !== void 0)
      return !1;
  return !0;
}
function Z1(s, ...e) {
  return Object.fromEntries(
    Object.entries(s).filter(([t]) => e.includes(t))
  );
}
function K1(s, ...e) {
  return Object.fromEntries(
    Object.entries(s).filter(([t]) => !e.includes(t))
  );
}
function Q1(s) {
  return Object.fromEntries(
    Object.entries(s).filter(([, e]) => e !== null)
  );
}
function e0(s) {
  var t, n;
  const e = [];
  for (const i of s) {
    if (typeof i.insert == "string" && i.insert.length === 0)
      continue;
    const r = e[e.length - 1];
    if (!r || typeof r.insert != "string" || typeof i.insert != "string") {
      e.push(i);
      continue;
    }
    if (r.attributes === i.attributes || !r.attributes == !i.attributes && Il((t = r.attributes) != null ? t : {}, (n = i.attributes) != null ? n : {})) {
      r.insert += i.insert;
      continue;
    }
    e.push(i);
  }
  return e;
}
function fn(s) {
  return e0(s.toDelta());
}
function ad({ insert: s }) {
  return typeof s == "string" ? s.length : 1;
}
function ld(s) {
  return s.reduce((e, t) => e + ad(t), 0);
}
function cd(s, e, t) {
  if (t < 1)
    return [];
  let n = 0;
  const i = [], r = e + t;
  for (let o = 0; o < s.length && !(n >= r); o++) {
    const a = s[o], l = ad(a);
    if (n + l <= e) {
      n += l;
      continue;
    }
    if (typeof a.insert != "string") {
      n += l, i.push(a);
      continue;
    }
    const c = Math.max(0, e - n), u = Math.min(
      l,
      l - (n + l - r)
    );
    i.push({
      ...a,
      insert: a.insert.slice(c, u)
    }), n += l;
  }
  return i;
}
function en(s) {
  return K1(
    s,
    de.isText(s) ? "text" : "children"
  );
}
function hd(s) {
  const e = fn(s), t = e.length > 0 ? e.map(Va) : [{ text: "" }];
  return { ...s.getAttributes(), children: t };
}
function Va(s) {
  return typeof s.insert == "string" ? { ...s.attributes, text: s.insert } : hd(s.insert);
}
function ud(s) {
  return s.map((e) => de.isText(e) ? { insert: e.text, attributes: en(e) } : { insert: dd(e) });
}
function dd({
  children: s,
  ...e
}) {
  const t = new Je();
  return Object.entries(e).forEach(([n, i]) => {
    t.setAttribute(n, i);
  }), t.applyDelta(ud(s), { sanitize: !1 }), t;
}
function Ji(s) {
  return s ? de.isText(s) ? s.text.length : 1 : 0;
}
function t0(s, e) {
  return s.children.slice(0, e).reduce((t, n) => t + Ji(n), 0);
}
function dt(s, e, t) {
  var f;
  if (t.length === 0)
    throw new Error("Path has to a have a length >= 1");
  if (de.isText(e))
    throw new Error("Cannot descent into slate text");
  const [n, ...i] = t, r = t0(e, n), o = e.children[n], a = fn(s), l = Ji(o), c = cd(a, r, l);
  if (c.length > 1)
    throw new Error("Path doesn't match yText, yTarget spans multiple nodes");
  const u = (f = c[0]) == null ? void 0 : f.insert;
  if (i.length > 0) {
    if (!(u instanceof Je))
      throw new Error(
        "Path doesn't match yText, cannot descent into non-yText"
      );
    return dt(u, o, i);
  }
  return {
    yParent: s,
    textRange: { start: r, end: r + l },
    yTarget: u instanceof Je ? u : void 0,
    slateParent: e,
    slateTarget: o,
    targetDelta: c
  };
}
function Jn(s, e, t = {}) {
  const { assoc: n = 0, insert: i = !1 } = t;
  let r = 0, o = 0;
  for (let c = 0; c < s.children.length; c++) {
    const u = s.children[c], f = de.isText(u) ? u.text.length : 1;
    f > 0 && (o = c);
    const d = r + f;
    if (f > 0 && (n >= 0 ? d > e : d >= e))
      return [c, e - r];
    r += f;
  }
  if (e > r + (i ? 1 : 0))
    throw new Error("yOffset out of bounds");
  if (i)
    return [s.children.length, 0];
  const a = s.children[o], l = de.isText(a) ? a.text.length : 1;
  return [o, l];
}
function fd(s, e, t) {
  const n = [t];
  for (; n[0] !== s; ) {
    const { parent: r } = n[0];
    if (!r)
      throw new Error("yText isn't a descendant of root element");
    if (!(r instanceof Je))
      throw new Error("Unexpected y parent type");
    n.unshift(r);
  }
  if (n.length < 2)
    return [];
  let i = e;
  return n.reduce((r, o, a) => {
    const l = n[a + 1];
    if (!l)
      return r;
    let c = 0;
    const u = fn(o);
    for (const d of u) {
      if (d.insert === l)
        break;
      c += typeof d.insert == "string" ? d.insert.length : 1;
    }
    if (de.isText(i))
      throw new Error("Cannot descent into slate text");
    const [f] = Jn(i, c);
    return i = i.children[f], r.concat(f);
  }, []);
}
function Os(s) {
  if (!s.doc)
    throw new Error("shared type isn't attached to a document");
}
const cs = "__slateYjsStoredPosition_";
function Ha(s, e, t) {
  const { yTarget: n, yParent: i, textRange: r } = dt(
    s,
    e,
    t.path
  );
  if (n)
    throw new Error(
      "Slate point points to a non-text element inside sharedRoot"
    );
  const o = r.start + t.offset;
  return Lu(
    i,
    o,
    o === r.end ? -1 : 0
  );
}
function n0(s, e, { type: t, index: n, assoc: i }) {
  if (!(t instanceof Je))
    throw new Error("Absolute position points to a non-XMLText");
  const r = fd(s, e, t), o = ps.get(e, r);
  if (de.isText(o))
    throw new Error(
      "Absolute position doesn't match slateRoot, cannot descent into text"
    );
  const [a, l] = Jn(o, n, {
    assoc: i
  }), c = o.children[a];
  return de.isText(c) ? { path: [...r, a], offset: l } : null;
}
function Ua(s, e, t) {
  if (!s.doc)
    throw new Error("sharedRoot isn't attach to a yDoc");
  const n = Nu(
    t,
    s.doc
  );
  return n && n0(s, e, n);
}
function s0(s, e) {
  const t = s.getAttribute(cs + e);
  return t ? Du(t) : null;
}
function i0(s) {
  return Object.fromEntries(
    Object.entries(s.getAttributes()).filter(([e]) => e.startsWith(cs)).map(([e, t]) => [
      e.slice(cs.length),
      Gm(t)
    ])
  );
}
function r0(s) {
  return Os(s), Object.fromEntries(
    Object.entries(s.getAttributes()).filter(([e]) => e.startsWith(cs)).map(
      ([e, t]) => [
        e.slice(cs.length),
        Nu(
          Du(t),
          s.doc
        )
      ]
    ).filter(([, e]) => e)
  );
}
function o0(s, e) {
  s.removeAttribute(cs + e);
}
function gd(s, e, t) {
  s.setAttribute(
    cs + e,
    Xm(t)
  );
}
function pd(s, e, t) {
  return Object.fromEntries(
    Object.entries(s).filter(([, n]) => n.type !== e ? !1 : t ? n.assoc >= 0 ? n.index >= t.start && n.index < t.end : n.index > t.start && n.index >= t.end : !0)
  );
}
function md(s, e, t = "") {
  const n = {
    [t]: pd(s, e)
  };
  return fn(e).forEach(({ insert: r }, o) => {
    r instanceof Je && Object.assign(
      n,
      md(
        s,
        r,
        t ? "".concat(t, ".").concat(o) : o.toString()
      )
    );
  }), n;
}
function jl(s, e, t, n = 0) {
  const i = r0(s), r = {
    "": pd(i, e, {
      start: n,
      end: n + ld(t)
    })
  };
  return t.forEach(({ insert: o }, a) => {
    o instanceof Je && Object.assign(
      r,
      md(i, o, a.toString())
    );
  }), r;
}
function Do(s, e, t, n, i = 0, r = 0, o = "") {
  const a = t[o];
  a && Object.entries(a).forEach(([l, c]) => {
    gd(
      s,
      l,
      Lu(
        e,
        c.index - r + i,
        c.assoc
      )
    );
  }), n.forEach(({ insert: l }, c) => {
    l instanceof Je && Do(
      s,
      l,
      t,
      fn(l),
      0,
      0,
      o ? "".concat(o, ".").concat(c) : c.toString()
    );
  });
}
function Hr(s, e, t) {
  return {
    anchor: Ha(s, e, t.anchor),
    focus: Ha(s, e, t.focus)
  };
}
function wd(s, e, t) {
  const n = Ua(
    s,
    e,
    t.anchor
  );
  if (!n)
    return null;
  const i = Ua(
    s,
    e,
    t.focus
  );
  return i ? { anchor: n, focus: i } : null;
}
function a0(s, e, t) {
  const n = [];
  let i = t.reduce((r, o) => "retain" in o ? r + o.retain : "delete" in o ? r + o.delete : r, 0);
  return t.reverse().forEach((r) => {
    var o;
    if ("attributes" in r && "retain" in r) {
      const [a, l] = Jn(
        s,
        i - r.retain
      ), [c, u] = Jn(
        s,
        i,
        { assoc: -1 }
      );
      for (let f = c; f >= a; f--) {
        const d = s.children[f], g = [...e, f];
        if (!de.isText(d))
          continue;
        const p = r.attributes, m = Z1(
          s,
          ...Object.keys(r.attributes)
        );
        if (f === a || f === c) {
          const w = f === a ? l : 0, v = f === c ? u : d.text.length;
          if (v !== d.text.length && n.push({
            type: "split_node",
            path: g,
            position: v,
            properties: en(d)
          }), w !== 0) {
            n.push({
              type: "split_node",
              path: g,
              position: w,
              properties: Q1({
                ...en(d),
                ...p
              })
            });
            continue;
          }
        }
        n.push({
          type: "set_node",
          newProperties: p,
          path: g,
          properties: m
        });
      }
    }
    if ("retain" in r && (i -= r.retain), "delete" in r) {
      const [a, l] = Jn(
        s,
        i - r.delete
      ), [c, u] = Jn(
        s,
        i,
        { assoc: -1 }
      );
      for (let f = u === 0 ? c - 1 : c; f >= a; f--) {
        const d = s.children[f], g = [...e, f];
        if (de.isText(d) && (f === a || f === c)) {
          const p = f === a ? l : 0, m = f === c ? u : d.text.length;
          n.push({
            type: "remove_text",
            offset: p,
            text: d.text.slice(p, m),
            path: g
          }), i -= m - p;
          continue;
        }
        n.push({
          type: "remove_node",
          node: d,
          path: g
        }), i -= Ji(d);
      }
      return;
    }
    if ("insert" in r) {
      const [a, l] = Jn(s, i, {
        insert: !0
      }), c = s.children[a], u = [...e, a];
      if (de.isText(c)) {
        const f = n[n.length - 1], d = f != null && f.type === "insert_node" ? f.node : en(c);
        let g = [];
        if (f != null && (f.type === "insert_node" || f.type === "insert_text" || f.type === "split_node" || f.type === "set_node") && (g = f.path), typeof r.insert == "string" && Il((o = r.attributes) != null ? o : {}, d) && is.equals(u, g))
          return n.push({
            type: "insert_text",
            offset: l,
            text: r.insert,
            path: u
          });
        const p = Va(r);
        return l === 0 ? n.push({
          type: "insert_node",
          path: u,
          node: p
        }) : (l < c.text.length && n.push({
          type: "split_node",
          path: u,
          position: l,
          properties: en(c)
        }), n.push({
          type: "insert_node",
          path: is.next(u),
          node: p
        }));
      }
      return n.push({
        type: "insert_node",
        path: u,
        node: Va(r)
      });
    }
  }), n;
}
function l0(s, e, t) {
  const { target: n, changes: i } = t, r = t.delta;
  if (!(n instanceof Je))
    throw new Error("Unexpected target node type");
  const o = [], a = fd(s, e, n), l = ps.get(e, a);
  if (de.isText(l))
    throw new Error("Cannot apply yTextEvent to text node");
  const c = Array.from(i.keys.entries());
  if (a.length > 0 && c.length > 0) {
    const u = Object.fromEntries(
      c.map(([d, g]) => [
        d,
        g.action === "delete" ? null : n.getAttribute(d)
      ])
    ), f = Object.fromEntries(
      c.map(([d]) => [d, l[d]])
    );
    o.push({ type: "set_node", newProperties: u, properties: f, path: a });
  }
  return r.length > 0 && o.push(...a0(l, a, r)), o;
}
function c0(s, e, t) {
  if (t instanceof td)
    return l0(s, e, t);
  throw new Error("Unexpected Y event type");
}
function h0(s, e, t) {
  Q.withoutNormalizing(e, () => {
    t.forEach((n) => {
      c0(s, e, n).forEach((i) => {
        e.apply(i);
      });
    });
  });
}
function u0(s, e, t) {
  const { yParent: n, textRange: i } = dt(s, e, t.path);
  if (de.isText(t.node))
    return n.insert(
      i.start,
      t.node.text,
      en(t.node)
    );
  n.insertEmbed(i.start, dd(t.node));
}
function d0(s) {
  const e = new Je(), t = s.getAttributes();
  return Object.entries(t).forEach(([n, i]) => {
    e.setAttribute(n, i);
  }), e.applyDelta(No(fn(s)), {
    sanitize: !1
  }), e;
}
function No(s) {
  return s.map((e) => typeof e.insert == "string" ? e : { ...e, insert: d0(e.insert) });
}
function f0(s, e, t) {
  const n = dt(s, e, t.path), i = dt(
    n.yParent,
    n.slateParent,
    is.previous(t.path.slice(-1))
  );
  if (!n.yTarget != !i.yTarget)
    throw new Error("Cannot merge y text with y element");
  if (!i.yTarget || !n.yTarget) {
    const { yParent: u, textRange: f, slateTarget: d } = n;
    if (!d)
      throw new Error("Expected Slate target node for merge op.");
    const g = ps.get(e, is.previous(t.path));
    if (!de.isText(g))
      throw new Error("Path points to Y.Text but not a Slate text node.");
    const p = en(d), m = en(g), w = Object.keys(p).reduce((v, y) => y in m ? v : { ...v, [y]: null }, {});
    return u.format(f.start, f.end - f.start, {
      ...w,
      ...m
    });
  }
  const r = i.yTarget.length, o = fn(n.yTarget), a = No(o), l = jl(
    s,
    n.yTarget,
    o,
    r
  ), c = [{ retain: r }, ...a];
  i.yTarget.applyDelta(c, {
    sanitize: !1
  }), n.yParent.delete(
    n.textRange.start,
    n.textRange.end - n.textRange.start
  ), Do(
    s,
    i.yTarget,
    l,
    a,
    r
  );
}
function g0(s, e, t) {
  const n = is.parent(t.newPath), i = t.newPath[t.newPath.length - 1], r = ps.get(e, n);
  if (de.isText(r))
    throw new Error("Cannot move slate node into text element");
  const o = [
    ...n,
    Math.min(i, r.children.length)
  ], a = dt(s, e, t.path), l = dt(s, e, o), c = No(a.targetDelta), u = jl(
    s,
    a.yParent,
    a.targetDelta
  );
  a.yParent.delete(
    a.textRange.start,
    a.textRange.end - a.textRange.start
  );
  const f = ld(fn(l.yParent)), d = Math.min(l.textRange.start, f), g = [{ retain: d }, ...c];
  l.yParent.applyDelta(g, { sanitize: !1 }), Do(
    s,
    l.yParent,
    u,
    c,
    d,
    a.textRange.start
  );
}
function p0(s, e, t) {
  const { yParent: n, textRange: i } = dt(
    s,
    e,
    t.path
  );
  n.delete(i.start, i.end - i.start);
}
function m0(s, e, t) {
  const { yTarget: n, textRange: i, yParent: r } = dt(
    s,
    e,
    t.path
  );
  if (n)
    return Object.entries(t.newProperties).forEach(([l, c]) => {
      if (c === null)
        return n.removeAttribute(l);
      n.setAttribute(l, c);
    }), Object.entries(t.properties).forEach(([l]) => {
      t.newProperties.hasOwnProperty(l) || n.removeAttribute(l);
    });
  const a = { ...Object.fromEntries(
    Object.keys(t.properties).map((l) => [l, null])
  ), ...t.newProperties };
  r.format(
    i.start,
    i.end - i.start,
    a
  );
}
function w0(s, e, t) {
  const n = dt(s, e, t.path);
  if (!n.slateTarget)
    throw new Error("Y target without corresponding slate node");
  if (!n.yTarget) {
    if (!de.isText(n.slateTarget))
      throw new Error("Mismatch node type between y target and slate node");
    const f = {};
    return n.targetDelta.forEach((d) => {
      d.attributes && Object.keys(d.attributes).forEach((g) => {
        f[g] = null;
      });
    }), n.yParent.format(
      n.textRange.start,
      n.textRange.end - n.textRange.start,
      { ...f, ...t.properties }
    );
  }
  if (de.isText(n.slateTarget))
    throw new Error("Mismatch node type between y target and slate node");
  const i = dt(n.yTarget, n.slateTarget, [
    t.position
  ]), r = n.slateTarget.children.slice(0, t.position).reduce((f, d) => f + Ji(d), 0), o = n.slateTarget.children.reduce(
    (f, d) => f + Ji(d),
    0
  ), a = cd(
    fn(n.yTarget),
    r,
    o - r
  ), l = No(a), c = jl(
    s,
    n.yTarget,
    a,
    r
  ), u = new Je();
  u.applyDelta(l, {
    sanitize: !1
  }), Object.entries(t.properties).forEach(([f, d]) => {
    u.setAttribute(f, d);
  }), n.yTarget.delete(
    i.textRange.start,
    n.yTarget.length - i.textRange.start
  ), n.yParent.insertEmbed(n.textRange.end, u), Do(
    s,
    u,
    c,
    l,
    0,
    r
  );
}
const y0 = {
  insert_node: u0,
  remove_node: p0,
  set_node: m0,
  merge_node: f0,
  move_node: g0,
  split_node: w0
};
function b0(s, e, t) {
  const { yParent: n, textRange: i } = dt(
    s,
    e,
    t.path
  ), r = ps.get(e, t.path);
  if (!de.isText(r))
    throw new Error("Cannot insert text into non-text node");
  n.insert(
    i.start + t.offset,
    t.text,
    en(r)
  );
}
function v0(s, e, t) {
  const { yParent: n, textRange: i } = dt(
    s,
    e,
    t.path
  );
  n.delete(i.start + t.offset, t.text.length);
}
const x0 = {
  insert_text: b0,
  remove_text: v0
}, C0 = () => {
}, E0 = {
  ...x0,
  ...y0,
  set_selection: C0
};
function S0(s, e, t) {
  const n = E0[t.type];
  if (!n)
    throw new Error("Unknown operation: ".concat(t.type));
  n(s, e, t);
}
const A0 = Symbol("slate-yjs-operation"), M0 = Symbol("slate-yjs-position-storage"), ca = /* @__PURE__ */ new WeakMap(), qa = /* @__PURE__ */ new WeakMap(), Ga = /* @__PURE__ */ new WeakSet(), be = {
  isYjsEditor(s) {
    return Q.isEditor(s) && s.sharedRoot instanceof Je && "localOrigin" in s && "positionStorageOrigin" in s && typeof s.applyRemoteEvents == "function" && typeof s.storeLocalChange == "function" && typeof s.flushLocalChanges == "function" && typeof s.isLocalOrigin == "function" && typeof s.connect == "function" && typeof s.disconnect == "function";
  },
  localChanges(s) {
    var e;
    return (e = qa.get(s)) != null ? e : [];
  },
  applyRemoteEvents(s, e, t) {
    s.applyRemoteEvents(e, t);
  },
  storeLocalChange(s, e) {
    s.storeLocalChange(e);
  },
  flushLocalChanges(s) {
    s.flushLocalChanges();
  },
  connected(s) {
    return Ga.has(s);
  },
  connect(s) {
    s.connect();
  },
  disconnect(s) {
    s.disconnect();
  },
  isLocal(s) {
    return s.isLocalOrigin(be.origin(s));
  },
  origin(s) {
    const e = ca.get(s);
    return e !== void 0 ? e : s.localOrigin;
  },
  withOrigin(s, e, t) {
    const n = be.origin(s);
    ca.set(s, e), t(), ca.set(s, n);
  },
  storePosition(s, e, t) {
    var o;
    const { sharedRoot: n, positionStorageOrigin: i } = s;
    Os(n);
    const r = Ha(n, s, t);
    (o = n.doc) == null || o.transact(() => {
      gd(n, e, r);
    }, i);
  },
  removeStoredPosition(s, e) {
    var i;
    const { sharedRoot: t, positionStorageOrigin: n } = s;
    Os(t), (i = t.doc) == null || i.transact(() => {
      o0(t, e);
    }, n);
  },
  position(s, e) {
    const t = s0(s.sharedRoot, e);
    if (t)
      return Ua(s.sharedRoot, s, t);
  },
  storedPositionsRelative(s) {
    return i0(s.sharedRoot);
  }
};
function k0(s, e, t, {
  localOrigin: n,
  positionStorageOrigin: i,
  autoConnect: r = !1
} = {}) {
  const o = s;
  o.sharedRoot = e, o.editorWindow = t, o.localOrigin = n != null ? n : A0, o.positionStorageOrigin = i != null ? i : M0, o.applyRemoteEvents = (f, d) => {
    be.flushLocalChanges(o), Q.withoutNormalizing(o, () => {
      be.withOrigin(o, d, () => {
        h0(o.sharedRoot, o, f);
      });
    });
  }, o.isLocalOrigin = (f) => f === o.localOrigin;
  const a = (f, d) => {
    o.isLocalOrigin(d.origin) || be.applyRemoteEvents(o, f, d.origin);
  };
  let l = null;
  r && (l = setTimeout(() => {
    l = null, be.connect(o);
  })), o.connect = () => {
    if (be.connected(o))
      throw new Error("already connected");
    o.sharedRoot.observeDeep(a);
    const f = hd(o.sharedRoot);
    o.children = f.children, Ga.add(o), Q.normalize(s, { force: !0 }), s.operations.length || s.onChange();
  }, o.disconnect = () => {
    l && clearTimeout(l), be.flushLocalChanges(o), o.sharedRoot.unobserveDeep(a), Ga.delete(o);
  }, o.storeLocalChange = (f) => {
    qa.set(o, [
      ...be.localChanges(o),
      { op: f, doc: s.children, origin: be.origin(o) }
    ]);
  }, o.flushLocalChanges = () => {
    Os(o.sharedRoot);
    const f = be.localChanges(o);
    qa.delete(o);
    const d = [];
    f.forEach((g) => {
      const p = d[d.length - 1];
      if (p && p[0].origin === g.origin)
        return p.push(g);
      d.push([g]);
    }), d.forEach((g) => {
      var p;
      Os(o.sharedRoot), (p = o.sharedRoot.doc) == null || p.transact(() => {
        g.forEach((m) => {
          Os(o.sharedRoot), S0(o.sharedRoot, { children: m.doc }, m.op);
        });
      }, g[0].origin);
    });
  };
  const { apply: c, onChange: u } = o;
  return o.apply = (f) => {
    be.connected(o) && be.isLocal(o) && be.storeLocalChange(o, f), c(f);
  }, o.onChange = () => {
    be.connected(o) && be.flushLocalChanges(o), u();
  }, o;
}
const Jc = /* @__PURE__ */ new WeakMap(), P0 = Symbol(
  "slate-yjs-history-without-saving"
);
function _0(s, {
  withoutSavingOrigin: e = P0,
  trackedOrigins: t = /* @__PURE__ */ new Set([s.localOrigin]),
  ...n
} = {}) {
  const i = s, r = new i1(i.sharedRoot, {
    trackedOrigins: t,
    ...n
  });
  i.undoManager = r, i.withoutSavingOrigin = e;
  const { onChange: o, isLocalOrigin: a } = i;
  i.onChange = () => {
    o(), Jc.set(
      i,
      i.selection && Hr(i.sharedRoot, i, i.selection)
    );
  }, i.isLocalOrigin = (g) => g === i.withoutSavingOrigin || a(g);
  const l = ({
    stackItem: g
  }) => {
    g.meta.set(
      "selection",
      i.selection && Hr(i.sharedRoot, i, i.selection)
    ), g.meta.set("selectionBefore", Jc.get(i));
  }, c = ({
    stackItem: g
  }) => {
    g.meta.set(
      "selection",
      i.selection && Hr(i.sharedRoot, i, i.selection)
    );
  }, u = ({
    stackItem: g,
    type: p
  }) => {
    const m = p === "undo" ? i.undoManager.redoStack : i.undoManager.undoStack, w = m[m.length - 1];
    w && (w.meta.set("selection", g.meta.get("selectionBefore")), w.meta.set("selectionBefore", g.meta.get("selection")));
    const v = g.meta.get(
      "selectionBefore"
    );
    if (!v)
      return;
    const y = wd(
      i.sharedRoot,
      i,
      v
    );
    y && $e.select(i, y);
  }, { connect: f, disconnect: d } = i;
  return i.connect = () => {
    f(), i.undoManager.on("stack-item-added", l), i.undoManager.on("stack-item-popped", u), i.undoManager.on("stack-item-updated", c);
  }, i.disconnect = () => {
    i.undoManager.off("stack-item-added", l), i.undoManager.off("stack-item-popped", u), i.undoManager.off("stack-item-updated", c), d();
  }, i.undo = () => {
    be.connected(i) && (be.flushLocalChanges(i), i.undoManager.undo());
  }, i.redo = () => {
    be.connected(i) && (be.flushLocalChanges(i), i.undoManager.redo());
  }, i;
}
const Ur = /* @__PURE__ */ new WeakMap(), _r = new Zh(), En = {
  isCursorEditor(s) {
    return be.isYjsEditor(s) && s.awareness && typeof s.cursorDataField == "string" && typeof s.selectionStateField == "string" && typeof s.sendCursorPosition == "function" && typeof s.sendCursorData == "function";
  },
  sendCursorPosition(s, e = s.selection) {
    s.sendCursorPosition(e);
  },
  sendCursorData(s, e) {
    s.sendCursorData(e);
  },
  on(s, e, t) {
    var i;
    if (e !== "change")
      return;
    const n = (i = Ur.get(s)) != null ? i : /* @__PURE__ */ new Set();
    n.add(t), Ur.set(s, n);
  },
  off(s, e, t) {
    if (e !== "change")
      return;
    const n = Ur.get(s);
    n && n.delete(t);
  },
  cursorState(s, e) {
    var n;
    if (e === s.awareness.clientID || !be.connected(s))
      return null;
    const t = s.awareness.getStates().get(e);
    return t ? {
      relativeSelection: (n = t[s.selectionStateField]) != null ? n : null,
      data: t[s.cursorDataField],
      clientId: e
    } : null;
  },
  cursorStates(s) {
    return be.connected(s) ? Object.fromEntries(
      Array.from(s.awareness.getStates().entries(), ([e, t]) => e === s.awareness.clientID || !t ? null : [
        e,
        {
          relativeSelection: t[s.selectionStateField],
          data: t[s.cursorDataField]
        }
      ]).filter(Array.isArray)
    ) : {};
  },
  // TODO CursorEditor自定义事件处理器
  emitEvent(s, ...e) {
    _r.emit(s, ...e);
  },
  onEvent(s, e) {
    _r.on(s, e);
  },
  offEvent(s, e) {
    _r.off(s, e);
  },
  resetEvent() {
    _r.reset();
  }
};
function O0(s, e, {
  cursorStateField: t = "selection",
  cursorDataField: n = "data",
  autoSend: i = !0,
  data: r
} = {}) {
  const o = s;
  o.awareness = e, o.cursorDataField = n, o.selectionStateField = t, o.sendCursorData = (u) => {
    o.awareness.setLocalStateField(o.cursorDataField, u);
  }, o.sendCursorPosition = (u) => {
    const f = o.awareness.getLocalState(), d = f == null ? void 0 : f[t];
    if (!u) {
      d && o.awareness.setLocalStateField(o.selectionStateField, null);
      return;
    }
    const { anchor: g, focus: p } = Hr(o.sharedRoot, o, u);
    (!d || !Ic(g, d) || !Ic(p, d)) && o.awareness.setLocalStateField(o.selectionStateField, { anchor: g, focus: p });
  };
  const a = (u) => {
    const f = Ur.get(o);
    if (!f)
      return;
    const d = o.awareness.clientID, g = {
      added: u.added.filter((p) => p !== d),
      removed: u.removed.filter((p) => p !== d),
      updated: u.updated.filter((p) => p !== d)
    };
    (g.added.length > 0 || g.removed.length > 0 || g.updated.length > 0) && f.forEach((p) => p(g));
  }, { connect: l, disconnect: c } = o;
  return o.connect = () => {
    if (l(), o.awareness.on("change", a), a({
      removed: [],
      added: Array.from(o.awareness.getStates().keys()),
      updated: []
    }), i) {
      r && En.sendCursorData(o, r);
      const { onChange: u } = o;
      o.onChange = () => {
        u(), be.connected(o) && (En.sendCursorPosition(o), En.emitEvent("updateCursor"));
      };
    }
  }, o.disconnect = () => {
    o.awareness.off("change", a), En.resetEvent(), a({
      removed: Array.from(o.awareness.getStates().keys()),
      added: [],
      updated: []
    }), c();
  }, o;
}
function yd(s) {
  return s.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
}
function Cs(s) {
  const e = yd(s);
  return new RegExp("(".concat(e, ").+?(").concat(e, ")$"));
}
function ha(s) {
  const e = yd(s);
  return new RegExp("^(".concat(e, ")$"));
}
function ua(s) {
  return (e, t) => {
    $e.setNodes(e, { type: s }, {
      match: (n) => Q.isBlock(e, n),
      at: t
    });
  };
}
function T0(s) {
  return (e, t) => {
    const n = Q.rangeRef(e, t);
    $e.unwrapNodes(e, {
      at: t,
      match: (r) => Q.isInline(e, r),
      mode: "all",
      split: !0
    }), n.current && $e.insertNodes(
      e,
      { text: " " },
      {
        match: de.isText,
        at: st.end(n.current),
        select: !0
      }
    );
    const i = n.unref();
    i && $e.wrapNodes(e, { type: s, children: [] }, {
      at: i,
      split: !0
    });
  };
}
function xi(s) {
  return (e, t) => {
    $e.insertNodes(
      e,
      { text: " " },
      {
        match: de.isText,
        at: st.end(t),
        select: !0
      }
    ), $e.setNodes(
      e,
      { [s]: !0 },
      {
        match: de.isText,
        at: t,
        split: !0
      }
    );
  };
}
const L0 = [
  { trigger: ha("#"), apply: ua("heading-one") },
  { trigger: ha("##"), apply: ua("heading-two") },
  { trigger: ha(">"), apply: ua("block-quote") },
  { trigger: Cs("`"), apply: T0("inline-code") },
  { trigger: Cs("**"), apply: xi("bold") },
  { trigger: Cs("__"), apply: xi("bold") },
  { trigger: Cs("*"), apply: xi("italic") },
  { trigger: Cs("_"), apply: xi("italic") },
  { trigger: Cs("~~"), apply: xi("strikethrough") }
];
function qr(s, e, t) {
  if (e.offset >= t)
    return { offset: e.offset - t, path: e.path };
  const n = Q.previous(s, {
    at: e.path,
    match: de.isText
  });
  if (!n)
    return;
  const [i, r] = n;
  return qr(
    s,
    { offset: i.text.length, path: r },
    t - e.offset
  );
}
function D0(s) {
  const { deleteBackward: e, insertText: t, isInline: n, insertBreak: i } = s;
  return s.insertText = (r) => {
    const { selection: o } = s;
    if (r !== " " || !o || !st.isCollapsed(o))
      return t(r);
    const { anchor: a } = o, l = Q.above(s, {
      match: (d) => Q.isBlock(s, d)
    }), c = l ? l[1] : [], u = { anchor: a, focus: Q.start(s, c) }, f = Q.string(s, u);
    for (const { trigger: d, apply: g } of L0) {
      const p = d.exec(f);
      if (!p)
        continue;
      const [m, w, v] = p;
      Q.withoutNormalizing(s, () => {
        const y = a, b = v && qr(s, y, v.length), x = w && qr(s, y, m.length - w.length), C = qr(s, y, m.length);
        if (!y || !C)
          return;
        const A = Q.rangeRef(s, {
          anchor: C,
          focus: y
        });
        b && $e.delete(s, {
          at: { anchor: b, focus: y }
        }), x && $e.delete(s, {
          at: { anchor: C, focus: x }
        });
        const P = A.unref();
        P && g(s, P);
      });
      return;
    }
    t(r);
  }, s.insertBreak = () => {
    var a;
    const { selection: r } = s;
    if (fe.getSelectedNodeByType(s, "layout")) {
      i();
      return;
    }
    if (r) {
      const l = Q.above(s, {
        match: (d) => Q.isBlock(s, d)
      }), c = l ? l[1] : [], u = Q.end(s, c), f = Yr.equals(
        u,
        st.end(r)
      );
      if ($e.splitNodes(s, { always: !0 }), f) {
        $e.unwrapNodes(s, {
          match: (g) => Q.isInline(s, g),
          mode: "all"
        }), $e.setNodes(s, { type: "paragraph" }, {
          match: (g) => Q.isBlock(s, g)
        });
        const d = (a = Q.marks(s)) != null ? a : {};
        $e.unsetNodes(s, Object.keys(d), {
          match: de.isText
        });
      }
    }
  }, s.deleteBackward = (...r) => {
    if (fe.getSelectedNodeByType(s, "layout")) {
      e(...r);
      return;
    }
    const { selection: a } = s;
    if (a && st.isCollapsed(a)) {
      const l = Q.above(s, {
        match: (c) => Q.isBlock(s, c)
      });
      if (l) {
        const [c, u] = l, f = Q.start(s, u);
        if (!Q.isEditor(c) && Ri.isElement(c) && c.type !== "paragraph" && Yr.equals(a.anchor, f)) {
          const d = {
            type: "paragraph"
          };
          $e.setNodes(s, d);
          return;
        }
      }
      e(...r);
    }
  }, s.isInline = (r) => Ri.isElement(r) && r.type === "inline-code" || n(r), s;
}
function N0(s) {
  const { normalizeNode: e } = s;
  return s.normalizeNode = (t) => {
    const [n] = t;
    if (!Q.isEditor(n) || n.children.length > 0)
      return e(t);
    const i = {
      type: "paragraph",
      children: [{ text: "" }]
    };
    $e.insertNodes(s, i, { at: [0] });
  }, s;
}
class zs {
  /**
   * 获取主题
   * @returns
   */
  static getThemeVar() {
    const e = document.documentElement;
    return e ? getComputedStyle(e).getPropertyValue("--ibiz-color-primary") : null;
  }
  /**
   * 是否包含中文字符
   * @param inputString
   * @returns
   */
  static isChineseCharacter(e) {
    return /[\u4e00-\u9fa5]/.test(e);
  }
  /**
   * 判断字符串是否同时存在英文和中文
   * @param str
   * @returns
   */
  static hasChineseAndEnglish(e) {
    return /[\u4e00-\u9fa5]+.*[a-zA-Z]+|[a-zA-Z]+.*[\u4e00-\u9fa5]+/.test(e);
  }
  /**
   * 字符串转16进制颜色
   * @param text
   * @returns
   */
  static stringToHexColor(e) {
    if (!e)
      return "";
    let t = 0;
    for (let l = 0; l < e.length; l++)
      if (this.isChineseCharacter(e))
        t = e.charCodeAt(l) + ((t << 5) - t), t = t & t;
      else {
        const c = e.charCodeAt(l);
        t += c.toString(16);
      }
    const n = String(t).substring(0, 6);
    let i = parseInt(n.substring(0, 2), 16), r = parseInt(n.substring(2, 4), 16), o = parseInt(n.substring(4, 6), 16);
    i < 0 && (i = 10), r < 0 && (r = 10), o < 0 && (o = 10);
    const a = "#".concat(i.toString(16).padStart(2, "0")).concat(r.toString(16).padStart(2, "0")).concat(o.toString(16).padStart(2, "0"));
    return a === "#FFFFFF" && this.getThemeVar() || a;
  }
  /**
   * 缩写名字
   * @param text
   * @returns
   */
  static avatarName(e) {
    if (e && e.toString().length < 2)
      return e;
    if (e && e.toString().length >= 2) {
      if (this.hasChineseAndEnglish(e)) {
        const r = e.split("").find((a) => /[a-zA-Z]/.test(a)) || "", o = e.split("").find((a) => /[\u4E00-\u9FA5]/.test(a)) || "";
        return "".concat(r).concat(o).toLowerCase();
      }
      return /[a-zA-Z]/.test(e) ? e.split("").filter((r) => /[a-zA-Z]/.test(r)).slice(0, 2).join("").toUpperCase() : /[\u4E00-\u9FA5]/.test(e) ? e.split("").filter((r) => /[\u4E00-\u9FA5]/.test(r)).slice(-2).join("") : e.replaceAll(" ", "").substring(0, 2);
    }
  }
  /**
   * 解析emoji表情
   *
   * @param {string} value
   * @return {*}  {string}
   */
  static getEmojiCustomHtml(e) {
    return e.replaceAll(/{"emoji":"(.+?)"}/g, (t, n) => {
      const i = decodeURIComponent(atob(n));
      return '<span class="emoji-tag">'.concat(i, "</span>");
    }).replaceAll(
      /<span data-w-e-type="emoji" class='emoji'>(.+?)<\/span>/g,
      (t, n) => {
        const i = decodeURIComponent(atob(n));
        return "<span data-w-e-type=\"emoji\" class='emoji'>".concat(i, "</span>");
      }
    );
  }
}
function I0(s, e) {
  const t = Math.round(Math.min(Math.max(e, 0), 1) * 255);
  return s + t.toString(16).toUpperCase();
}
function j0(s) {
  return {
    color: zs.stringToHexColor(s),
    name: "".concat(s)
  };
}
const R0 = globalThis.Text, bd = (s) => {
  var e, t;
  return (t = (e = s == null ? void 0 : s.ownerDocument) == null ? void 0 : e.defaultView) != null ? t : null;
}, B0 = (s) => {
  const e = bd(s);
  return !!e && s instanceof e.Node;
}, Yc = (s) => B0(s) && s.nodeType === 1;
function Xc(s, e) {
  var l;
  const [t] = Q.node(s, e.path), n = s.toDOMNode(t);
  let i;
  Q.void(s, { at: e }) && (e = { path: e.path, offset: 0 });
  const r = "[data-slate-string], [data-slate-zero-width]", o = Array.from(n.querySelectorAll(r));
  let a = 0;
  for (let c = 0; c < o.length; c++) {
    const u = o[c], f = u.childNodes[0];
    if (f == null || f.textContent == null)
      continue;
    const { length: d } = f.textContent, g = u.getAttribute("data-slate-length"), p = g == null ? d : parseInt(g, 10), m = a + p, w = o[c + 1];
    if (e.offset === m && (w != null && w.hasAttribute("data-slate-mark-placeholder"))) {
      const v = w.childNodes[0];
      i = [
        v instanceof R0 ? v : w,
        (l = w.textContent) != null && l.startsWith("\uFEFF") ? 1 : 0
      ];
      break;
    }
    if (e.offset <= m) {
      const v = Math.min(d, Math.max(0, e.offset - a));
      i = [f, v];
      break;
    }
    a = m;
  }
  if (!i)
    throw new Error(
      "Cannot resolve a DOM point from Slate point: ".concat(JSON.stringify(e))
    );
  return i;
}
function $0(s, e) {
  const { anchor: t, focus: n } = e, i = st.isBackward(e), r = Xc(s, t), o = st.isCollapsed(e) ? r : Xc(s, n), l = s.editorWindow.document.createRange(), [c, u] = i ? o : r, [f, d] = i ? r : o, p = !!(Yc(c) ? c : c.parentElement).getAttribute("data-slate-zero-width"), w = !!(Yc(f) ? f : f.parentElement).getAttribute("data-slate-zero-width");
  return l.setStart(c, p ? 1 : u), l.setEnd(f, w ? 1 : d), l;
}
function F0(s, e) {
  try {
    return $0(s, e);
  } catch (t) {
    return null;
  }
}
const Zc = /* @__PURE__ */ new WeakMap();
function Kc(s, e) {
  if (!e.relativeSelection || !s)
    return null;
  let t = Zc.get(s.children);
  t || (t = /* @__PURE__ */ new WeakMap(), Zc.set(s.children, t));
  let n = t.get(e);
  if (n === void 0)
    try {
      n = wd(
        s.sharedRoot,
        s,
        e.relativeSelection
      ), t.set(e, n);
    } catch (i) {
      return null;
    }
  return n;
}
function z0(s, e, { yOffset: t, xOffset: n, shouldGenerateOverlay: i }) {
  const [r, o] = st.edges(e), a = F0(s, e);
  if (!a)
    return {
      caretPosition: null,
      selectionRects: []
    };
  const l = [], c = Q.nodes(s, {
    at: e,
    match: (d, g) => de.isText(d) && (!i || i(d, g))
  });
  let u = null;
  const f = st.isBackward(e);
  for (const [d, g] of c) {
    const p = s.toDOMNode(d), m = is.equals(g, r.path), w = is.equals(g, o.path);
    let v = null;
    if (m || w) {
      const b = document.createRange();
      b.selectNode(p), m && b.setStart(a.startContainer, a.startOffset), w && b.setEnd(a.endContainer, a.endOffset), v = b.getClientRects();
    } else
      v = p.getClientRects();
    const y = f ? m : w;
    for (let b = 0; b < v.length; b++) {
      const x = v.item(b);
      if (!x)
        continue;
      const C = y && (f ? b === 0 : b === v.length - 1), A = x.top - t, P = x.left - n;
      C && (u = {
        height: "".concat(x.height, "px"),
        top: "".concat(A, "px"),
        left: "".concat(P + (f || st.isCollapsed(e) ? 0 : x.width), "px")
      }), l.push({
        width: "".concat(x.width, "px"),
        height: "".concat(x.height, "px"),
        top: "".concat(A, "px"),
        left: "".concat(P, "px")
      });
    }
  }
  return {
    selectionRects: l,
    caretPosition: u
  };
}
const V0 = /* @__PURE__ */ me({
  name: "CursorCaret",
  props: {
    data: {
      type: Object,
      required: !0
    },
    caretPosition: Object
  },
  setup(s) {
    const e = we("cursor-caret"), t = Ge(() => ({
      ...s.caretPosition,
      background: s.data.color
    })), n = Ge(() => ({
      transform: "translateY(-100%)",
      background: s.data.color
    }));
    return {
      ns: e,
      caretStyle: t,
      labelStyle: n
    };
  },
  render() {
    return M("div", {
      style: this.caretStyle,
      class: this.ns.b()
    }, [M("div", {
      class: this.ns.e("text"),
      style: this.labelStyle
    }, [this.data.name])]);
  }
});
const H0 = /* @__PURE__ */ me({
  name: "CursorSelection",
  props: {
    data: Object,
    selectionRects: Array,
    caretPosition: Object
  },
  setup(s) {
    const e = we("cursor-selection"), t = Ge(() => ({
      backgroundColor: I0(s.data.color, 0.5)
    }));
    return {
      ns: e,
      selectionStyle: t
    };
  },
  render() {
    var s;
    return this.data ? M(Hg, null, [(s = this.selectionRects) == null ? void 0 : s.map((e, t) => M("div", {
      style: {
        ...this.selectionStyle,
        ...e
      },
      class: this.ns.b(),
      key: t
    }, null)), this.caretPosition && M(V0, {
      caretPosition: this.caretPosition,
      data: this.data
    }, null)]) : null;
  }
});
function U0(s, e) {
  let t = null;
  hn(() => {
    s.value && (t = new ResizeObserver(() => {
      e();
    }), t.observe(s.value));
  }), or(() => {
    t && s.value && t.unobserve(s.value);
  });
}
const Qc = Object.freeze([]);
function q0(s) {
  var u;
  const { slateYjs: e, containerRef: t, shouldGenerateOverlay: n } = s, i = "refreshOnResize" in s && (u = s.refreshOnResize) != null ? u : !0, r = /* @__PURE__ */ new Map(), o = T({}), a = () => {
    var w, v, y;
    if (t && !t.value || !e.yjsEditor)
      return;
    const f = (w = t == null ? void 0 : t.value) == null ? void 0 : w.getBoundingClientRect(), d = (v = f == null ? void 0 : f.x) != null ? v : 0, g = (y = f == null ? void 0 : f.y) != null ? y : 0;
    let p = Object.keys(o.value).length !== Object.keys(e.cursorStates).length;
    const m = Object.fromEntries(
      Object.entries(e.cursorStates).map(([b, x]) => {
        const C = x.relativeSelection && Kc(e.yjsEditor, x);
        if (!C)
          return [b, Qc];
        const A = r.get(C);
        if (A)
          return [b, A];
        const P = z0(
          e.yjsEditor,
          C,
          {
            xOffset: d,
            yOffset: g,
            shouldGenerateOverlay: n
          }
        );
        return p = !0, r.set(C, P), [b, P];
      })
    );
    p && (o.value = m);
  }, l = () => {
    r.clear(), a();
  };
  return i && U0(t, l), En.onEvent("updateCursor", wl(a, 0)), Ne(
    () => e.cursorStates,
    () => a(),
    { deep: !0, immediate: !0 }
  ), {
    overlayData: Ge(() => Object.entries(e.cursorStates).map(([f, d]) => {
      var m, w;
      const g = d.relativeSelection && Kc(e.yjsEditor, d), p = o.value[f];
      return {
        ...d,
        range: g,
        caretPosition: (m = p == null ? void 0 : p.caretPosition) != null ? m : null,
        selectionRects: (w = p == null ? void 0 : p.selectionRects) != null ? w : Qc
      };
    })),
    refresh: l
  };
}
const G0 = /* @__PURE__ */ me({
  name: "CursorOverlay",
  props: {
    slateYjs: {
      type: Object,
      required: !0
    }
  },
  setup(s) {
    const e = we("cursor-overlay"), t = T(), {
      overlayData: n
    } = q0({
      slateYjs: s.slateYjs,
      containerRef: t
    });
    return {
      ns: e,
      overlayData: n,
      containerRef: t
    };
  },
  render() {
    var s, e;
    return M("div", {
      class: this.ns.b(),
      ref: "containerRef"
    }, [(e = (s = this.$slots).default) == null ? void 0 : e.call(s), this.overlayData.map((t) => M(H0, Ug({
      key: t.clientId
    }, t), null))]);
  }
});
class W0 {
  /**
   * Creates an instance of CollaborateService.
   * @author tony001
   * @date 2024-08-06 11:08:59
   * @param {string} id
   * @param {string} mqttTopic
   * @param {string} token
   * @param {string} appId
   */
  constructor(e, t, n, i) {
    /**
     * 发送消息
     *
     * @author tony001
     * @date 2024-08-06 11:08:00
     * @protected
     */
    E(this, "collaborateUrl", "/portal/collaborate");
    /**
     * 连接状态
     *
     * @author tony001
     * @date 2024-08-06 11:08:20
     * @protected
     * @type {number}
     */
    E(this, "readyState");
    /**
     * 事件对象
     *
     * @author tony001
     * @date 2024-08-05 19:08:09
     */
    E(this, "evt", new Zh());
    /**
     * mqtt 连接实例
     *
     * @author tony001
     * @date 2024-08-05 19:08:52
     * @type {MqttClient}
     */
    E(this, "client");
    /**
     * 连接选项
     *
     * @author tony001
     * @date 2024-08-05 19:08:06
     * @protected
     * @type {IClientOptions}
     */
    E(this, "options", {
      // 超时时间
      connectTimeout: 6e3,
      // 认证信息
      clientId: rt(),
      username: "",
      password: "",
      // 心跳时间
      keepalive: 60,
      clean: !0
    });
    this.id = e, this.mqttTopic = t, this.token = n, this.appId = i, this.options.username = t, this.options.password = n, this.readyState = 0;
  }
  /**
   * 发送消息
   *
   * @author tony001
   * @date 2024-08-06 11:08:40
   * @param {(string | ArrayBufferLike | Blob | ArrayBufferView)} data
   */
  send(e) {
    ibiz.net.post("".concat(this.collaborateUrl, "/ROOM/").concat(this.id), { data: e });
  }
  /**
   * mqtt 连接
   *
   * @author tony001
   * @date 2024-08-05 19:08:17
   * @return {*}  {Promise<void>}
   */
  async connect() {
    const e = await import("./mqtt.min-4690c45a.js").then((i) => i.m), t = e.default ? e.default : e, { location: n } = window;
    this.client = t.connect(
      "ws://".concat(n.host).concat(ibiz.env.baseUrl, "/").concat(this.appId).concat(ibiz.env.mqttUrl),
      this.options
    ), this.client.on("connect", () => {
      this.client.subscribe(this.mqttTopic), this.readyState = 1, this.evt.emit("connect"), ibiz.log.debug("collaborate connect");
    }), this.client.on("error", (i) => {
      this.readyState = 3, this.evt.emit("error", i), ibiz.log.debug("collaborate error");
    }), this.client.on("message", (i, r) => {
      const o = JSON.parse(r.toString());
      o && o.data && o.data.data && o.data.data.data && this.evt.emit(
        "message",
        new Uint8Array(Object.values(o.data.data.data))
      ), ibiz.log.debug("collaborate message");
    }), this.client.on("reconnect", () => {
      this.readyState = 0, this.evt.emit("reconnect");
    }), this.client.on("close", () => {
      this.readyState = 3, this.evt.emit("close"), ibiz.log.debug("collaborate close");
    });
  }
  /**
   * 结束 mqtt 连接
   *
   * @author tony001
   * @date 2024-08-05 19:08:02
   */
  close() {
    var e;
    (e = this.client) == null || e.end(), this.evt.reset();
  }
}
const Ts = () => /* @__PURE__ */ new Map(), vd = (s, e, t) => {
  let n = s.get(e);
  return n === void 0 && s.set(e, n = t()), n;
}, J0 = String.fromCharCode, Y0 = (s) => s.toLowerCase(), X0 = /^\s*/g, Z0 = (s) => s.replace(X0, ""), K0 = /([A-Z])/g, eh = (s, e) => Z0(s.replace(K0, (t) => "".concat(e).concat(Y0(t)))), Q0 = (s) => {
  const e = unescape(encodeURIComponent(s)), t = e.length, n = new Uint8Array(t);
  for (let i = 0; i < t; i++)
    n[i] = /** @type {number} */
    e.codePointAt(i);
  return n;
}, Io = (
  /** @type {TextEncoder} */
  typeof TextEncoder < "u" ? new TextEncoder() : null
), ew = (s) => Io.encode(s), tw = Io ? ew : Q0;
let Pi = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8", { fatal: !0, ignoreBOM: !0 });
Pi && Pi.decode(new Uint8Array()).length === 1 && (Pi = null);
const th = (s) => s === void 0 ? null : s;
class nw {
  constructor() {
    this.map = /* @__PURE__ */ new Map();
  }
  /**
   * @param {string} key
   * @param {any} newValue
   */
  setItem(e, t) {
    this.map.set(e, t);
  }
  /**
   * @param {string} key
   */
  getItem(e) {
    return this.map.get(e);
  }
}
let xd = new nw(), Cd = !0;
try {
  typeof localStorage < "u" && (xd = localStorage, Cd = !1);
} catch (s) {
}
const Ed = xd, sw = (s) => Cd || addEventListener(
  "storage",
  /** @type {any} */
  s
), Yi = typeof process < "u" && process.release && /node|io\.js/.test(process.release.name), Sd = typeof window < "u" && !Yi;
let $t;
const iw = () => {
  if ($t === void 0)
    if (Yi) {
      $t = Ts();
      const s = process.argv;
      let e = null;
      for (let t = 0; t < s.length; t++) {
        const n = s[t];
        n[0] === "-" ? (e !== null && $t.set(e, ""), e = n) : e !== null && ($t.set(e, n), e = null);
      }
      e !== null && $t.set(e, "");
    } else
      typeof location == "object" ? ($t = Ts(), (location.search || "?").slice(1).split("&").forEach((s) => {
        if (s.length !== 0) {
          const [e, t] = s.split("=");
          $t.set("--".concat(eh(e, "-")), t), $t.set("-".concat(eh(e, "-")), t);
        }
      })) : $t = Ts();
  return $t;
}, rw = (s) => iw().has(s), ow = (s) => th(Yi ? process.env[s.toUpperCase()] : Ed.getItem(s)), aw = (s) => rw("--" + s) || ow(s) !== null;
aw("production");
const Ad = Math.floor, Md = (s, e) => s < e ? s : e, lw = (s, e) => s > e ? s : e, cw = Math.pow, kd = 128, Gr = 127, hw = Number.MAX_SAFE_INTEGER;
class uw {
  constructor() {
    this.cpos = 0, this.cbuf = new Uint8Array(100), this.bufs = [];
  }
}
const wt = () => new uw(), Rl = (s) => {
  let e = s.cpos;
  for (let t = 0; t < s.bufs.length; t++)
    e += s.bufs[t].length;
  return e;
}, ct = (s) => {
  const e = new Uint8Array(Rl(s));
  let t = 0;
  for (let n = 0; n < s.bufs.length; n++) {
    const i = s.bufs[n];
    e.set(i, t), t += i.length;
  }
  return e.set(Od(s.cbuf.buffer, 0, s.cpos), t), e;
}, io = (s, e) => {
  const t = s.cbuf.length;
  s.cpos === t && (s.bufs.push(s.cbuf), s.cbuf = new Uint8Array(t * 2), s.cpos = 0), s.cbuf[s.cpos++] = e;
}, Ae = (s, e) => {
  for (; e > Gr; )
    io(s, kd | Gr & e), e = Ad(e / 128);
  io(s, Gr & e);
}, Wa = new Uint8Array(3e4), dw = Wa.length / 3, fw = (s, e) => {
  if (e.length < dw) {
    const t = Io.encodeInto(e, Wa).written || 0;
    Ae(s, t);
    for (let n = 0; n < t; n++)
      io(s, Wa[n]);
  } else
    rn(s, tw(e));
}, gw = (s, e) => {
  const t = unescape(encodeURIComponent(e)), n = t.length;
  Ae(s, n);
  for (let i = 0; i < n; i++)
    io(
      s,
      /** @type {number} */
      t.codePointAt(i)
    );
}, pw = Io ? fw : gw, mw = (s, e) => {
  const t = s.cbuf.length, n = s.cpos, i = Md(t - n, e.length), r = e.length - i;
  s.cbuf.set(e.subarray(0, i), n), s.cpos += i, r > 0 && (s.bufs.push(s.cbuf), s.cbuf = new Uint8Array(lw(t * 2, r)), s.cbuf.set(e.subarray(i)), s.cpos = r);
}, rn = (s, e) => {
  Ae(s, e.byteLength), mw(s, e);
};
class ww {
  /**
   * @param {Uint8Array} uint8Array Binary data to decode
   */
  constructor(e) {
    this.arr = e, this.pos = 0;
  }
}
const Pd = (s) => new ww(s), yw = (s, e) => {
  const t = Od(s.arr.buffer, s.pos + s.arr.byteOffset, e);
  return s.pos += e, t;
}, jo = (s) => yw(s, Mn(s)), nh = (s) => s.arr[s.pos++], Mn = (s) => {
  let e = 0, t = 1;
  for (; ; ) {
    const n = s.arr[s.pos++];
    if (e = e + (n & Gr) * t, t *= 128, n < kd)
      return e;
    if (e > hw)
      throw new Error("Integer out of range!");
  }
}, bw = (s) => {
  let e = Mn(s);
  if (e === 0)
    return "";
  {
    let t = String.fromCodePoint(nh(s));
    if (--e < 100)
      for (; e--; )
        t += String.fromCodePoint(nh(s));
    else
      for (; e > 0; ) {
        const n = e < 1e4 ? e : 1e4, i = s.arr.subarray(s.pos, s.pos + n);
        s.pos += n, t += String.fromCodePoint.apply(
          null,
          /** @type {any} */
          i
        ), e -= n;
      }
    return decodeURIComponent(escape(t));
  }
}, vw = (s) => (
  /** @type any */
  Pi.decode(jo(s))
), _d = Pi ? vw : bw, xw = (s) => new Uint8Array(s), Od = (s, e, t) => new Uint8Array(s, e, t), Cw = (s) => new Uint8Array(s), Ew = (s) => {
  let e = "";
  for (let t = 0; t < s.byteLength; t++)
    e += J0(s[t]);
  return btoa(e);
}, Sw = (s) => Buffer.from(s.buffer, s.byteOffset, s.byteLength).toString("base64"), Aw = (s) => {
  const e = atob(s), t = xw(e.length);
  for (let n = 0; n < e.length; n++)
    t[n] = e.charCodeAt(n);
  return t;
}, Mw = (s) => {
  const e = Buffer.from(s, "base64");
  return new Uint8Array(e.buffer, e.byteOffset, e.byteLength);
}, kw = Sd ? Ew : Sw, Pw = Sd ? Aw : Mw, _w = /* @__PURE__ */ new Map();
class Ow {
  /**
   * @param {string} room
   */
  constructor(e) {
    this.room = e, this.onmessage = null, sw((t) => t.key === e && this.onmessage !== null && this.onmessage({ data: Pw(t.newValue || "") }));
  }
  /**
   * @param {ArrayBuffer} buf
   */
  postMessage(e) {
    Ed.setItem(this.room, kw(Cw(e)));
  }
}
const Tw = typeof BroadcastChannel > "u" ? Ow : BroadcastChannel, Bl = (s) => vd(_w, s, () => {
  const e = /* @__PURE__ */ new Set(), t = new Tw(s);
  return t.onmessage = (n) => e.forEach((i) => i(n.data, "broadcastchannel")), {
    bc: t,
    subs: e
  };
}), Lw = (s, e) => Bl(s).subs.add(e), Dw = (s, e) => Bl(s).subs.delete(e), As = (s, e, t = null) => {
  const n = Bl(s);
  n.bc.postMessage(e), n.subs.forEach((i) => i(e, t));
}, hs = Date.now, Td = 0, $l = 1, Ld = 2, Ja = (s, e) => {
  Ae(s, Td);
  const t = Um(e);
  rn(s, t);
}, Dd = (s, e, t) => {
  Ae(s, $l), rn(s, Fm(e, t));
}, Nw = (s, e, t) => Dd(e, t, jo(s)), Nd = (s, e, t) => {
  try {
    Rm(e, jo(s), t);
  } catch (n) {
    console.error("Caught error while handling a Yjs update", n);
  }
}, Iw = (s, e) => {
  Ae(s, Ld), rn(s, e);
}, jw = Nd, Rw = (s, e, t, n) => {
  const i = Mn(s);
  switch (i) {
    case Td:
      Nw(s, e, t);
      break;
    case $l:
      Nd(s, t, n);
      break;
    case Ld:
      jw(s, t, n);
      break;
    default:
      throw new Error("Unknown message type");
  }
  return i;
}, Bw = 0, $w = (s, e, t) => {
  switch (Mn(s)) {
    case Bw:
      t(e, _d(s));
  }
}, Fw = () => /* @__PURE__ */ new Set(), zw = Array.from;
class Id {
  constructor() {
    this._observers = Ts();
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  on(e, t) {
    vd(this._observers, e, Fw).add(t);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  once(e, t) {
    const n = (...i) => {
      this.off(e, n), t(...i);
    };
    this.on(e, n);
  }
  /**
   * @param {N} name
   * @param {function} f
   */
  off(e, t) {
    const n = this._observers.get(e);
    n !== void 0 && (n.delete(t), n.size === 0 && this._observers.delete(e));
  }
  /**
   * Emit a named event. All registered event listeners that listen to the
   * specified name will receive the event.
   *
   * @todo This should catch exceptions
   *
   * @param {N} name The event name.
   * @param {Array<any>} args The arguments that are applied to the event listener.
   */
  emit(e, t) {
    return zw((this._observers.get(e) || Ts()).values()).forEach((n) => n(...t));
  }
  destroy() {
    this._observers = Ts();
  }
}
const Vw = Object.keys, Hw = (s, e) => {
  const t = [];
  for (const n in s)
    t.push(e(s[n], n));
  return t;
}, sh = (s) => Vw(s).length, Uw = (s, e) => Object.prototype.hasOwnProperty.call(s, e), qw = (s, e) => s === e, _i = (s, e) => {
  if (s == null || e == null)
    return qw(s, e);
  if (s.constructor !== e.constructor)
    return !1;
  if (s === e)
    return !0;
  switch (s.constructor) {
    case ArrayBuffer:
      s = new Uint8Array(s), e = new Uint8Array(e);
    case Uint8Array: {
      if (s.byteLength !== e.byteLength)
        return !1;
      for (let t = 0; t < s.length; t++)
        if (s[t] !== e[t])
          return !1;
      break;
    }
    case Set: {
      if (s.size !== e.size)
        return !1;
      for (const t of s)
        if (!e.has(t))
          return !1;
      break;
    }
    case Map: {
      if (s.size !== e.size)
        return !1;
      for (const t of s.keys())
        if (!e.has(t) || !_i(s.get(t), e.get(t)))
          return !1;
      break;
    }
    case Object:
      if (sh(s) !== sh(e))
        return !1;
      for (const t in s)
        if (!Uw(s, t) || !_i(s[t], e[t]))
          return !1;
      break;
    case Array:
      if (s.length !== e.length)
        return !1;
      for (let t = 0; t < s.length; t++)
        if (!_i(s[t], e[t]))
          return !1;
      break;
    default:
      return !1;
  }
  return !0;
}, da = 3e4;
class Gw extends Id {
  /**
   * @param {Y.Doc} doc
   */
  constructor(e) {
    super(), this.doc = e, this.clientID = e.clientID, this.states = /* @__PURE__ */ new Map(), this.meta = /* @__PURE__ */ new Map(), this._checkInterval = /** @type {any} */
    setInterval(() => {
      const t = hs();
      this.getLocalState() !== null && da / 2 <= t - /** @type {{lastUpdated:number}} */
      this.meta.get(this.clientID).lastUpdated && this.setLocalState(this.getLocalState());
      const n = [];
      this.meta.forEach((i, r) => {
        r !== this.clientID && da <= t - i.lastUpdated && this.states.has(r) && n.push(r);
      }), n.length > 0 && Fl(this, n, "timeout");
    }, Ad(da / 10)), e.on("destroy", () => {
      this.destroy();
    }), this.setLocalState({});
  }
  destroy() {
    this.emit("destroy", [this]), this.setLocalState(null), super.destroy(), clearInterval(this._checkInterval);
  }
  /**
   * @return {Object<string,any>|null}
   */
  getLocalState() {
    return this.states.get(this.clientID) || null;
  }
  /**
   * @param {Object<string,any>|null} state
   */
  setLocalState(e) {
    const t = this.clientID, n = this.meta.get(t), i = n === void 0 ? 0 : n.clock + 1, r = this.states.get(t);
    e === null ? this.states.delete(t) : this.states.set(t, e), this.meta.set(t, {
      clock: i,
      lastUpdated: hs()
    });
    const o = [], a = [], l = [], c = [];
    e === null ? c.push(t) : r == null ? e != null && o.push(t) : (a.push(t), _i(r, e) || l.push(t)), (o.length > 0 || l.length > 0 || c.length > 0) && this.emit("change", [{ added: o, updated: l, removed: c }, "local"]), this.emit("update", [{ added: o, updated: a, removed: c }, "local"]);
  }
  /**
   * @param {string} field
   * @param {any} value
   */
  setLocalStateField(e, t) {
    const n = this.getLocalState();
    n !== null && this.setLocalState({
      ...n,
      [e]: t
    });
  }
  /**
   * @return {Map<number,Object<string,any>>}
   */
  getStates() {
    return this.states;
  }
}
const Fl = (s, e, t) => {
  const n = [];
  for (let i = 0; i < e.length; i++) {
    const r = e[i];
    if (s.states.has(r)) {
      if (s.states.delete(r), r === s.clientID) {
        const o = (
          /** @type {MetaClientState} */
          s.meta.get(r)
        );
        s.meta.set(r, {
          clock: o.clock + 1,
          lastUpdated: hs()
        });
      }
      n.push(r);
    }
  }
  n.length > 0 && (s.emit("change", [{ added: [], updated: [], removed: n }, t]), s.emit("update", [{ added: [], updated: [], removed: n }, t]));
}, Oi = (s, e, t = s.states) => {
  const n = e.length, i = wt();
  Ae(i, n);
  for (let r = 0; r < n; r++) {
    const o = e[r], a = t.get(o) || null, l = (
      /** @type {MetaClientState} */
      s.meta.get(o).clock
    );
    Ae(i, o), Ae(i, l), pw(i, JSON.stringify(a));
  }
  return ct(i);
}, Ww = (s, e, t) => {
  const n = Pd(e), i = hs(), r = [], o = [], a = [], l = [], c = Mn(n);
  for (let u = 0; u < c; u++) {
    const f = Mn(n);
    let d = Mn(n);
    const g = JSON.parse(_d(n)), p = s.meta.get(f), m = s.states.get(f), w = p === void 0 ? 0 : p.clock;
    (w < d || w === d && g === null && s.states.has(f)) && (g === null ? f === s.clientID && s.getLocalState() != null ? d++ : s.states.delete(f) : s.states.set(f, g), s.meta.set(f, {
      clock: d,
      lastUpdated: i
    }), p === void 0 && g !== null ? r.push(f) : p !== void 0 && g === null ? l.push(f) : g !== null && (_i(g, m) || a.push(f), o.push(f)));
  }
  (r.length > 0 || a.length > 0 || l.length > 0) && s.emit("change", [{
    added: r,
    updated: a,
    removed: l
  }, t]), (r.length > 0 || o.length > 0 || l.length > 0) && s.emit("update", [{
    added: r,
    updated: o,
    removed: l
  }, t]);
}, Jw = (s) => Hw(s, (e, t) => "".concat(encodeURIComponent(t), "=").concat(encodeURIComponent(e))).join("&"), Xn = 0, jd = 3, Ls = 1, Yw = 2, fr = [];
fr[Xn] = (s, e, t, n, i) => {
  Ae(s, Xn);
  const r = Rw(
    e,
    s,
    t.doc,
    t
  );
  n && r === $l && !t.synced && (t.synced = !0);
};
fr[jd] = (s, e, t, n, i) => {
  Ae(s, Ls), rn(
    s,
    Oi(
      t.awareness,
      Array.from(t.awareness.getStates().keys())
    )
  );
};
fr[Ls] = (s, e, t, n, i) => {
  Ww(
    t.awareness,
    jo(e),
    t
  );
};
fr[Yw] = (s, e, t, n, i) => {
  $w(
    e,
    t.doc,
    (r, o) => Xw(t, o)
  );
};
const ih = 3e4, Xw = (s, e) => console.warn("Permission denied to access ".concat(s.url, ".\n").concat(e)), Rd = (s, e, t) => {
  const n = Pd(e), i = wt(), r = Mn(n), o = s.messageHandlers[r];
  return /** @type {any} */ o ? o(i, n, s, t, r) : console.error("Unable to compute message"), i;
}, Bd = (s) => {
  if (s.shouldConnect && s.ws === null) {
    const e = s._WS;
    s.ws = e, s.wsconnecting = !0, s.wsconnected = !1, s.synced = !1, e.evt.on("message", (t) => {
      s.wsLastMessageReceived = hs();
      const n = Rd(s, t, !0);
      Rl(n) > 1 && e.send(ct(n));
    }), e.evt.on("error", (t) => {
      s.emit("connection-error", [t, s]);
    }), e.evt.on("close", (t) => {
      s.emit("connection-close", [t, s]), s.ws = null, s.wsconnecting = !1, s.wsconnected ? (s.wsconnected = !1, s.synced = !1, Fl(
        s.awareness,
        Array.from(s.awareness.getStates().keys()).filter(
          (n) => n !== s.doc.clientID
        ),
        s
      ), s.emit("status", [
        {
          status: "disconnected"
        }
      ])) : s.wsUnsuccessfulReconnects++, setTimeout(
        Bd,
        Md(
          cw(2, s.wsUnsuccessfulReconnects) * 100,
          s.maxBackoffTime
        ),
        s
      );
    }), e.evt.on("connect", () => {
      s.wsLastMessageReceived = hs(), s.wsconnecting = !1, s.wsconnected = !0, s.wsUnsuccessfulReconnects = 0, s.emit("status", [
        {
          status: "connected"
        }
      ]);
      const t = wt();
      if (Ae(t, Xn), Ja(t, s.doc), e.send(ct(t)), s.awareness.getLocalState() !== null) {
        const n = wt();
        Ae(n, Ls), rn(
          n,
          Oi(s.awareness, [
            s.doc.clientID
          ])
        ), e.send(ct(n));
      }
    }), s.emit("status", [
      {
        status: "connecting"
      }
    ]);
  }
}, fa = (s, e) => {
  const t = s.ws;
  s.wsconnected && t && t.readyState === 1 && t.send(e), s.bcconnected && As(s.bcChannel, e, s);
};
class Zw extends Id {
  /**
   * @param {string} serverUrl
   * @param {string} roomname
   * @param {Y.Doc} doc
   * @param {object} opts
   * @param {boolean} [opts.connect]
   * @param {awarenessProtocol.Awareness} [opts.awareness]
   * @param {Object<string,string>} [opts.params] specify url parameters
   * @param {Array<string>} [opts.protocols] specify websocket protocols
   * @param {typeof Object} [opts.WebSocketPolyfill] Optionall provide a Object polyfill
   * @param {number} [opts.resyncInterval] Request server state every `resyncInterval` milliseconds
   * @param {number} [opts.maxBackoffTime] Maximum amount of time to wait before trying to reconnect (we try to reconnect using exponential backoff)
   * @param {boolean} [opts.disableBc] Disable cross-tab BroadcastChannel communication
   */
  constructor(e, t, n, {
    connect: i = !0,
    awareness: r = new Gw(n),
    params: o = {},
    protocols: a = [],
    WebSocketPolyfill: l,
    resyncInterval: c = -1,
    maxBackoffTime: u = 2500,
    disableBc: f = !1
  } = {}) {
    for (super(); e[e.length - 1] === "/"; )
      e = e.slice(0, e.length - 1);
    this.serverUrl = e, this.bcChannel = e + "/" + t, this.maxBackoffTime = u, this.params = o, this.protocols = a, this.roomname = t, this.doc = n, this._WS = l, this.awareness = r, this.wsconnected = !1, this.wsconnecting = !1, this.bcconnected = !1, this.disableBc = f, this.wsUnsuccessfulReconnects = 0, this.messageHandlers = fr.slice(), this._synced = !1, this.ws = null, this.wsLastMessageReceived = 0, this.shouldConnect = i, this._resyncInterval = 0, c > 0 && (this._resyncInterval = /** @type {any} */
    setInterval(() => {
      if (this.ws && this.ws.readyState === 1) {
        const d = wt();
        Ae(d, Xn), Ja(d, n), this.ws.send(ct(d));
      }
    }, c)), this._bcSubscriber = (d, g) => {
      if (g !== this) {
        const p = Rd(this, new Uint8Array(d), !1);
        Rl(p) > 1 && As(this.bcChannel, ct(p), this);
      }
    }, this._updateHandler = (d, g) => {
      if (g !== this) {
        const p = wt();
        Ae(p, Xn), Iw(p, d), fa(this, ct(p));
      }
    }, this.doc.on("update", this._updateHandler), this._awarenessUpdateHandler = ({ added: d, updated: g, removed: p }, m) => {
      const w = d.concat(g).concat(p), v = wt();
      Ae(v, Ls), rn(
        v,
        Oi(r, w)
      ), fa(this, ct(v));
    }, this._exitHandler = () => {
      Fl(
        this.awareness,
        [n.clientID],
        "app closed"
      );
    }, Yi && typeof process < "u" && process.on("exit", this._exitHandler), r.on("update", this._awarenessUpdateHandler), this._checkInterval = /** @type {any} */
    setInterval(() => {
      this.wsconnected && ih < hs() - this.wsLastMessageReceived && this.ws.close();
    }, ih / 10), i && this.connect();
  }
  get url() {
    const e = Jw(this.params);
    return this.serverUrl + "/" + this.roomname + (e.length === 0 ? "" : "?" + e);
  }
  /**
   * @type {boolean}
   */
  get synced() {
    return this._synced;
  }
  set synced(e) {
    this._synced !== e && (this._synced = e, this.emit("synced", [e]), this.emit("sync", [e]));
  }
  destroy() {
    this._resyncInterval !== 0 && clearInterval(this._resyncInterval), clearInterval(this._checkInterval), this.disconnect(), Yi && typeof process < "u" && process.off("exit", this._exitHandler), this.awareness.off("update", this._awarenessUpdateHandler), this.doc.off("update", this._updateHandler), super.destroy();
  }
  connectBc() {
    if (this.disableBc)
      return;
    this.bcconnected || (Lw(this.bcChannel, this._bcSubscriber), this.bcconnected = !0);
    const e = wt();
    Ae(e, Xn), Ja(e, this.doc), As(this.bcChannel, ct(e), this);
    const t = wt();
    Ae(t, Xn), Dd(t, this.doc), As(this.bcChannel, ct(t), this);
    const n = wt();
    Ae(n, jd), As(
      this.bcChannel,
      ct(n),
      this
    );
    const i = wt();
    Ae(i, Ls), rn(
      i,
      Oi(this.awareness, [
        this.doc.clientID
      ])
    ), As(
      this.bcChannel,
      ct(i),
      this
    );
  }
  disconnectBc() {
    const e = wt();
    Ae(e, Ls), rn(
      e,
      Oi(
        this.awareness,
        [this.doc.clientID],
        /* @__PURE__ */ new Map()
      )
    ), fa(this, ct(e)), this.bcconnected && (Dw(this.bcChannel, this._bcSubscriber), this.bcconnected = !1);
  }
  disconnect() {
    this.shouldConnect = !1, this.disconnectBc(), this.ws !== null && this.ws.close();
  }
  connect() {
    this.shouldConnect = !0, !this.wsconnected && this.ws === null && (Bd(this), this.connectBc());
  }
}
class Kw {
  /**
   * Creates an instance of CollaborateRoom.
   * @author tony001
   * @date 2024-08-05 18:08:36
   * @param {string} id
   * @param {IData} doc
   */
  constructor(e, t, n, i) {
    /**
     * 唯一标识
     *
     * @author tony001
     * @date 2024-08-05 18:08:19
     * @type {string}
     */
    E(this, "id");
    /**
     * 房间名称
     *
     * @author tony001
     * @date 2024-08-06 10:08:25
     * @type {string}
     */
    E(this, "name");
    /**
     * 文档实例
     *
     * @author tony001
     * @date 2024-08-05 18:08:59
     * @type {Y.Doc}
     */
    E(this, "doc");
    /**
     * 上下文
     *
     * @author tony001
     * @date 2024-08-06 10:08:29
     * @type {IContext}
     */
    E(this, "context");
    /**
     * 视图参数
     *
     * @author tony001
     * @date 2024-08-06 10:08:34
     * @type {IParams}
     */
    E(this, "params");
    /**
     * 连接提供者
     *
     * @author tony001
     * @date 2024-08-05 18:08:04
     * @type {*}
     */
    E(this, "connectionProvider");
    this.context = e, this.params = t, this.id = n, this.doc = i;
    const r = ibiz.appData.mqtttopic.split("/");
    this.name = "/".concat(r[1], "/collaborate/ROOM/").concat(this.id);
  }
  /**
   * 创建当前实例
   *
   * @author tony001
   * @date 2024-08-06 10:08:20
   * @return {*}  {Promise<void>}
   */
  async created() {
    const t = ibiz.hub.getApp(this.context.srfappid).model.appId || ibiz.env.appId, n = "ws://".concat(window.location.host).concat(ibiz.env.baseUrl, "/").concat(t).concat(ibiz.env.mqttUrl), i = new W0(
      this.id,
      this.name,
      tp(),
      t
    );
    await i.connect(), this.connectionProvider = new Zw(
      n,
      this.name,
      this.doc,
      { WebSocketPolyfill: i, resyncInterval: 5e3 }
    );
  }
  /**
   * 销毁当前实例
   *
   * @author tony001
   * @date 2024-08-06 10:08:08
   * @return {*}  {Promise<void>}
   */
  async destroy() {
    var e;
    (e = this.connectionProvider) == null || e.destroy();
  }
}
class Qw {
  constructor() {
    /**
     * 协同房间缓存实例
     *
     * @author tony001
     * @date 2024-08-06 14:08:38
     * @protected
     * @type {Map<string, Map<string, CollaborateRoom>>}
     */
    E(this, "collaborateMap", /* @__PURE__ */ new Map());
  }
  /**
   * 获取应用标识
   *
   * @author tony001
   * @date 2024-08-06 14:08:27
   * @protected
   * @param {IContext} context
   * @return {*}  {string}
   */
  getAppId(e) {
    return ibiz.hub.getApp(e.srfappid).model.appId || ibiz.env.appId;
  }
  /**
   * 创建协同房间
   *
   * @author tony001
   * @date 2024-08-06 14:08:37
   * @param {IContext} context 上下文
   * @param {IParams} params 视图参数
   * @param {string} id 业务数据主键
   * @param {IData} doc 文档实例对象
   * @return {*}  {Promise<CollaborateRoom>}
   */
  async create(e, t, n, i) {
    const r = new Kw(e, t, n, i);
    await r.created();
    const o = this.getAppId(e);
    return this.collaborateMap.has(o) || this.collaborateMap.set(o, /* @__PURE__ */ new Map()), this.collaborateMap.get(o).set(r.id, r), r;
  }
  /**
   * 获取协同房间
   *
   * @author tony001
   * @date 2024-08-06 10:08:17
   * @param {IContext} context 上下文
   * @param {IParams} params 视图参数
   * @param {string} id 业务数据主键
   * @return {*}  {Promise<CollaborateRoom>}
   */
  async get(e, t, n) {
    const i = this.getAppId(e);
    if (!this.collaborateMap.has(i))
      throw new Error(
        ibiz.i18n.t("runtime.utils.collaborateManager.invalidCollaborateRoom", {
          id: n
        })
      );
    const r = this.collaborateMap.get(i);
    if (r && r.has(n))
      return r.get(n);
    throw new Error(
      ibiz.i18n.t("runtime.utils.collaborateManager.invalidCollaborateRoom", {
        id: n
      })
    );
  }
  /**
   * 销毁协同房间
   *
   * @author tony001
   * @date 2024-08-06 10:08:08
   * @param {IContext} context 上下文
   * @param {IParams} params 视图参数
   * @param {string} id 业务数据主键
   * @return {*}  {Promise<void>}
   */
  async destroy(e, t, n) {
    const i = this.getAppId(e);
    if (this.collaborateMap.has(i)) {
      const r = this.collaborateMap.get(i);
      r && r.has(n) && (r.get(n).destroy(), r.delete(n));
    }
  }
}
class e2 {
  /**
   * Creates an instance of SlateYjs.
   * @memberof SlateYjs
   */
  constructor(e) {
    /**
     * Yjs 文档
     *
     * @private
     * @type {Y.Doc}
     * @memberof Yjs
     */
    E(this, "yDoc", new ui());
    /**
     * 协同编辑管理器
     *
     * @private
     * @memberof SlateYjs
     */
    E(this, "collaborateManager", new Qw());
    /**
     * Yjs ws 适配器
     *
     * @type {WebsocketProvider | undefined}
     * @memberof Yjs
     */
    E(this, "wsProvider");
    /**
     * 是否初始化完成
     *
     * @private
     * @type {Ref<boolean>}
     * @memberof Yjs
     */
    E(this, "inited", T(!1));
    /**
     * yjs 编辑器实例
     *
     * @type {YjsEditor | undefined}
     * @memberof Yjs
     */
    E(this, "yjsEditor");
    /**
     * 光标状态信息
     *
     * @memberof Yjs
     */
    E(this, "cursorStates", Wh({}));
    /**
     * 光标处理
     *
     * @private
     * @type {(RemoteCursorChangeEventListener | null)}
     * @memberof Yjs
     */
    E(this, "cursorHandler", null);
    this.enableRealtime = e, this.inited.value = !e;
  }
  /**
   * 初始化YJS 必须调用
   *
   * @param {ISlateYjsOption} opt
   * @return {*}  {Promise<void>}
   * @memberof Yjs
   */
  async initYjs(e) {
    var t;
    if (!this.inited.value) {
      const n = [...e.editor.children], i = this.yDoc.get("content", Je), r = await this.collaborateManager.create(
        e.context,
        e.params,
        e.roomname,
        this.yDoc
      );
      this.wsProvider = r.connectionProvider, this.wsProvider.on("status", (o) => {
        o.status === "connected" && !this.inited.value && setTimeout(() => {
          this.inited.value = !0, !i.toJSON() && n.length > 0 && i.applyDelta(ud(n));
        }, 1e3);
      }), this.yjsEditor = D0(
        N0(
          _0(
            O0(
              k0(e.editor, i, bd((t = e.htmlRef) == null ? void 0 : t.$el), {
                autoConnect: !0
              }),
              this.wsProvider.awareness,
              {
                data: j0(e.context.srfusername)
              }
            )
          )
        )
      ), this.initCursorHandler();
    }
  }
  /**
   * 初始化光标处理
   *
   * @private
   * @memberof Yjs
   */
  initCursorHandler() {
    if (!this.cursorHandler && this.yjsEditor) {
      const e = /* @__PURE__ */ new Set();
      this.cursorHandler = (t) => {
        t.added.forEach((n) => e.add(n)), t.removed.forEach((n) => e.add(n)), t.updated.forEach((n) => e.add(n)), e.forEach((n) => {
          const i = En.cursorState(
            this.yjsEditor,
            n
          );
          i === null ? delete this.cursorStates[n.toString()] : this.cursorStates[n] = i;
        });
      }, En.on(
        this.yjsEditor,
        "change",
        this.cursorHandler
      );
    }
  }
  /**
   * 销毁
   *
   * @memberof Yjs
   */
  destroy() {
    var e, t;
    (e = this.yjsEditor) == null || e.disconnect(), this.wsProvider.disconnect(), this.cursorHandler && (En.off(
      this.yjsEditor,
      "change",
      this.cursorHandler
    ), this.cursorHandler = null), (t = this.yjsEditor) == null || t.destroy();
  }
}
const Ya = /* @__PURE__ */ me({
  name: "IBizHtmlCollapse",
  props: gl(),
  emits: ["change", "blur", "focus", "enter", "infoTextChange", "link"],
  setup(s, {
    emit: e
  }) {
    const t = we("html"), n = s.controller, i = T(), r = T({});
    let o = null, a = 0;
    const l = T(), c = Gh(), u = T(), f = T(), d = T(), g = T(""), p = T({
      Authorization: "Bearer ".concat(pl(ml.TOKEN))
    }), m = T(""), w = T(""), v = T(!0), y = T(!1), b = T(!1), x = T(!1), C = T(!1), A = T(!0), P = T(!1), O = T(""), k = T(!1);
    let D;
    const L = T([]), B = new e2(n.enableRealtime), ee = () => {
      const N = s.data.srfuf === Gg.CREATE;
      B.initYjs({
        roomname: N ? "draft" : s.data.srfkey,
        editor: c.value,
        context: n.context,
        params: n.params,
        htmlRef: u.value
      });
    }, q = n.model;
    q.editorParams && (q.editorParams.enableEdit && (y.value = !0, b.value = !0, v.value = n.toBoolean(q.editorParams.enableEdit) && !s.readonly && !s.disabled), q.editorParams.enableFullScreen && (x.value = n.toBoolean(q.editorParams.enableFullScreen))), s.readonly && (y.value = !1, b.value = !0), Ne(() => s.data, (N) => {
      if (N) {
        const z = ibiz.util.file.calcFileUpDownUrl(n.context, n.params, N, n.editorParams);
        m.value = z.uploadUrl, w.value = z.downloadUrl;
      }
    }, {
      immediate: !0,
      deep: !0
    });
    const _ = (N, z) => {
      if (z)
        return !0;
    }, I = (N) => N;
    let H;
    const oe = async () => {
      var N;
      if (n.deService) {
        const z = await import("@ibiz-template-plugin/ai-chat"), W = z.chat || z.default.chat;
        H = W;
        const ve = W.create({
          question: async (Jt) => {
            var hc;
            const Yt = rt();
            return await ((hc = n.deService) == null ? void 0 : hc.aiChatSse((pt) => {
              if (ibiz.log.info("aiChatSse", pt), pt.actionstate === 20 && pt.actionresult)
                ve.addMessage({
                  messageid: Yt,
                  state: pt.actionstate,
                  type: "DEFAULT",
                  role: "ASSISTANT",
                  content: pt.actionresult
                });
              else if (pt.actionstate === 30 && pt.actionresult) {
                const Fg = JSON.parse(pt.actionresult), {
                  choices: ea
                } = Fg;
                ea && ea.length > 0 && ve.replaceMessage({
                  messageid: Yt,
                  state: pt.actionstate,
                  type: "DEFAULT",
                  role: "ASSISTANT",
                  content: ea[0].content || ""
                });
              } else
                pt.actionstate === 40 && ve.replaceMessage({
                  messageid: Yt,
                  state: pt.actionstate,
                  type: "ERROR",
                  role: "ASSISTANT",
                  content: pt.actionresult
                });
            }, n.context, {}, {
              messages: Jt
            })), ve.addMessage({
              messageid: Yt,
              state: 10,
              type: "DEFAULT",
              role: "ASSISTANT",
              content: ""
            }), !0;
          },
          action: (Jt, Yt) => {
            Jt === "backfill" && (y.value ? g.value = Yt.content : e("change", Yt.content), k.value = !0);
          },
          closed: () => {
            c.value && c.value.focus(!0);
          }
        }), Xe = await ((N = n.deService) == null ? void 0 : N.aiChatHistory(n.context, {}));
        Xe.data && Array.isArray(Xe.data) && Xe.data.forEach((Jt) => {
          const Yt = {
            messageid: rt(),
            state: 30,
            type: "DEFAULT",
            role: Jt.role,
            content: Jt.content
          };
          ve.addMessage(Yt);
        });
      }
    }, ne = {
      toolbarKeys: mp
    };
    n.chatCompletion && (ne.insertKeys = {
      index: 60,
      keys: ["|", "aichart"]
    }), n.insertKeys.length > 0 && ne.toolbarKeys && n.insertKeys.forEach((N) => {
      N.keys && N.keys.forEach((z, W) => {
        ne.toolbarKeys.includes(z) || ne.toolbarKeys.splice(N.index + W, 0, z);
      });
    });
    const ye = {
      placeholder: n.placeHolder,
      readOnly: y.value ? b.value : s.readonly,
      MENU_CONF: {
        // 图片上传
        uploadImage: {
          // 上传地址
          server: m.value,
          // form-data fieldName ，默认值 'wangeditor-uploaded-image'
          fieldName: "file",
          // 单个文件的最大体积限制，默认为 2M
          maxFileSize: 10 * 1024 * 1024,
          // 10M
          // 最多可上传几个文件，默认为 100
          maxNumberOfFiles: 10,
          // 选择文件时的类型限制，默认为 ['image/*'] 。如不想限制，则设置为 []
          allowedFileTypes: [],
          // 自定义增加 http  header
          headers: p.value,
          // 跨域是否传递 cookie ，默认为 false
          withCredentials: !0,
          // 上传之前触发
          onBeforeUpload(N) {
            return N;
          },
          // 上传进度的回调函数
          onProgress(N) {
            console.log("progress", N);
          },
          // 单个文件上传成功之后
          onSuccess(N, z) {
            console.log("".concat(N.name, " 上传成功"), z);
          },
          // 单个文件上传失败
          onFailed(N, z) {
            console.log("".concat(N.name, " 上传失败"), z);
          },
          // 上传错误，或者触发 timeout 超时
          onError(N, z, W) {
            console.log("".concat(N.name, " 上传出错"), z, W);
          },
          // 自定义插入图片
          async customInsert(N, z) {
            const W = w.value.replace("%fileId%", N.id), ve = N.filename;
            z(W, ve, "");
          }
        },
        // 插入链接
        insertLink: {
          checkLink: _,
          // 也支持 async 函数
          parseLinkUrl: I
          // 也支持 async 函数
        },
        // 更新链接
        editLink: {
          checkLink: _,
          // 也支持 async 函数
          parseLinkUrl: I
          // 也支持 async 函数
        }
      },
      hoverbarKeys: {
        link: {
          menuKeys: ["editLink", "unLink", "customViewLink"]
        }
      }
    };
    Co(() => {
      const N = c.value;
      N != null && (n.enableRealtime ? B.destroy() : N.destroy());
    });
    const Se = async (N) => {
      if (n.maxHeight) {
        const z = N.getEditableContainer();
        P.value = z.offsetHeight > n.maxHeight;
      }
    }, Rt = async (N) => {
      const z = N.src;
      if (b.value)
        Wt(z);
      else {
        const W = Q.nodes(c.value, {
          match: (ve) => !!(Ri.isElement(ve) && ve.type === "image"),
          universal: !0
        });
        if (W)
          for (const ve of W) {
            const [Xe] = ve;
            Xe.type === "image" && z.endsWith(Xe.src) && Wt(Xe.src);
          }
      }
    }, Wt = async (N) => {
      if (O.value = N, L.value = [N], await ht(), f.value) {
        const {
          container: z
        } = f.value.$refs;
        z && z.children[0].click();
      }
    }, ot = (N) => {
      const z = N.getEditableContainer();
      z && z.querySelectorAll("img").forEach((ve) => {
        ve.onload = () => {
          Se(N);
        }, ve.onclick = (Xe) => {
          const Jt = Xe.target;
          Jt && Rt(Jt);
        };
      });
    }, Mt = (N) => {
      if (f.value) {
        const {
          container: z
        } = f.value.$refs;
        if (z) {
          const W = z.querySelector(".el-image-viewer__wrapper");
          W == null || W[N]("keydown", Ke);
        }
      }
    }, Ke = async (N) => {
      (N.key === "Escape" || N.keyCode === 27) && (N.stopPropagation(), N.preventDefault(), await ht(), Mt("removeEventListener"), L.value = []);
    }, Qe = async () => {
      await ht(), Mt("addEventListener");
    }, mn = () => {
      let N = g.value;
      if (n.renderMode === "JSON") {
        const z = c.value;
        N = n.toJson(z.children);
      }
      s.value !== N && e("change", N);
    }, Hn = wl(mn, n.saveInterval), gt = (N) => {
      c.value = N, n.onCreated(c.value, s.data, ne);
      const z = n.parseNode(g.value);
      N.setHtml(z), ee();
      let W;
      N.on("modalOrPanelShow", (ve) => {
        W = new ru(ve, u.value);
      }), N.on("modalOrPanelHide", () => {
        W && W.destroy();
      }), N.on("aiClick", () => {
        oe();
      });
    }, vr = (N) => {
      const z = N.getHtml();
      Se(N), ot(N);
      const W = z === "<p><br></p>" ? "" : z;
      W === s.value || W === "" && Kh(s.value) || (!y.value && N.isFocused() && (n.emitMode === "AUTOMATIC" ? Hn() : mn()), n.evt.emit("onChange", {
        eventArg: W
      }));
    }, xr = (N) => {
    }, Un = (N) => {
      e("focus"), n.evt.emit("onFocus", {
        eventArg: s.value
      });
    }, qn = (N) => {
      e("blur"), n.evt.emit("onBlur", {
        eventArg: s.value
      });
    }, Cr = (N, z) => {
      alert("【自定义提示】".concat(z, " - ").concat(N));
    }, Er = (N, z, W) => {
      W(!0);
    }, yi = (N) => {
      const z = c.value;
      z != null && z.insertText(N);
    }, Jo = () => {
      c.value != null;
    }, vs = () => {
      const N = c.value;
      N != null && N.disable();
    }, xs = () => {
      const N = c.value;
      N != null && N.enable();
    }, Yo = () => {
      np(0, () => {
        if (i.value && l.value) {
          const N = i.value.$el.offsetHeight;
          o = new ResizeObserver((z) => {
            const {
              height: W
            } = z[0].contentRect;
            if (W !== a) {
              const ve = {
                height: "".concat(N - z[0].contentRect.height, "px")
              };
              r.value = t.cssVarBlock(ve), a = W;
            }
          }), o.observe(l.value.selector);
        }
      });
    }, bi = () => {
      var N, z;
      if (s.value) {
        const W = s.value.indexOf("</p>");
        if (W >= 0) {
          const ve = (N = c.value.selection.anchor) == null ? void 0 : N.offset, Xe = (z = c.value.selection.anchor) == null ? void 0 : z.path;
          ve === 0 && Xe.length > 0 && Xe[0] === 0 && c.value.move(W - 3);
        }
      }
    }, vi = () => {
      if (b.value = !b.value, !b.value)
        xs(), c.value.focus(), bi(), A.value = !0;
      else {
        if (u.value) {
          const {
            box: N
          } = u.value.$refs;
          N.scroll(0, 0);
        }
        vs();
      }
    }, Xo = () => M("div", {
      class: t.be("message", "message-content")
    }, [M("p", null, [tt("确定要取消编辑吗？")]), M("p", {
      class: t.bem("message", "message-content", "message-tip")
    }, [tt("取消编辑将无法保存修改的内容，且不能找回。")])]), Zo = () => {
      s.value !== g.value ? eu({
        title: "确认取消",
        type: "warning",
        customClass: t.b("message"),
        message: Xo(),
        showCancelButton: !0,
        cancelButtonClass: t.be("message", "message-cancel"),
        confirmButtonClass: t.be("message", "message-comfire")
      }).then(() => {
        if (s.value) {
          const N = n.parseNode(s.value);
          g.value = N;
        } else
          g.value = "";
        vi();
      }).catch(() => {
        c.value.focus();
      }) : vi();
    }, Ko = () => {
      b.value = !0, c.value.disable(), n.renderMode !== "JSON" && e("change", g.value), C.value && (C.value = !1);
    }, Qo = () => y.value && n.emitMode !== "AUTOMATIC" ? M("div", {
      class: [t.b("footer"), {
        [t.b("footer-dialog")]: C.value
      }]
    }, [M("div", {
      class: t.be("footer", "cancel"),
      onClick: () => Zo()
    }, [tt("取消")]), M("div", {
      class: t.be("footer", "save"),
      onClick: () => Ko()
    }, [tt("保存")])]) : null, j = () => {
      C.value = !C.value, A.value = !C.value, ht(() => {
        b.value ? vs() : (xs(), c.value.focus());
      });
    }, V = () => x.value ? C.value ? M("i", {
      class: "fa fa-compress",
      "aria-hidden": "true",
      title: "缩小",
      onClick: () => j()
    }, null) : M("i", {
      class: "fa fa-expand",
      "aria-hidden": "true",
      title: "放大",
      onClick: () => j()
    }, null) : null, ie = () => y.value || x.value ? M("div", {
      class: t.b("custom-toolbar")
    }, [y.value && v.value && b.value ? M("i", {
      class: "fa fa-edit",
      "aria-hidden": "true",
      title: "编辑",
      onClick: () => vi()
    }, null) : null, V()]) : null, Oe = () => P.value ? A.value ? M("div", {
      class: t.e("toggle"),
      onClick: () => {
        A.value = !A.value;
      }
    }, [tt("展开更多 "), M(Ie("ion-icon"), {
      name: "arrow-down-outline"
    }, null)]) : M("div", {
      class: t.e("toggle"),
      onClick: () => {
        A.value = !A.value;
      }
    }, [tt("收起更多 "), M(Ie("ion-icon"), {
      name: "arrow-up-outline"
    }, null)]) : null, et = () => {
      const N = {
        ...r.value
      };
      return A.value && n.maxHeight && Object.assign(N, {
        maxHeight: "".concat(n.maxHeight, "px")
      }), ri(M(G0, {
        ref: "htmlContent",
        style: N,
        slateYjs: B,
        "element-loading-text": "数据同步中...",
        class: [t.b("content"), t.is("readonly", b.value)]
      }, {
        default: () => [M(Xh, {
          ref: "toolbarRef",
          editor: c.value,
          "default-config": ne,
          mode: "default",
          class: t.b("toolbar")
        }, null), M(Yh, {
          ref: "htmlRef",
          class: t.b("editor"),
          modelValue: g.value,
          "onUpdate:modelValue": (z) => g.value = z,
          "default-config": ye,
          mode: "default",
          onOnCreated: gt,
          onOnChange: vr,
          onOnDestroyed: xr,
          onOnFocus: Un,
          onOnBlur: qn,
          oncustomAlert: Cr,
          oncustomPaste: Er
        }, null)]
      }), [[ji("loading"), !B.inited.value]]);
    }, kt = () => M(Ie("el-image"), {
      class: t.e("preview"),
      ref: "previewRef",
      "zoom-rate": 1.1,
      src: O.value,
      "preview-src-list": L.value,
      "hide-on-click-modal": !0,
      onShow: Qe,
      fit: "cover"
    }, null);
    return hn(() => {
      d.value && (D = Zg(d, async () => {
        c.value && c.value.emit("clickOutside");
      })), Yo(), Ne(() => s.value, (N, z) => {
        N !== z && (typeof s.value == "string" || N == null) && (N == null ? g.value = "" : n.renderMode === "JSON" ? g.value = n.jsonToHtml(N) : g.value = N, k.value && (c.value && ht(() => {
          c.value.focus(!0);
        }), k.value = !1));
      }, {
        immediate: !0
      }), Ne(() => s.disabled, (N, z) => {
        N !== z && (N === !0 ? vs() : xs());
      }, {
        immediate: !0
      });
    }), or(() => {
      o && o.disconnect(), D && D.stop && D.stop(), H && H.close();
    }), {
      ns: t,
      editorRef: c,
      previewRef: f,
      containerRef: d,
      htmlRef: u,
      mode: "default",
      valueHtml: g,
      toolbarConfig: ne,
      editorConfig: ye,
      handleCreated: gt,
      handleChange: vr,
      handleDestroyed: xr,
      handleFocus: Un,
      handleBlur: qn,
      customAlert: Cr,
      customPaste: Er,
      insertText: yi,
      printHtml: Jo,
      disable: vs,
      enable: xs,
      renderHeaserToolbar: ie,
      renderEditorContent: et,
      renderToggle: Oe,
      renderFooter: Qo,
      htmlContent: i,
      hasEnableEdit: y,
      cssVars: r,
      toolbarRef: l,
      isFullScreen: C,
      readonlyState: b,
      collapse: A,
      changeFullScreenState: j,
      renderPreview: kt
    };
  },
  render() {
    return this.isFullScreen ? M(Ie("el-dialog"), {
      modelValue: this.isFullScreen,
      "onUpdate:modelValue": (s) => this.isFullScreen = s,
      width: "80%",
      top: "10vh",
      class: this.ns.b("dialog-full-screen"),
      onClose: () => this.changeFullScreenState()
    }, {
      default: () => [M("div", {
        ref: "containerRef",
        class: [this.ns.b(), this.ns.b("collapse"), {
          [this.ns.b("editor-readonly")]: this.readonlyState
        }]
      }, [this.renderHeaserToolbar(), this.renderEditorContent(), this.hasEnableEdit && !this.readonlyState ? this.renderFooter() : null])]
    }) : M("div", {
      ref: "containerRef",
      class: [this.ns.b(), this.ns.is("allow-collapse", !0), {
        [this.ns.b("editor-readonly")]: this.readonlyState
      }]
    }, [this.renderHeaserToolbar(), this.renderEditorContent(), this.readonlyState ? this.renderToggle() : null, this.hasEnableEdit && !this.readonlyState ? this.renderFooter() : null, this.renderPreview()]);
  }
});
const ga = /* @__PURE__ */ me({
  name: "HtmlComment",
  props: gl(),
  emits: Kg(),
  setup(s, {
    emit: e
  }) {
    const t = we("html-comment"), n = s.controller, i = T(), r = T(), o = T(!1), a = () => {
      n.collapsed.value = !1, e("focus");
    }, l = (d) => {
      e("change", d), d && n.collapsed.value && (n.collapsed.value = !1);
    }, c = () => {
      if (e("blur"), s.value)
        return null;
      n.collapsed.value = !0;
    }, u = () => {
      o.value = !0;
    };
    return {
      ns: t,
      c: n,
      comment: i,
      editorRef: r,
      onChange: l,
      onFocus: a,
      onBlur: c,
      renderAvatar: () => {
        if (n.userAvatar && !o.value) {
          const p = JSON.parse(n.userAvatar);
          if (p.length === 0)
            return null;
          const {
            downloadUrl: m
          } = ibiz.util.file.calcFileUpDownUrl(n.context, n.params, s.data, n.editorParams), w = m.replace("%fileId%", p[0].id);
          return M("div", {
            class: t.e("avatar-name")
          }, [M("img", {
            src: w,
            alt: "",
            onError: u
          }, null)]);
        }
        const d = zs.stringToHexColor(n.context.srfusername), g = zs.avatarName(n.context.srfusername);
        return n.context.srfusername ? M("div", {
          class: t.e("avatar-name"),
          style: "background: ".concat(d, ";")
        }, [g]) : M(Ie("el-avatar"), {
          class: t.e("avatar"),
          src: "./assets/images/user-avatar.png"
        }, null);
      }
    };
  },
  render() {
    return this.c.mode === "default" ? M(Ya, {
      controller: this.c,
      data: this.data,
      value: this.value,
      readonly: this.readonly,
      onChange: this.onChange,
      onFocus: this.onFocus,
      onBlur: this.onBlur
    }, null) : M("div", {
      ref: "comment",
      class: [this.ns.b(), this.ns.is("collapse", this.c.collapsed.value)],
      style: {
        height: "".concat(this.c.collapsed.value ? this.c.minHeight : this.c.maxHeight, "px")
      }
    }, [this.renderAvatar(), M(Xr, {
      controller: this.c,
      data: this.data,
      value: this.value,
      onChange: this.onChange,
      onFocus: this.onFocus,
      onBlur: this.onBlur
    }, null)]);
  }
});
function rh(s, e, t, n, i) {
  const r = e === void 0 ? void 0 : e.key;
  return { sel: s, data: e, children: t, text: n, elm: i, key: r };
}
const oh = Array.isArray;
function pa(s) {
  return typeof s == "string" || typeof s == "number" || s instanceof String || s instanceof Number;
}
function $d(s, e, t) {
  if (s.ns = "http://www.w3.org/2000/svg", t !== "foreignObject" && e !== void 0)
    for (let n = 0; n < e.length; ++n) {
      const i = e[n];
      if (typeof i == "string")
        continue;
      const r = i.data;
      r !== void 0 && $d(r, i.children, i.sel);
    }
}
function gn(s, e, t) {
  let n = {}, i, r, o;
  if (t !== void 0 ? (e !== null && (n = e), oh(t) ? i = t : pa(t) ? r = t.toString() : t && t.sel && (i = [t])) : e != null && (oh(e) ? i = e : pa(e) ? r = e.toString() : e && e.sel ? i = [e] : n = e), i !== void 0)
    for (o = 0; o < i.length; ++o)
      pa(i[o]) && (i[o] = rh(void 0, void 0, void 0, i[o], void 0));
  return s[0] === "s" && s[1] === "v" && s[2] === "g" && (s.length === 3 || s[3] === "." || s[3] === "#") && $d(n, i, s), rh(s, n, i, r, void 0);
}
function t2(s) {
  const { script: e = "", data: t = {} } = s, n = Lt.execScriptFn({ data: t }, e, {
    singleRowReturn: !0,
    isAsync: !1
  });
  return "".concat(n);
}
const n2 = {
  type: "attachments",
  elemToHtml: t2
};
function s2(s) {
  const e = decodeURIComponent(s.getAttribute("data-value") || ""), t = JSON.parse(e);
  return {
    type: "attachments",
    script: t.script,
    data: t,
    children: [{ text: "" }]
  };
}
const i2 = {
  selector: 'span[data-w-e-type="attachments"]',
  parseElemHtml: s2
};
function r2(s) {
  const { data: e = {} } = s, t = {
    name: "".concat(e.name),
    id: e.id
  };
  return gn(
    "mention-elem",
    {
      dataset: { value: JSON.stringify(t) },
      props: {
        contentEditable: !1
        // 不可编辑
      }
    },
    []
  );
}
const o2 = {
  type: "attachments",
  renderElem: r2
};
class a2 {
  constructor() {
    E(this, "title", "本地文件");
    E(this, "tag", "button");
    E(this, "iconSvg", '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36px" height="36px" viewBox="0 0 36 36" version="1.1">\n    <title>附件</title>\n    <g id="附件" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n        <g id="icon">\n            <rect id="矩形" stroke="#EEEEEE" fill="#FFFFFF" x="0.5" y="0.5" width="35" height="35" rx="4"/>\n            <g id="编组-28" transform="translate(2.997929, 8.001508)">\n                <path d="M13.9611058,12.6330155 C13.9611058,14.5460163 12.4108408,16.0968098 10.498492,16.0968098 C8.58614322,16.0968098 7.03587822,14.5460163 7.03590808,12.6393438 L7.03590808,12.6393438 L6.98338468,7.07669061 C6.97992133,6.70644889 7.27712693,6.40347538 7.64724246,6.39998034 C8.017358,6.39648531 8.32022824,6.69379224 8.32372209,7.06403396 L8.32372209,7.06403396 L8.37624485,12.6330155 C8.37624485,13.8054998 9.32640727,14.7559862 10.498492,14.7559862 C11.6705768,14.7559862 12.6207392,13.8054998 12.6207392,12.6330155 L12.6207392,12.6330155 L12.6207392,6.46506253 C12.6207392,4.69957562 11.0562006,3.24725012 9.10227678,3.24725012 C7.148353,3.24725012 5.58381437,4.69957562 5.58381437,6.46506253 L5.58381437,6.46506253 L5.58381437,12.8655397 C5.58381437,15.5621365 7.78332719,17.7497339 10.498492,17.7497339 C13.2136568,17.7497339 15.4131697,15.5621365 15.4131697,12.8655397 L15.4131697,12.8655397 L15.4131697,7.10001026 C15.4131697,6.72975204 15.713221,6.42959845 16.083353,6.42959845 C16.453485,6.42959845 16.7535363,6.72975204 16.7535363,7.10001026 L16.7535363,7.10001026 L16.7535363,12.8655397 C16.7535363,16.3043913 13.9521943,19.0905575 10.498492,19.0905575 C7.04478976,19.0905575 4.24344774,16.3043913 4.24344774,12.8655397 L4.24344774,12.8655397 L4.24344774,6.46506253 C4.24344774,3.93573556 6.42955024,1.90642651 9.10227678,1.90642651 C11.7750033,1.90642651 13.9611058,3.93573556 13.9611058,6.46506253 L13.9611058,6.46506253 Z" id="形状结合" fill="#DDDDDD" transform="translate(10.498492, 10.498492) rotate(-315.000000) translate(-10.498492, -10.498492) "/>\n                <path d="M21.6662931,9.87797441 L24.6096402,9.87797441 C24.9410111,9.87797441 25.2096402,10.1466036 25.2096402,10.4779744 C25.2096402,10.8093453 24.9410111,11.0779744 24.6096402,11.0779744 L21.6662931,11.0779744 C21.3349223,11.0779744 21.0662931,10.8093453 21.0662931,10.4779744 C21.0662931,10.1466036 21.3349223,9.87797441 21.6662931,9.87797441 Z" id="矩形备份-74" fill="#73D897"/>\n                <path d="M21.6662931,4.29120933 L27.4020707,4.29120933 C27.7334415,4.29120933 28.0020707,4.55983848 28.0020707,4.89120933 C28.0020707,5.22258018 27.7334415,5.49120933 27.4020707,5.49120933 L21.6662931,5.49120933 C21.3349223,5.49120933 21.0662931,5.22258018 21.0662931,4.89120933 C21.0662931,4.55983848 21.3349223,4.29120933 21.6662931,4.29120933 Z" id="矩形备份-75" fill="#6698FF"/>\n                <path d="M21.6662931,15.4647395 L27.4020707,15.4647395 C27.7334415,15.4647395 28.0020707,15.7333686 28.0020707,16.0647395 C28.0020707,16.3961103 27.7334415,16.6647395 27.4020707,16.6647395 L21.6662931,16.6647395 C21.3349223,16.6647395 21.0662931,16.3961103 21.0662931,16.0647395 C21.0662931,15.7333686 21.3349223,15.4647395 21.6662931,15.4647395 Z" id="矩形备份-77" fill="#FF7575"/>\n            </g>\n        </g>\n    </g>\n</svg>');
  }
  // 菜单是否需要激活（如选中加粗文本，“加粗”菜单会激活），用不到则返回 false
  isActive(e) {
    return !1;
  }
  // 获取菜单执行时的 value ，用不到则返回空 字符串或 false
  getValue(e) {
    return "";
  }
  // 菜单是否需要禁用（如选中 H1 ，“引用”菜单被禁用），用不到则返回 false
  isDisabled(e) {
    return !1;
  }
  // 点击菜单时触发的函数
  exec(e, t) {
    throw new rs("暂未支持上传本地文件！");
  }
}
const l2 = {
  key: "attachments",
  factory() {
    return new a2();
  }
}, c2 = {
  renderElems: [o2],
  elemsToHtml: [n2],
  parseElemsHtml: [i2],
  menus: [l2]
};
class h2 {
  /**
   * Creates an instance of AttachmentsController.
   * @param {IData} option
   * @memberof AttachmentsController
   */
  constructor() {
    /**
     * 模型
     *
     * @type {IEditor}
     * @memberof AttachmentsController
     */
    E(this, "model");
    /**
     * 上下文
     *
     * @type {IContext}
     */
    E(this, "context");
    /**
     * 视图参数
     *
     * @type {IParams}
     */
    E(this, "params");
    /**
     * 表单数据
     *
     * @type {IData}
     * @memberof AttachmentsController
     */
    E(this, "data", {});
    /**
     * 编辑器示例
     *
     * @type {IDomEditor}
     * @memberof AttachmentsController
     */
    E(this, "editor");
    /**
     * 编辑器参数
     *
     * @type {IData}
     * @memberof AttachmentsController
     */
    E(this, "editorParams");
    /**
     * 用户数据
     *
     * @type {IData[]}
     * @memberof AttachmentsController
     */
    E(this, "items", []);
    /**
     * 编辑器事件
     *
     * @type {ControllerEvent<commentEvent>}
     * @memberof AttachmentsController
     */
    E(this, "evt");
    /**
     * 是否正在执行
     *
     * @private
     * @type {boolean}
     * @memberof AttachmentsController
     */
    E(this, "execting", !1);
    this.registerNode();
  }
  registerNode() {
    window.attachmentsIsRegiter || (it.registerModule(c2), window.attachmentsIsRegiter = !0);
  }
  /**
   * 初始化
   *
   * @param {IDomEditor} editor
   * @memberof AttachmentsController
   */
  async init(e, t) {
    this.model = t.model, this.context = t.context, this.params = t.params, this.evt = t.evt, this.data = t.data, this.editor = e, this.editorParams = this.model.editorParams;
  }
  /**
   * 控制器销毁
   *
   * @memberof AttachmentsController
   */
  onDestroyed() {
  }
  /**
   * 插入节点
   *
   * @param {IDomEditor} editor
   * @memberof AttachmentsController
   */
  insertNode(e) {
  }
  /**
   * 解析mention节点
   *
   * @param {string} value
   * @return {*}
   * @memberof AttachmentsController
   */
  parseNode(e) {
    return e;
  }
}
function u2(s) {
  const { script: e = "", data: t = {} } = s, n = Lt.execScriptFn({ data: t }, e, {
    singleRowReturn: !0,
    isAsync: !1
  });
  return "".concat(n);
}
const d2 = {
  type: "codesnippet",
  elemToHtml: u2
};
function f2(s) {
  const e = decodeURIComponent(s.getAttribute("data-value") || ""), t = JSON.parse(e);
  return {
    type: "codesnippet",
    script: t.script,
    data: t,
    children: [{ text: "" }]
  };
}
const g2 = {
  selector: 'span[data-w-e-type="codesnippet"]',
  parseElemHtml: f2
};
function p2(s) {
  const { data: e = {} } = s, t = {
    name: "".concat(e.name),
    id: e.id
  };
  return gn(
    "mention-elem",
    {
      dataset: { value: JSON.stringify(t) },
      props: {
        contentEditable: !1
        // 不可编辑
      }
    },
    []
  );
}
const m2 = {
  type: "CodeSnippet",
  renderElem: p2
};
class w2 {
  constructor() {
    E(this, "title", "代码段");
    E(this, "tag", "button");
    E(this, "iconSvg", '<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="36px" height="36px" viewBox="0 0 36 36" version="1.1">\n  <title>代码段</title>\n  <g id="代码段" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd">\n      <g id="icon备份">\n          <rect id="矩形" stroke="#EEEEEE" fill="#FFFFFF" x="0.5" y="0.5" width="35" height="35" rx="4"/>\n          <path d="M24.6642225,18.8794824 L27.6075695,18.8794824 C27.9389404,18.8794824 28.2075695,19.1481115 28.2075695,19.4794824 C28.2075695,19.8108532 27.9389404,20.0794824 27.6075695,20.0794824 L24.6642225,20.0794824 C24.3328516,20.0794824 24.0642225,19.8108532 24.0642225,19.4794824 C24.0642225,19.1481115 24.3328516,18.8794824 24.6642225,18.8794824 Z" id="矩形备份-74" fill="#73D897"/>\n          <path d="M24.6642225,13.2927173 L30.4,13.2927173 C30.7313708,13.2927173 31,13.5613465 31,13.8927173 C31,14.2240882 30.7313708,14.4927173 30.4,14.4927173 L24.6642225,14.4927173 C24.3328516,14.4927173 24.0642225,14.2240882 24.0642225,13.8927173 C24.0642225,13.5613465 24.3328516,13.2927173 24.6642225,13.2927173 Z" id="矩形备份-75" fill="#6698FF"/>\n          <path d="M24.6642225,24.4662475 L30.4,24.4662475 C30.7313708,24.4662475 31,24.7348766 31,25.0662475 C31,25.3976183 30.7313708,25.6662475 30.4,25.6662475 L24.6642225,25.6662475 C24.3328516,25.6662475 24.0642225,25.3976183 24.0642225,25.0662475 C24.0642225,24.7348766 24.3328516,24.4662475 24.6642225,24.4662475 Z" id="矩形备份-77" fill="#FF7575"/>\n          <g id="1.Base基础/1.icon图标/11.editor/header-1" transform="translate(5.000000, 11.000000)" fill="#DDDDDD">\n              <path d="M4.68266589,2.39258039 L1.51032474,7.44797324 L5.01586095,12.7216272 L4.05994646,13.3212428 L0.126424153,7.40475416 L3.68603474,1.72997946 L4.68266589,2.39258039 Z M11.3173341,12.6697762 L14.4896753,7.61438339 L10.984139,2.34072939 L11.9400535,1.7411138 L15.8735758,7.65760247 L12.3139653,13.3323772 L11.3173341,12.6697762 Z M8.86596086,1.31248434 L10.0376294,1.55020137 L7.19605832,13.6243456 L6.0243898,13.3866286 L8.86596086,1.31248434 Z" id="形状结合"/>\n          </g>\n      </g>\n  </g>\n</svg>');
  }
  // 菜单是否需要激活（如选中加粗文本，“加粗”菜单会激活），用不到则返回 false
  isActive(e) {
    return !1;
  }
  // 获取菜单执行时的 value ，用不到则返回空 字符串或 false
  getValue(e) {
    return "";
  }
  // 菜单是否需要禁用（如选中 H1 ，“引用”菜单被禁用），用不到则返回 false
  isDisabled(e) {
    return !1;
  }
  // 点击菜单时触发的函数
  exec(e, t) {
    throw new rs("暂未支持上传代码段！");
  }
}
const y2 = {
  key: "codesnippet",
  factory() {
    return new w2();
  }
}, b2 = {
  renderElems: [m2],
  elemsToHtml: [d2],
  parseElemsHtml: [g2],
  menus: [y2]
};
class v2 {
  /**
   * Creates an instance of CodeSnippetController.
   * @param {IData} option
   * @memberof CodeSnippetController
   */
  constructor() {
    /**
     * 模型
     *
     * @type {IEditor}
     * @memberof CodeSnippetController
     */
    E(this, "model");
    /**
     * 上下文
     *
     * @type {IContext}
     */
    E(this, "context");
    /**
     * 视图参数
     *
     * @type {IParams}
     */
    E(this, "params");
    /**
     * 表单数据
     *
     * @type {IData}
     * @memberof CodeSnippetController
     */
    E(this, "data", {});
    /**
     * 编辑器示例
     *
     * @type {IDomEditor}
     * @memberof CodeSnippetController
     */
    E(this, "editor");
    /**
     * 编辑器参数
     *
     * @type {IData}
     * @memberof CodeSnippetController
     */
    E(this, "editorParams");
    /**
     * 用户数据
     *
     * @type {IData[]}
     * @memberof CodeSnippetController
     */
    E(this, "items", []);
    /**
     * 编辑器事件
     *
     * @type {ControllerEvent<commentEvent>}
     * @memberof CodeSnippetController
     */
    E(this, "evt");
    /**
     * 是否正在执行
     *
     * @private
     * @type {boolean}
     * @memberof CodeSnippetController
     */
    E(this, "execting", !1);
    this.registerNode();
  }
  registerNode() {
    window.codesnippetIsRegiter || (it.registerModule(b2), window.codesnippetIsRegiter = !0);
  }
  /**
   * 初始化
   *
   * @param {IDomEditor} editor
   * @memberof CodeSnippetController
   */
  async init(e, t) {
    this.model = t.model, this.context = t.context, this.params = t.params, this.evt = t.evt, this.data = t.data, this.editor = e, this.editorParams = this.model.editorParams;
  }
  /**
   * 控制器销毁
   *
   * @memberof CodeSnippetController
   */
  onDestroyed() {
  }
  /**
   * 插入节点
   *
   * @param {IDomEditor} editor
   * @memberof CodeSnippetController
   */
  insertNode(e) {
  }
  /**
   * 解析mention节点
   *
   * @param {string} value
   * @return {*}
   * @memberof CodeSnippetController
   */
  parseNode(e) {
    return e;
  }
}
function x2(s) {
  const { script: e = "", data: t = {} } = s, n = Lt.execScriptFn({ data: t }, e, {
    singleRowReturn: !0,
    isAsync: !1
  });
  return "".concat(n);
}
const C2 = {
  type: "marker",
  elemToHtml: x2
};
function E2(s) {
  const e = decodeURIComponent(s.getAttribute("data-value") || ""), t = JSON.parse(e);
  return {
    type: "marker",
    script: t.script,
    data: t,
    children: [{ text: "" }]
  };
}
const S2 = {
  selector: 'span[data-w-e-type="marker"]',
  parseElemHtml: E2
};
function A2(s) {
  const { data: e = {} } = s;
  return gn(
    "mention-elem",
    {
      dataset: { value: JSON.stringify(e) },
      props: {
        contentEditable: !1
        // 不可编辑
      }
    },
    []
  );
}
const M2 = {
  type: "marker",
  renderElem: A2
};
let k2 = class {
  constructor() {
    E(this, "title", "提及工作项");
    E(this, "tag", "button");
    E(this, "iconSvg", '<svg t="1706259772097" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6854" width="200" height="200"><path d="M929.28 625.664l-234.496 0.512 24.064-229.888 210.432-0.512c20.992 0 38.4-17.408 38.4-38.4s-17.408-38.4-38.4-38.4H727.04l29.184-275.456c2.048-20.992-13.312-39.936-34.304-41.984-20.992-2.048-39.936 13.312-41.984 34.304L650.24 318.976l-232.448 0.512 29.184-275.456c2.048-20.992-13.312-39.936-34.304-41.984-20.992-2.048-39.936 13.312-41.984 34.304l-29.696 283.648-246.272 0.512c-20.992 0-38.4 17.408-38.4 38.4s17.408 38.4 38.4 38.4l238.08-0.512-24.064 229.888-214.016 0.512c-20.992 0-38.4 17.408-38.4 38.4s17.408 38.4 38.4 38.4l205.824-0.512-29.184 276.992c-2.048 20.992 13.312 39.936 34.304 41.984h4.096c19.456 0 35.84-14.848 37.888-34.304l30.208-285.184 232.448-0.512-29.184 277.504c-2.048 20.992 13.312 39.936 34.304 41.984h4.096c19.456 0 35.84-14.848 38.4-34.304l30.208-285.184 242.688-0.512c20.992 0 38.4-17.408 38.4-38.4-1.536-20.992-18.944-37.888-39.936-37.888z m-544.256 0.512l24.064-229.888 232.448-0.512-24.064 229.888-232.448 0.512z" fill="#979797" p-id="6855"></path></svg>');
  }
  // 菜单是否需要激活（如选中加粗文本，“加粗”菜单会激活），用不到则返回 false
  isActive(e) {
    return !1;
  }
  // 获取菜单执行时的 value ，用不到则返回空 字符串或 false
  getValue(e) {
    return "";
  }
  // 菜单是否需要禁用（如选中 H1 ，“引用”菜单被禁用），用不到则返回 false
  isDisabled(e) {
    return !1;
  }
  // 点击菜单时触发的函数
  exec(e, t) {
    e.insertText("#");
  }
};
const P2 = {
  key: "marker",
  factory() {
    return new k2();
  }
}, _2 = {
  renderElems: [M2],
  elemsToHtml: [C2],
  parseElemsHtml: [S2],
  menus: [P2]
};
const O2 = /* @__PURE__ */ me({
  name: "MenTion",
  props: {
    controller: {
      type: Object,
      required: !0
    },
    modal: {
      type: Object
    }
  },
  setup(s) {
    const e = we("mention"), t = s.controller, n = T(!1), i = T([]);
    let r = St;
    const o = T({}), a = T(0), l = T([]), c = (x) => {
      const {
        eventArg: C
      } = x;
      if (C) {
        !C.includes("@") && t.overlay && t.execting && t.overlay.dismiss();
        const A = C.match(new RegExp("(?<=\\@)([^\\@&^{]*?)(?=\\<)", "g")) || [];
        t.execting && (A.length === 0 && t.overlay.dismiss(), t.query = A.pop() || "", t.query && /\s$/.test(t.query) ? t.overlay.dismiss() : t.query && p({
          isInitialLoad: !0
        }));
      } else
        t.overlay && t.execting && t.overlay.dismiss();
    }, u = () => {
      t.evt && t.evt.on("onChange", c);
    }, f = (x = {}) => {
      n.value = !0, t.getUsers(x).then((C) => {
        (C.status !== 200 || !C.data) && (n.value = !1), C.headers["x-total"] && (a.value = Number(C.headers["x-total"])), x.isLoadMore === !0 ? i.value.push(...t.toUIData(C.data)) : (i.value = t.toUIData(C.data), i.value.length > 0 && (o.value = i.value[0])), n.value = !1;
      }).catch(() => {
        n.value = !1;
      });
    }, d = () => {
      f({
        isLoadMore: !0
      });
    }, g = Ge(() => i.value.length >= a.value || n.value || a.value <= t.size), p = tu(f, 300, {
      leading: !0
    });
    u(), f({
      isInitialLoad: !0
    });
    const m = (x) => {
      let C = i.value.findIndex((A) => A.id === o.value.id);
      switch (x) {
        case "up":
          C--, (C === -1 || C === -2) && (C = i.value.length - 1), o.value = i.value[C];
          break;
        case "down":
          C++, C === i.value.length && (C = 0), o.value = i.value[C];
          break;
        case "enter":
          w(o.value);
          break;
      }
    }, w = (x) => {
      var C;
      if (s.modal) {
        const A = {
          ok: !0,
          data: [x]
        };
        (C = s.modal) == null || C.dismiss(A);
      }
    }, v = (x) => {
      if (!x)
        return null;
      const C = JSON.parse(x);
      if (C.length === 0)
        return null;
      const {
        downloadUrl: A
      } = ibiz.util.file.calcFileUpDownUrl(t.context, t.params, t.editorParams);
      return A.replace("%fileId%", C[0].id);
    }, y = (x) => {
      l.value.push(x);
    }, b = (x) => {
      const C = x.name, A = zs.stringToHexColor(C), P = zs.avatarName(C);
      let O = "";
      if (t.operatorMap.has(x.id)) {
        const k = t.operatorMap.get(x.id);
        k.data.iconurl && (O = v(k.data.iconurl) || "");
      }
      return M("div", {
        class: [e.e("item"), e.is("active", x.id === o.value.id)],
        onClick: () => w(x)
      }, [M("div", {
        class: e.e("avatar"),
        style: "background: ".concat(A, ";")
      }, [O && !l.value.includes(O) ? M("img", {
        src: O,
        onError: () => y(O)
      }, null) : P]), M("div", {
        class: e.e("name"),
        title: C
      }, [C])]);
    };
    return hn(() => {
      r = li(window, "keyup", (x) => {
        x.keyCode === 40 ? m("down") : x.keyCode === 38 ? m("up") : x.keyCode === 13 && m("enter");
      });
    }), Co(() => {
      r !== St && r(), t.evt.off("onChange", c);
    }), {
      ns: e,
      items: i,
      loading: n,
      isLodeMoreDisabled: g,
      renderItem: b,
      loadMore: d
    };
  },
  render() {
    return ri(M("div", {
      "infinite-scroll-distance": 10,
      "infinite-scroll-disabled": this.isLodeMoreDisabled,
      "infinite-scroll-immediate": !1,
      class: this.ns.b()
    }, [this.items.map((s) => this.renderItem(s)), this.items.length === 0 && M(Ie("iBizNoData"), {
      text: "暂无用户数据"
    }, null)]), [[ji("infinite-scroll"), () => this.loadMore()], [ji("loading"), this.loading]]);
  }
});
const T2 = /* @__PURE__ */ me({
  name: "Marker",
  props: {
    controller: {
      type: Object,
      required: !0
    },
    modal: {
      type: Object
    }
  },
  setup(s) {
    const e = we("marker"), t = s.controller, n = T(!1), i = T([]);
    let r = St;
    const o = T({}), a = T(0), l = (y) => {
      const {
        eventArg: b
      } = y;
      if (b) {
        !b.includes("#") && t.overlay && t.execting && t.overlay.dismiss();
        const x = /<svg((.|[\t\r\f\n\s])+?)<\/svg>/g, A = b.replace(x, "").match(new RegExp("(?<=\\#)([^\\#&^{]*?)(?=\\<)", "g")) || [];
        t.execting && (A.length === 0 && t.overlay.dismiss(), t.query = A.pop() || "", t.query && /\s$/.test(t.query) ? t.overlay.dismiss() : t.query && g({
          isInitialLoad: !0
        }));
      } else
        t.overlay && t.execting && t.overlay.dismiss();
    }, c = () => {
      t.evt && t.evt.on("onChange", l);
    }, u = (y = {}) => {
      n.value = !0, t.load(y).then((b) => {
        (b.status !== 200 || !b.data) && (n.value = !1), b.headers["x-total"] && (a.value = Number(b.headers["x-total"])), y.isLoadMore === !0 ? i.value.push(...t.toUIData(b.data)) : (i.value = t.toUIData(b.data), i.value.length > 0 && (o.value = i.value[0])), n.value = !1;
      }).catch(() => {
        n.value = !1;
      });
    }, f = () => {
      u({
        isLoadMore: !0
      });
    }, d = Ge(() => i.value.length >= a.value || n.value || a.value <= t.size), g = tu(u, 300, {
      leading: !0
    });
    c(), u({
      isInitialLoad: !0
    });
    const p = (y) => {
      let b = i.value.findIndex((x) => x.id === o.value.id);
      switch (y) {
        case "up":
          b--, (b === -1 || b === -2) && (b = i.value.length - 1), o.value = i.value[b];
          break;
        case "down":
          b++, b === i.value.length && (b = 0), o.value = i.value[b];
          break;
        case "enter":
          m(o.value);
          break;
      }
    }, m = (y) => {
      var b;
      if (s.modal) {
        const x = {
          ok: !0,
          data: [y]
        };
        (b = s.modal) == null || b.dismiss(x);
      }
    }, w = (y, b) => {
      if (t.quoteCodelistMap.has(y)) {
        const x = t.quoteCodelistMap.get(y);
        return M(Ie("iBizCodeList"), {
          codeListItems: x.codeListItems,
          codeList: x.codeList,
          value: b
        }, null);
      }
      return b;
    }, v = (y) => M("div", {
      class: [e.e("item"), e.is("active", y.id === o.value.id)],
      onClick: () => m(y)
    }, [M("div", {
      class: e.e("type")
    }, [w("type", y.type)]), M("div", {
      class: e.e("identifier")
    }, [w("identifier", y.identifier)]), M("div", {
      class: e.e("name"),
      title: y.name
    }, [w("name", y.name)])]);
    return hn(() => {
      r = li(window, "keyup", (y) => {
        y.keyCode === 40 ? p("down") : y.keyCode === 38 ? p("up") : y.keyCode === 13 && p("enter");
      });
    }), Co(() => {
      r !== St && r(), t.evt.off("onChange", l);
    }), {
      ns: e,
      items: i,
      loading: n,
      isLodeMoreDisabled: d,
      renderItem: v,
      loadMore: f
    };
  },
  render() {
    return ri(M("div", {
      "infinite-scroll-distance": 10,
      "infinite-scroll-disabled": this.isLodeMoreDisabled,
      "infinite-scroll-immediate": !1,
      class: this.ns.b()
    }, [this.items.map((s) => this.renderItem(s)), this.items.length === 0 && M(Ie("iBizNoData"), {
      text: "暂无用户数据"
    }, null)]), [[ji("infinite-scroll"), () => this.loadMore()], [ji("loading"), this.loading]]);
  }
});
const L2 = /* @__PURE__ */ me({
  name: "IBizHtmlEmoji",
  props: {
    modal: {
      type: Object,
      required: !0
    }
  },
  setup(s) {
    return {
      ns: we("html-emoji"),
      onSelect: (n) => {
        const i = {
          ok: !0,
          data: [{
            emoji: ka(n.data)
          }]
        };
        s.modal.dismiss(i);
      }
    };
  },
  render() {
    return M("div", {
      class: this.ns.b()
    }, [M(Ie("iBizEmojiSelect"), {
      dark: !0,
      continuousList: !0,
      onSelect: this.onSelect
    }, null)]);
  }
});
let Zt = class {
  constructor(e, t, n) {
    E(this, "name");
    E(this, "icon");
    E(this, "text");
    this.name = e, this.icon = t, this.text = n;
  }
  get label() {
    return this.name;
  }
};
class h {
  constructor(e, t, n) {
    E(this, "data");
    E(this, "category");
    E(this, "aliases");
    this.data = e, this.category = t, this.aliases = n;
  }
}
const D2 = [
  new h("😀", "peoples", ["grinning"]),
  new h("😃", "peoples", ["smiley"]),
  new h("😄", "peoples", ["smile"]),
  new h("😁", "peoples", ["grin"]),
  new h("😆", "peoples", ["laughing", "satisfied"]),
  new h("😅", "peoples", ["sweat_smile"]),
  new h("😂", "peoples", ["joy"]),
  new h("🤣", "peoples", ["rofl"]),
  new h("😌", "peoples", ["relaxed"]),
  new h("😊", "peoples", ["blush"]),
  new h("😇", "peoples", ["innocent"]),
  new h("🙂", "peoples", ["slightly_smiling_face"]),
  new h("🙃", "peoples", ["upside_down_face"]),
  new h("😉", "peoples", ["wink"]),
  new h("😌", "peoples", ["relieved"]),
  new h("😍", "peoples", ["heart_eyes"]),
  new h("😘", "peoples", ["kissing_heart"]),
  new h("😗", "peoples", ["kissing"]),
  new h("😙", "peoples", ["kissing_smiling_eyes"]),
  new h("😚", "peoples", ["kissing_closed_eyes"]),
  new h("😋", "peoples", ["yum"]),
  new h("😜", "peoples", ["stuck_out_tongue_winking_eye"]),
  new h("😝", "peoples", ["stuck_out_tongue_closed_eyes"]),
  new h("😛", "peoples", ["stuck_out_tongue"]),
  new h("🤑", "peoples", ["money_mouth_face"]),
  new h("🤗", "peoples", ["hugs"]),
  new h("🤓", "peoples", ["nerd_face"]),
  new h("😎", "peoples", ["sunglasses"]),
  new h("🤡", "peoples", ["clown_face"]),
  new h("🤠", "peoples", ["cowboy_hat_face"]),
  new h("😏", "peoples", ["smirk"]),
  new h("😒", "peoples", ["unamused"]),
  new h("😞", "peoples", ["disappointed"]),
  new h("😔", "peoples", ["pensive"]),
  new h("😟", "peoples", ["worried"]),
  new h("😕", "peoples", ["confused"]),
  new h("🙁", "peoples", ["slightly_frowning_face"]),
  new h("☹️", "peoples", ["frowning_face"]),
  new h("😣", "peoples", ["persevere"]),
  new h("😖", "peoples", ["confounded"]),
  new h("😫", "peoples", ["tired_face"]),
  new h("😩", "peoples", ["weary"]),
  new h("😤", "peoples", ["triumph"]),
  new h("😠", "peoples", ["angry"]),
  new h("😡", "peoples", ["rage", "pout"]),
  new h("😶", "peoples", ["no_mouth"]),
  new h("😐", "peoples", ["neutral_face"]),
  new h("😑", "peoples", ["expressionless"]),
  new h("😯", "peoples", ["hushed"]),
  new h("😦", "peoples", ["frowning"]),
  new h("😧", "peoples", ["anguished"]),
  new h("😮", "peoples", ["open_mouth"]),
  new h("😲", "peoples", ["astonished"]),
  new h("😵", "peoples", ["dizzy_face"]),
  new h("😳", "peoples", ["flushed"]),
  new h("😱", "peoples", ["scream"]),
  new h("😨", "peoples", ["fearful"]),
  new h("😰", "peoples", ["cold_sweat"]),
  new h("😢", "peoples", ["cry"]),
  new h("😥", "peoples", ["disappointed_relieved"]),
  new h("🤤", "peoples", ["drooling_face"]),
  new h("😭", "peoples", ["sob"]),
  new h("😓", "peoples", ["sweat"]),
  new h("😪", "peoples", ["sleepy"]),
  new h("😴", "peoples", ["sleeping"]),
  new h("🙄", "peoples", ["roll_eyes"]),
  new h("🤔", "peoples", ["thinking"]),
  new h("🤥", "peoples", ["lying_face"]),
  new h("😬", "peoples", ["grimacing"]),
  new h("🤐", "peoples", ["zipper_mouth_face"]),
  new h("🤢", "peoples", ["nauseated_face"]),
  new h("🤧", "peoples", ["sneezing_face"]),
  new h("😷", "peoples", ["mask"]),
  new h("🤒", "peoples", ["face_with_thermometer"]),
  new h("🤕", "peoples", ["face_with_head_bandage"]),
  new h("😈", "peoples", ["smiling_imp"]),
  new h("👿", "peoples", ["imp"]),
  new h("👹", "peoples", ["japanese_ogre"]),
  new h("👺", "peoples", ["japanese_goblin"]),
  new h("💩", "peoples", ["hankey", "poop", "shit"]),
  new h("👻", "peoples", ["ghost"]),
  new h("💀", "peoples", ["skull"]),
  new h("☠️", "peoples", ["skull_and_crossbones"]),
  new h("👽", "peoples", ["alien"]),
  new h("👾", "peoples", ["space_invader"]),
  new h("🤖", "peoples", ["robot"]),
  new h("🎃", "peoples", ["jack_o_lantern"]),
  new h("😺", "peoples", ["smiley_cat"]),
  new h("😸", "peoples", ["smile_cat"]),
  new h("😹", "peoples", ["joy_cat"]),
  new h("😻", "peoples", ["heart_eyes_cat"]),
  new h("😼", "peoples", ["smirk_cat"]),
  new h("😽", "peoples", ["kissing_cat"]),
  new h("🙀", "peoples", ["scream_cat"]),
  new h("😿", "peoples", ["crying_cat_face"]),
  new h("😾", "peoples", ["pouting_cat"]),
  new h("👐", "peoples", ["open_hands"]),
  new h("🙌", "peoples", ["raised_hands"]),
  new h("👏", "peoples", ["clap"]),
  new h("🙏", "peoples", ["pray"]),
  new h("🤝", "peoples", ["handshake"]),
  new h("👍", "peoples", ["+1", "thumbsup"]),
  new h("👎", "peoples", ["-1", "thumbsdown"]),
  new h("👊", "peoples", ["fist_oncoming", "facepunch", "punch"]),
  new h("✊", "peoples", ["fist_raised", "fist"]),
  new h("🤛", "peoples", ["fist_left"]),
  new h("🤜", "peoples", ["fist_right"]),
  new h("🤞", "peoples", ["crossed_fingers"]),
  new h("✌️", "peoples", ["v"]),
  new h("🤘", "peoples", ["metal"]),
  new h("👌", "peoples", ["ok_hand"]),
  new h("👈", "peoples", ["point_left"]),
  new h("👉", "peoples", ["point_right"]),
  new h("👆", "peoples", ["point_up_2"]),
  new h("👇", "peoples", ["point_down"]),
  new h("☝️", "peoples", ["point_up"]),
  new h("✋", "peoples", ["hand", "raised_hand"]),
  new h("🤚", "peoples", ["raised_back_of_hand"]),
  new h("🖐", "peoples", ["raised_hand_with_fingers_splayed"]),
  new h("🖖", "peoples", ["vulcan_salute"]),
  new h("👋", "peoples", ["wave"]),
  new h("🤙", "peoples", ["call_me_hand"]),
  new h("💪", "peoples", ["muscle"]),
  new h("🖕", "peoples", ["middle_finger", "fu"]),
  new h("✍️", "peoples", ["writing_hand"]),
  new h("🤳", "peoples", ["selfie"]),
  new h("💅", "peoples", ["nail_care"]),
  new h("💍", "peoples", ["ring"]),
  new h("💄", "peoples", ["lipstick"]),
  new h("💋", "peoples", ["kiss"]),
  new h("👄", "peoples", ["lips"]),
  new h("👅", "peoples", ["tongue"]),
  new h("👂", "peoples", ["ear"]),
  new h("👃", "peoples", ["nose"]),
  new h("👣", "peoples", ["footprints"]),
  new h("👁", "peoples", ["eye"]),
  new h("👀", "peoples", ["eyes"]),
  new h("🗣", "peoples", ["speaking_head"]),
  new h("👤", "peoples", ["bust_in_silhouette"]),
  new h("👥", "peoples", ["busts_in_silhouette"]),
  new h("👶", "peoples", ["baby"]),
  new h("👦", "peoples", ["boy"]),
  new h("👧", "peoples", ["girl"]),
  new h("👨", "peoples", ["man"]),
  new h("👩", "peoples", ["woman"]),
  new h("👱‍♀", "peoples", ["blonde_woman"]),
  new h("👱", "peoples", ["blonde_man", "person_with_blond_hair"]),
  new h("👴", "peoples", ["older_man"]),
  new h("👵", "peoples", ["older_woman"]),
  new h("👲", "peoples", ["man_with_gua_pi_mao"]),
  new h("👳‍♀", "peoples", ["woman_with_turban"]),
  new h("👳", "peoples", ["man_with_turban"]),
  new h("👮‍♀", "peoples", ["policewoman"]),
  new h("👮", "peoples", ["policeman", "cop"]),
  new h("👷‍♀", "peoples", ["construction_worker_woman"]),
  new h("👷", "peoples", [
    "construction_worker_man",
    "construction_worker"
  ]),
  new h("💂‍♀", "peoples", ["guardswoman"]),
  new h("💂", "peoples", ["guardsman"]),
  new h("👩‍⚕", "peoples", ["woman_health_worker"]),
  new h("👨‍⚕", "peoples", ["man_health_worker"]),
  new h("👩‍🌾", "peoples", ["woman_farmer"]),
  new h("👨‍🌾", "peoples", ["man_farmer"]),
  new h("👩‍🍳", "peoples", ["woman_cook"]),
  new h("👨‍🍳", "peoples", ["man_cook"]),
  new h("👩‍🎓", "peoples", ["woman_student"]),
  new h("👨‍🎓", "peoples", ["man_student"]),
  new h("👩‍🎤", "peoples", ["woman_singer"]),
  new h("👨‍🎤", "peoples", ["man_singer"]),
  new h("👩‍🏫", "peoples", ["woman_teacher"]),
  new h("👨‍🏫", "peoples", ["man_teacher"]),
  new h("👩‍🏭", "peoples", ["woman_factory_worker"]),
  new h("👨‍🏭", "peoples", ["man_factory_worker"]),
  new h("👩‍💻", "peoples", ["woman_technologist"]),
  new h("👨‍💻", "peoples", ["man_technologist"]),
  new h("👩‍💼", "peoples", ["woman_office_worker"]),
  new h("👨‍💼", "peoples", ["man_office_worker"]),
  new h("👩‍🔧", "peoples", ["woman_mechanic"]),
  new h("👨‍🔧", "peoples", ["man_mechanic"]),
  new h("👩‍🔬", "peoples", ["woman_scientist"]),
  new h("👨‍🔬", "peoples", ["man_scientist"]),
  new h("👩‍🎨", "peoples", ["woman_artist"]),
  new h("👨‍🎨", "peoples", ["man_artist"]),
  new h("👩‍🚒", "peoples", ["woman_firefighter"]),
  new h("👨‍🚒", "peoples", ["man_firefighter"]),
  new h("👩‍🚀", "peoples", ["woman_astronaut"]),
  new h("👨‍🚀", "peoples", ["man_astronaut"]),
  new h("🤶", "peoples", ["mrs_claus"]),
  new h("🎅", "peoples", ["santa"]),
  new h("👸", "peoples", ["princess"]),
  new h("🤴", "peoples", ["prince"]),
  new h("👰", "peoples", ["bride_with_veil"]),
  new h("🤵", "peoples", ["man_in_tuxedo"]),
  new h("👼", "peoples", ["angel"]),
  new h("🤰", "peoples", ["pregnant_woman"]),
  new h("🙇‍♀", "peoples", ["bowing_woman"]),
  new h("🙇", "peoples", ["bowing_man", "bow"]),
  new h("💁", "peoples", [
    "tipping_hand_woman",
    "information_desk_person",
    "sassy_woman"
  ]),
  new h("💁‍♂", "peoples", ["tipping_hand_man", "sassy_man"]),
  new h("🙅", "peoples", ["no_good_woman", "no_good", "ng_woman"]),
  new h("🙅‍♂", "peoples", ["no_good_man", "ng_man"]),
  new h("🙆", "peoples", ["ok_woman"]),
  new h("🙆‍♂", "peoples", ["ok_man"]),
  new h("🙋", "peoples", ["raising_hand_woman", "raising_hand"]),
  new h("🙋‍♂", "peoples", ["raising_hand_man"]),
  new h("🤦‍♀", "peoples", ["woman_facepalming"]),
  new h("🤦‍♂", "peoples", ["man_facepalming"]),
  new h("🤷‍♀", "peoples", ["woman_shrugging"]),
  new h("🤷‍♂", "peoples", ["man_shrugging"]),
  new h("🙎", "peoples", ["pouting_woman", "person_with_pouting_face"]),
  new h("🙎‍♂", "peoples", ["pouting_man"]),
  new h("🙍", "peoples", ["frowning_woman", "person_frowning"]),
  new h("🙍‍♂", "peoples", ["frowning_man"]),
  new h("💇", "peoples", ["haircut_woman", "haircut"]),
  new h("💇‍♂", "peoples", ["haircut_man"]),
  new h("💆", "peoples", ["massage_woman", "massage"]),
  new h("💆‍♂", "peoples", ["massage_man"]),
  new h("🕴", "peoples", ["business_suit_levitating"]),
  new h("💃", "peoples", ["dancer"]),
  new h("🕺", "peoples", ["man_dancing"]),
  new h("👯", "peoples", ["dancing_women", "dancers"]),
  new h("👯‍♂", "peoples", ["dancing_men"]),
  new h("🚶‍♀", "peoples", ["walking_woman"]),
  new h("🚶", "peoples", ["walking_man", "walking"]),
  new h("🏃‍♀", "peoples", ["running_woman"]),
  new h("🏃", "peoples", ["running_man", "runner", "running"]),
  new h("👫", "peoples", ["couple"]),
  new h("👭", "peoples", ["two_women_holding_hands"]),
  new h("👬", "peoples", ["two_men_holding_hands"]),
  new h("💑", "peoples", [
    "couple_with_heart_woman_man",
    "couple_with_heart"
  ]),
  new h("👩‍❤️‍👩", "peoples", ["couple_with_heart_woman_woman"]),
  new h("👨‍❤️‍👨", "peoples", ["couple_with_heart_man_man"]),
  new h("💏", "peoples", ["couplekiss_man_woman"]),
  new h("👩‍❤️‍💋‍👩", "peoples", ["couplekiss_woman_woman"]),
  new h("👨‍❤️‍💋‍👨", "peoples", ["couplekiss_man_man"]),
  new h("👪", "peoples", ["family_man_woman_boy", "family"]),
  new h("👨‍👩‍👧", "peoples", ["family_man_woman_girl"]),
  new h("👨‍👩‍👧‍👦", "peoples", ["family_man_woman_girl_boy"]),
  new h("👨‍👩‍👦‍👦", "peoples", ["family_man_woman_boy_boy"]),
  new h("👨‍👩‍👧‍👧", "peoples", ["family_man_woman_girl_girl"]),
  new h("👩‍👩‍👦", "peoples", ["family_woman_woman_boy"]),
  new h("👩‍👩‍👧", "peoples", ["family_woman_woman_girl"]),
  new h("👩‍👩‍👧‍👦", "peoples", ["family_woman_woman_girl_boy"]),
  new h("👩‍👩‍👦‍👦", "peoples", ["family_woman_woman_boy_boy"]),
  new h("👩‍👩‍👧‍👧", "peoples", ["family_woman_woman_girl_girl"]),
  new h("👨‍👨‍👦", "peoples", ["family_man_man_boy"]),
  new h("👨‍👨‍👧", "peoples", ["family_man_man_girl"]),
  new h("👨‍👨‍👧‍👦", "peoples", ["family_man_man_girl_boy"]),
  new h("👨‍👨‍👦‍👦", "peoples", ["family_man_man_boy_boy"]),
  new h("👨‍👨‍👧‍👧", "peoples", ["family_man_man_girl_girl"]),
  new h("👩‍👦", "peoples", ["family_woman_boy"]),
  new h("👩‍👧", "peoples", ["family_woman_girl"]),
  new h("👩‍👧‍👦", "peoples", ["family_woman_girl_boy"]),
  new h("👩‍👦‍👦", "peoples", ["family_woman_boy_boy"]),
  new h("👩‍👧‍👧", "peoples", ["family_woman_girl_girl"]),
  new h("👨‍👦", "peoples", ["family_man_boy"]),
  new h("👨‍👧", "peoples", ["family_man_girl"]),
  new h("👨‍👧‍👦", "peoples", ["family_man_girl_boy"]),
  new h("👨‍👦‍👦", "peoples", ["family_man_boy_boy"]),
  new h("👨‍👧‍👧", "peoples", ["family_man_girl_girl"]),
  new h("👚", "peoples", ["womans_clothes"]),
  new h("👕", "peoples", ["shirt", "tshirt"]),
  new h("👖", "peoples", ["jeans"]),
  new h("👔", "peoples", ["necktie"]),
  new h("👗", "peoples", ["dress"]),
  new h("👙", "peoples", ["bikini"]),
  new h("👘", "peoples", ["kimono"]),
  new h("👠", "peoples", ["high_heel"]),
  new h("👡", "peoples", ["sandal"]),
  new h("👢", "peoples", ["boot"]),
  new h("👞", "peoples", ["mans_shoe", "shoe"]),
  new h("👟", "peoples", ["athletic_shoe"]),
  new h("👒", "peoples", ["womans_hat"]),
  new h("🎩", "peoples", ["tophat"]),
  new h("🎓", "peoples", ["mortar_board"]),
  new h("👑", "peoples", ["crown"]),
  new h("⛑", "peoples", ["rescue_worker_helmet"]),
  new h("🎒", "peoples", ["school_satchel"]),
  new h("👝", "peoples", ["pouch"]),
  new h("👛", "peoples", ["purse"]),
  new h("👜", "peoples", ["handbag"]),
  new h("💼", "peoples", ["briefcase"]),
  new h("👓", "peoples", ["eyeglasses"]),
  new h("🕶", "peoples", ["dark_sunglasses"]),
  new h("🌂", "peoples", ["closed_umbrella"]),
  new h("☂️", "peoples", ["open_umbrella"]),
  new h("🐶", "nature", ["dog"]),
  new h("🐱", "nature", ["cat"]),
  new h("🐭", "nature", ["mouse"]),
  new h("🐹", "nature", ["hamster"]),
  new h("🐰", "nature", ["rabbit"]),
  new h("🦊", "nature", ["fox_face"]),
  new h("🐻", "nature", ["bear"]),
  new h("🐼", "nature", ["panda_face"]),
  new h("🐨", "nature", ["koala"]),
  new h("🐯", "nature", ["tiger"]),
  new h("🦁", "nature", ["lion"]),
  new h("🐮", "nature", ["cow"]),
  new h("🐷", "nature", ["pig"]),
  new h("🐽", "nature", ["pig_nose"]),
  new h("🐸", "nature", ["frog"]),
  new h("🐵", "nature", ["monkey_face"]),
  new h("🙈", "nature", ["see_no_evil"]),
  new h("🙉", "nature", ["hear_no_evil"]),
  new h("🙊", "nature", ["speak_no_evil"]),
  new h("🐒", "nature", ["monkey"]),
  new h("🐔", "nature", ["chicken"]),
  new h("🐧", "nature", ["penguin"]),
  new h("🐦", "nature", ["bird"]),
  new h("🐤", "nature", ["baby_chick"]),
  new h("🐣", "nature", ["hatching_chick"]),
  new h("🐥", "nature", ["hatched_chick"]),
  new h("🦆", "nature", ["duck"]),
  new h("🦅", "nature", ["eagle"]),
  new h("🦉", "nature", ["owl"]),
  new h("🦇", "nature", ["bat"]),
  new h("🐺", "nature", ["wolf"]),
  new h("🐗", "nature", ["boar"]),
  new h("🐴", "nature", ["horse"]),
  new h("🦄", "nature", ["unicorn"]),
  new h("🐝", "nature", ["bee", "honeybee"]),
  new h("🐛", "nature", ["bug"]),
  new h("🦋", "nature", ["butterfly"]),
  new h("🐌", "nature", ["snail"]),
  new h("🐚", "nature", ["shell"]),
  new h("🐞", "nature", ["beetle"]),
  new h("🐜", "nature", ["ant"]),
  new h("🕷", "nature", ["spider"]),
  new h("🕸", "nature", ["spider_web"]),
  new h("🐢", "nature", ["turtle"]),
  new h("🐍", "nature", ["snake"]),
  new h("🦎", "nature", ["lizard"]),
  new h("🦂", "nature", ["scorpion"]),
  new h("🦀", "nature", ["crab"]),
  new h("🦑", "nature", ["squid"]),
  new h("🐙", "nature", ["octopus"]),
  new h("🦐", "nature", ["shrimp"]),
  new h("🐠", "nature", ["tropical_fish"]),
  new h("🐟", "nature", ["fish"]),
  new h("🐡", "nature", ["blowfish"]),
  new h("🐬", "nature", ["dolphin", "flipper"]),
  new h("🦈", "nature", ["shark"]),
  new h("🐳", "nature", ["whale"]),
  new h("🐋", "nature", ["whale2"]),
  new h("🐊", "nature", ["crocodile"]),
  new h("🐆", "nature", ["leopard"]),
  new h("🐅", "nature", ["tiger2"]),
  new h("🐃", "nature", ["water_buffalo"]),
  new h("🐂", "nature", ["ox"]),
  new h("🐄", "nature", ["cow2"]),
  new h("🦌", "nature", ["deer"]),
  new h("🐪", "nature", ["dromedary_camel"]),
  new h("🐫", "nature", ["camel"]),
  new h("🐘", "nature", ["elephant"]),
  new h("🦏", "nature", ["rhinoceros"]),
  new h("🦍", "nature", ["gorilla"]),
  new h("🐎", "nature", ["racehorse"]),
  new h("🐖", "nature", ["pig2"]),
  new h("🐐", "nature", ["goat"]),
  new h("🐏", "nature", ["ram"]),
  new h("🐑", "nature", ["sheep"]),
  new h("🐕", "nature", ["dog2"]),
  new h("🐩", "nature", ["poodle"]),
  new h("🐈", "nature", ["cat2"]),
  new h("🐓", "nature", ["rooster"]),
  new h("🦃", "nature", ["turkey"]),
  new h("🕊", "nature", ["dove"]),
  new h("🐇", "nature", ["rabbit2"]),
  new h("🐁", "nature", ["mouse2"]),
  new h("🐀", "nature", ["rat"]),
  new h("🐿", "nature", ["chipmunk"]),
  new h("🐾", "nature", ["feet", "paw_prints"]),
  new h("🐉", "nature", ["dragon"]),
  new h("🐲", "nature", ["dragon_face"]),
  new h("🌵", "nature", ["cactus"]),
  new h("🎄", "nature", ["christmas_tree"]),
  new h("🌲", "nature", ["evergreen_tree"]),
  new h("🌳", "nature", ["deciduous_tree"]),
  new h("🌴", "nature", ["palm_tree"]),
  new h("🌱", "nature", ["seedling"]),
  new h("🌿", "nature", ["herb"]),
  new h("☘️", "nature", ["shamrock"]),
  new h("🍀", "nature", ["four_leaf_clover"]),
  new h("🎍", "nature", ["bamboo"]),
  new h("🎋", "nature", ["tanabata_tree"]),
  new h("🍃", "nature", ["leaves"]),
  new h("🍂", "nature", ["fallen_leaf"]),
  new h("🍁", "nature", ["maple_leaf"]),
  new h("🍄", "nature", ["mushroom"]),
  new h("🌾", "nature", ["ear_of_rice"]),
  new h("💐", "nature", ["bouquet"]),
  new h("🌷", "nature", ["tulip"]),
  new h("🌹", "nature", ["rose"]),
  new h("🥀", "nature", ["wilted_flower"]),
  new h("🌻", "nature", ["sunflower"]),
  new h("🌼", "nature", ["blossom"]),
  new h("🌸", "nature", ["cherry_blossom"]),
  new h("🌺", "nature", ["hibiscus"]),
  new h("🌎", "nature", ["earth_americas"]),
  new h("🌍", "nature", ["earth_africa"]),
  new h("🌏", "nature", ["earth_asia"]),
  new h("🌕", "nature", ["full_moon"]),
  new h("🌖", "nature", ["waning_gibbous_moon"]),
  new h("🌗", "nature", ["last_quarter_moon"]),
  new h("🌘", "nature", ["waning_crescent_moon"]),
  new h("🌑", "nature", ["new_moon"]),
  new h("🌒", "nature", ["waxing_crescent_moon"]),
  new h("🌓", "nature", ["first_quarter_moon"]),
  new h("🌔", "nature", ["moon", "waxing_gibbous_moon"]),
  new h("🌚", "nature", ["new_moon_with_face"]),
  new h("🌝", "nature", ["full_moon_with_face"]),
  new h("🌞", "nature", ["sun_with_face"]),
  new h("🌛", "nature", ["first_quarter_moon_with_face"]),
  new h("🌜", "nature", ["last_quarter_moon_with_face"]),
  new h("🌙", "nature", ["crescent_moon"]),
  new h("💫", "nature", ["dizzy"]),
  new h("⭐️", "nature", ["star"]),
  new h("🌟", "nature", ["star2"]),
  new h("✨", "nature", ["sparkles"]),
  new h("⚡️", "nature", ["zap"]),
  new h("🔥", "nature", ["fire"]),
  new h("💥", "nature", ["boom", "collision"]),
  new h("☄", "nature", ["comet"]),
  new h("☀️", "nature", ["sunny"]),
  new h("🌤", "nature", ["sun_behind_small_cloud"]),
  new h("⛅️", "nature", ["partly_sunny"]),
  new h("🌥", "nature", ["sun_behind_large_cloud"]),
  new h("🌦", "nature", ["sun_behind_rain_cloud"]),
  new h("🌈", "nature", ["rainbow"]),
  new h("☁️", "nature", ["cloud"]),
  new h("🌧", "nature", ["cloud_with_rain"]),
  new h("⛈", "nature", ["cloud_with_lightning_and_rain"]),
  new h("🌩", "nature", ["cloud_with_lightning"]),
  new h("🌨", "nature", ["cloud_with_snow"]),
  new h("☃️", "nature", ["snowman_with_snow"]),
  new h("⛄️", "nature", ["snowman"]),
  new h("❄️", "nature", ["snowflake"]),
  new h("🌬", "nature", ["wind_face"]),
  new h("💨", "nature", ["dash"]),
  new h("🌪", "nature", ["tornado"]),
  new h("🌫", "nature", ["fog"]),
  new h("🌊", "nature", ["ocean"]),
  new h("💧", "nature", ["droplet"]),
  new h("💦", "nature", ["sweat_drops"]),
  new h("☔️", "nature", ["umbrella"]),
  new h("🍏", "foods", ["green_apple"]),
  new h("🍎", "foods", ["apple"]),
  new h("🍐", "foods", ["pear"]),
  new h("🍊", "foods", ["tangerine", "orange", "mandarin"]),
  new h("🍋", "foods", ["lemon"]),
  new h("🍌", "foods", ["banana"]),
  new h("🍉", "foods", ["watermelon"]),
  new h("🍇", "foods", ["grapes"]),
  new h("🍓", "foods", ["strawberry"]),
  new h("🍈", "foods", ["melon"]),
  new h("🍒", "foods", ["cherries"]),
  new h("🍑", "foods", ["peach"]),
  new h("🍍", "foods", ["pineapple"]),
  new h("🥝", "foods", ["kiwi_fruit"]),
  new h("🥑", "foods", ["avocado"]),
  new h("🍅", "foods", ["tomato"]),
  new h("🍆", "foods", ["eggplant"]),
  new h("🥒", "foods", ["cucumber"]),
  new h("🥕", "foods", ["carrot"]),
  new h("🌽", "foods", ["corn"]),
  new h("🌶", "foods", ["hot_pepper"]),
  new h("🥔", "foods", ["potato"]),
  new h("🍠", "foods", ["sweet_potato"]),
  new h("🌰", "foods", ["chestnut"]),
  new h("🥜", "foods", ["peanuts"]),
  new h("🍯", "foods", ["honey_pot"]),
  new h("🥐", "foods", ["croissant"]),
  new h("🍞", "foods", ["bread"]),
  new h("🥖", "foods", ["baguette_bread"]),
  new h("🧀", "foods", ["cheese"]),
  new h("🥚", "foods", ["egg"]),
  new h("🍳", "foods", ["fried_egg"]),
  new h("🥓", "foods", ["bacon"]),
  new h("🥞", "foods", ["pancakes"]),
  new h("🍤", "foods", ["fried_shrimp"]),
  new h("🍗", "foods", ["poultry_leg"]),
  new h("🍖", "foods", ["meat_on_bone"]),
  new h("🍕", "foods", ["pizza"]),
  new h("🌭", "foods", ["hotdog"]),
  new h("🍔", "foods", ["hamburger"]),
  new h("🍟", "foods", ["fries"]),
  new h("🥙", "foods", ["stuffed_flatbread"]),
  new h("🌮", "foods", ["taco"]),
  new h("🌯", "foods", ["burrito"]),
  new h("🥗", "foods", ["green_salad"]),
  new h("🥘", "foods", ["shallow_pan_of_food"]),
  new h("🍝", "foods", ["spaghetti"]),
  new h("🍜", "foods", ["ramen"]),
  new h("🍲", "foods", ["stew"]),
  new h("🍥", "foods", ["fish_cake"]),
  new h("🍣", "foods", ["sushi"]),
  new h("🍱", "foods", ["bento"]),
  new h("🍛", "foods", ["curry"]),
  new h("🍚", "foods", ["rice"]),
  new h("🍙", "foods", ["rice_ball"]),
  new h("🍘", "foods", ["rice_cracker"]),
  new h("🍢", "foods", ["oden"]),
  new h("🍡", "foods", ["dango"]),
  new h("🍧", "foods", ["shaved_ice"]),
  new h("🍨", "foods", ["ice_cream"]),
  new h("🍦", "foods", ["icecream"]),
  new h("🍰", "foods", ["cake"]),
  new h("🎂", "foods", ["birthday"]),
  new h("🍮", "foods", ["custard"]),
  new h("🍭", "foods", ["lollipop"]),
  new h("🍬", "foods", ["candy"]),
  new h("🍫", "foods", ["chocolate_bar"]),
  new h("🍿", "foods", ["popcorn"]),
  new h("🍩", "foods", ["doughnut"]),
  new h("🍪", "foods", ["cookie"]),
  new h("🥛", "foods", ["milk_glass"]),
  new h("🍼", "foods", ["baby_bottle"]),
  new h("☕️", "foods", ["coffee"]),
  new h("🍵", "foods", ["tea"]),
  new h("🍶", "foods", ["sake"]),
  new h("🍺", "foods", ["beer"]),
  new h("🍻", "foods", ["beers"]),
  new h("🥂", "foods", ["clinking_glasses"]),
  new h("🍷", "foods", ["wine_glass"]),
  new h("🥃", "foods", ["tumbler_glass"]),
  new h("🍸", "foods", ["cocktail"]),
  new h("🍹", "foods", ["tropical_drink"]),
  new h("🍾", "foods", ["champagne"]),
  new h("🥄", "foods", ["spoon"]),
  new h("🍴", "foods", ["fork_and_knife"]),
  new h("🍽", "foods", ["plate_with_cutlery"]),
  new h("⚽️", "activity", ["soccer"]),
  new h("🏀", "activity", ["basketball"]),
  new h("🏈", "activity", ["football"]),
  new h("⚾️", "activity", ["baseball"]),
  new h("🎾", "activity", ["tennis"]),
  new h("🏐", "activity", ["volleyball"]),
  new h("🏉", "activity", ["rugby_football"]),
  new h("🎱", "activity", ["8ball"]),
  new h("🏓", "activity", ["ping_pong"]),
  new h("🏸", "activity", ["badminton"]),
  new h("🥅", "activity", ["goal_net"]),
  new h("🏒", "activity", ["ice_hockey"]),
  new h("🏑", "activity", ["field_hockey"]),
  new h("🏏", "activity", ["cricket"]),
  new h("⛳️", "activity", ["golf"]),
  new h("🏹", "activity", ["bow_and_arrow"]),
  new h("🎣", "activity", ["fishing_pole_and_fish"]),
  new h("🥊", "activity", ["boxing_glove"]),
  new h("🥋", "activity", ["martial_arts_uniform"]),
  new h("⛸", "activity", ["ice_skate"]),
  new h("🎿", "activity", ["ski"]),
  new h("⛷", "activity", ["skier"]),
  new h("🏂", "activity", ["snowboarder"]),
  new h("🏋️‍♀️", "activity", ["weight_lifting_woman"]),
  new h("🏋", "activity", ["weight_lifting_man"]),
  new h("🤺", "activity", ["person_fencing"]),
  new h("🤼‍♀", "activity", ["women_wrestling"]),
  new h("🤼‍♂", "activity", ["men_wrestling"]),
  new h("🤸‍♀", "activity", ["woman_cartwheeling"]),
  new h("🤸‍♂", "activity", ["man_cartwheeling"]),
  new h("⛹️‍♀️", "activity", ["basketball_woman"]),
  new h("⛹", "activity", ["basketball_man"]),
  new h("🤾‍♀", "activity", ["woman_playing_handball"]),
  new h("🤾‍♂", "activity", ["man_playing_handball"]),
  new h("🏌️‍♀️", "activity", ["golfing_woman"]),
  new h("🏌", "activity", ["golfing_man"]),
  new h("🏄‍♀", "activity", ["surfing_woman"]),
  new h("🏄", "activity", ["surfing_man", "surfer"]),
  new h("🏊‍♀", "activity", ["swimming_woman"]),
  new h("🏊", "activity", ["swimming_man", "swimmer"]),
  new h("🤽‍♀", "activity", ["woman_playing_water_polo"]),
  new h("🤽‍♂", "activity", ["man_playing_water_polo"]),
  new h("🚣‍♀", "activity", ["rowing_woman"]),
  new h("🚣", "activity", ["rowing_man", "rowboat"]),
  new h("🏇", "activity", ["horse_racing"]),
  new h("🚴‍♀", "activity", ["biking_woman"]),
  new h("🚴", "activity", ["biking_man", "bicyclist"]),
  new h("🚵‍♀", "activity", ["mountain_biking_woman"]),
  new h("🚵", "activity", ["mountain_biking_man", "mountain_bicyclist"]),
  new h("🎽", "activity", ["running_shirt_with_sash"]),
  new h("🏅", "activity", ["medal_sports"]),
  new h("🎖", "activity", ["medal_military"]),
  new h("🥇", "activity", ["1st_place_medal"]),
  new h("🥈", "activity", ["2nd_place_medal"]),
  new h("🥉", "activity", ["3rd_place_medal"]),
  new h("🏆", "activity", ["trophy"]),
  new h("🏵", "activity", ["rosette"]),
  new h("🎗", "activity", ["reminder_ribbon"]),
  new h("🎫", "activity", ["ticket"]),
  new h("🎟", "activity", ["tickets"]),
  new h("🎪", "activity", ["circus_tent"]),
  new h("🤹‍♀", "activity", ["woman_juggling"]),
  new h("🤹‍♂", "activity", ["man_juggling"]),
  new h("🎭", "activity", ["performing_arts"]),
  new h("🎨", "activity", ["art"]),
  new h("🎬", "activity", ["clapper"]),
  new h("🎤", "activity", ["microphone"]),
  new h("🎧", "activity", ["headphones"]),
  new h("🎼", "activity", ["musical_score"]),
  new h("🎹", "activity", ["musical_keyboard"]),
  new h("🥁", "activity", ["drum"]),
  new h("🎷", "activity", ["saxophone"]),
  new h("🎺", "activity", ["trumpet"]),
  new h("🎸", "activity", ["guitar"]),
  new h("🎻", "activity", ["violin"]),
  new h("🎲", "activity", ["game_die"]),
  new h("🎯", "activity", ["dart"]),
  new h("🎳", "activity", ["bowling"]),
  new h("🎮", "activity", ["video_game"]),
  new h("🎰", "activity", ["slot_machine"]),
  new h("🚗", "places", ["car", "red_car"]),
  new h("🚕", "places", ["taxi"]),
  new h("🚙", "places", ["blue_car"]),
  new h("🚌", "places", ["bus"]),
  new h("🚎", "places", ["trolleybus"]),
  new h("🏎", "places", ["racing_car"]),
  new h("🚓", "places", ["police_car"]),
  new h("🚑", "places", ["ambulance"]),
  new h("🚒", "places", ["fire_engine"]),
  new h("🚐", "places", ["minibus"]),
  new h("🚚", "places", ["truck"]),
  new h("🚛", "places", ["articulated_lorry"]),
  new h("🚜", "places", ["tractor"]),
  new h("🛴", "places", ["kick_scooter"]),
  new h("🚲", "places", ["bike"]),
  new h("🛵", "places", ["motor_scooter"]),
  new h("🏍", "places", ["motorcycle"]),
  new h("🚨", "places", ["rotating_light"]),
  new h("🚔", "places", ["oncoming_police_car"]),
  new h("🚍", "places", ["oncoming_bus"]),
  new h("🚘", "places", ["oncoming_automobile"]),
  new h("🚖", "places", ["oncoming_taxi"]),
  new h("🚡", "places", ["aerial_tramway"]),
  new h("🚠", "places", ["mountain_cableway"]),
  new h("🚟", "places", ["suspension_railway"]),
  new h("🚃", "places", ["railway_car"]),
  new h("🚋", "places", ["train"]),
  new h("🚞", "places", ["mountain_railway"]),
  new h("🚝", "places", ["monorail"]),
  new h("🚄", "places", ["bullettrain_side"]),
  new h("🚅", "places", ["bullettrain_front"]),
  new h("🚈", "places", ["light_rail"]),
  new h("🚂", "places", ["steam_locomotive"]),
  new h("🚆", "places", ["train2"]),
  new h("🚇", "places", ["metro"]),
  new h("🚊", "places", ["tram"]),
  new h("🚉", "places", ["station"]),
  new h("🚁", "places", ["helicopter"]),
  new h("🛩", "places", ["small_airplane"]),
  new h("✈️", "places", ["airplane"]),
  new h("🛫", "places", ["flight_departure"]),
  new h("🛬", "places", ["flight_arrival"]),
  new h("🚀", "places", ["rocket"]),
  new h("🛰", "places", ["artificial_satellite"]),
  new h("💺", "places", ["seat"]),
  new h("🛶", "places", ["canoe"]),
  new h("⛵️", "places", ["boat", "sailboat"]),
  new h("🛥", "places", ["motor_boat"]),
  new h("🚤", "places", ["speedboat"]),
  new h("🛳", "places", ["passenger_ship"]),
  new h("⛴", "places", ["ferry"]),
  new h("🚢", "places", ["ship"]),
  new h("⚓️", "places", ["anchor"]),
  new h("🚧", "places", ["construction"]),
  new h("⛽️", "places", ["fuelpump"]),
  new h("🚏", "places", ["busstop"]),
  new h("🚦", "places", ["vertical_traffic_light"]),
  new h("🚥", "places", ["traffic_light"]),
  new h("🗺", "places", ["world_map"]),
  new h("🗿", "places", ["moyai"]),
  new h("🗽", "places", ["statue_of_liberty"]),
  new h("⛲️", "places", ["fountain"]),
  new h("🗼", "places", ["tokyo_tower"]),
  new h("🏰", "places", ["european_castle"]),
  new h("🏯", "places", ["japanese_castle"]),
  new h("🏟", "places", ["stadium"]),
  new h("🎡", "places", ["ferris_wheel"]),
  new h("🎢", "places", ["roller_coaster"]),
  new h("🎠", "places", ["carousel_horse"]),
  new h("⛱", "places", ["parasol_on_ground"]),
  new h("🏖", "places", ["beach_umbrella"]),
  new h("🏝", "places", ["desert_island"]),
  new h("⛰", "places", ["mountain"]),
  new h("🏔", "places", ["mountain_snow"]),
  new h("🗻", "places", ["mount_fuji"]),
  new h("🌋", "places", ["volcano"]),
  new h("🏜", "places", ["desert"]),
  new h("🏕", "places", ["camping"]),
  new h("⛺️", "places", ["tent"]),
  new h("🛤", "places", ["railway_track"]),
  new h("🛣", "places", ["motorway"]),
  new h("🏗", "places", ["building_construction"]),
  new h("🏭", "places", ["factory"]),
  new h("🏠", "places", ["house"]),
  new h("🏡", "places", ["house_with_garden"]),
  new h("🏘", "places", ["houses"]),
  new h("🏚", "places", ["derelict_house"]),
  new h("🏢", "places", ["office"]),
  new h("🏬", "places", ["department_store"]),
  new h("🏣", "places", ["post_office"]),
  new h("🏤", "places", ["european_post_office"]),
  new h("🏥", "places", ["hospital"]),
  new h("🏦", "places", ["bank"]),
  new h("🏨", "places", ["hotel"]),
  new h("🏪", "places", ["convenience_store"]),
  new h("🏫", "places", ["school"]),
  new h("🏩", "places", ["love_hotel"]),
  new h("💒", "places", ["wedding"]),
  new h("🏛", "places", ["classical_building"]),
  new h("⛪️", "places", ["church"]),
  new h("🕌", "places", ["mosque"]),
  new h("🕍", "places", ["synagogue"]),
  new h("🕋", "places", ["kaaba"]),
  new h("⛩", "places", ["shinto_shrine"]),
  new h("🗾", "places", ["japan"]),
  new h("🎑", "places", ["rice_scene"]),
  new h("🏞", "places", ["national_park"]),
  new h("🌅", "places", ["sunrise"]),
  new h("🌄", "places", ["sunrise_over_mountains"]),
  new h("🌠", "places", ["stars"]),
  new h("🎇", "places", ["sparkler"]),
  new h("🎆", "places", ["fireworks"]),
  new h("🌇", "places", ["city_sunrise"]),
  new h("🌆", "places", ["city_sunset"]),
  new h("🏙", "places", ["cityscape"]),
  new h("🌃", "places", ["night_with_stars"]),
  new h("🌌", "places", ["milky_way"]),
  new h("🌉", "places", ["bridge_at_night"]),
  new h("🌁", "places", ["foggy"]),
  new h("⌚️", "objects", ["watch"]),
  new h("📱", "objects", ["iphone"]),
  new h("📲", "objects", ["calling"]),
  new h("💻", "objects", ["computer"]),
  new h("⌨️", "objects", ["keyboard"]),
  new h("🖥", "objects", ["desktop_computer"]),
  new h("🖨", "objects", ["printer"]),
  new h("🖱", "objects", ["computer_mouse"]),
  new h("🖲", "objects", ["trackball"]),
  new h("🕹", "objects", ["joystick"]),
  new h("🗜", "objects", ["clamp"]),
  new h("💽", "objects", ["minidisc"]),
  new h("💾", "objects", ["floppy_disk"]),
  new h("💿", "objects", ["cd"]),
  new h("📀", "objects", ["dvd"]),
  new h("📼", "objects", ["vhs"]),
  new h("📷", "objects", ["camera"]),
  new h("📸", "objects", ["camera_flash"]),
  new h("📹", "objects", ["video_camera"]),
  new h("🎥", "objects", ["movie_camera"]),
  new h("📽", "objects", ["film_projector"]),
  new h("🎞", "objects", ["film_strip"]),
  new h("📞", "objects", ["telephone_receiver"]),
  new h("☎️", "objects", ["phone", "telephone"]),
  new h("📟", "objects", ["pager"]),
  new h("📠", "objects", ["fax"]),
  new h("📺", "objects", ["tv"]),
  new h("📻", "objects", ["radio"]),
  new h("🎙", "objects", ["studio_microphone"]),
  new h("🎚", "objects", ["level_slider"]),
  new h("🎛", "objects", ["control_knobs"]),
  new h("⏱", "objects", ["stopwatch"]),
  new h("⏲", "objects", ["timer_clock"]),
  new h("⏰", "objects", ["alarm_clock"]),
  new h("🕰", "objects", ["mantelpiece_clock"]),
  new h("⌛️", "objects", ["hourglass"]),
  new h("⏳", "objects", ["hourglass_flowing_sand"]),
  new h("📡", "objects", ["satellite"]),
  new h("🔋", "objects", ["battery"]),
  new h("🔌", "objects", ["electric_plug"]),
  new h("💡", "objects", ["bulb"]),
  new h("🔦", "objects", ["flashlight"]),
  new h("🕯", "objects", ["candle"]),
  new h("🗑", "objects", ["wastebasket"]),
  new h("🛢", "objects", ["oil_drum"]),
  new h("💸", "objects", ["money_with_wings"]),
  new h("💵", "objects", ["dollar"]),
  new h("💴", "objects", ["yen"]),
  new h("💶", "objects", ["euro"]),
  new h("💷", "objects", ["pound"]),
  new h("💰", "objects", ["moneybag"]),
  new h("💳", "objects", ["credit_card"]),
  new h("💎", "objects", ["gem"]),
  new h("⚖️", "objects", ["balance_scale"]),
  new h("🔧", "objects", ["wrench"]),
  new h("🔨", "objects", ["hammer"]),
  new h("⚒", "objects", ["hammer_and_pick"]),
  new h("🛠", "objects", ["hammer_and_wrench"]),
  new h("⛏", "objects", ["pick"]),
  new h("🔩", "objects", ["nut_and_bolt"]),
  new h("⚙️", "objects", ["gear"]),
  new h("⛓", "objects", ["chains"]),
  new h("🔫", "objects", ["gun"]),
  new h("💣", "objects", ["bomb"]),
  new h("🔪", "objects", ["hocho", "knife"]),
  new h("🗡", "objects", ["dagger"]),
  new h("⚔️", "objects", ["crossed_swords"]),
  new h("🛡", "objects", ["shield"]),
  new h("🚬", "objects", ["smoking"]),
  new h("⚰️", "objects", ["coffin"]),
  new h("⚱️", "objects", ["funeral_urn"]),
  new h("🏺", "objects", ["amphora"]),
  new h("🔮", "objects", ["crystal_ball"]),
  new h("📿", "objects", ["prayer_beads"]),
  new h("💈", "objects", ["barber"]),
  new h("⚗️", "objects", ["alembic"]),
  new h("🔭", "objects", ["telescope"]),
  new h("🔬", "objects", ["microscope"]),
  new h("🕳", "objects", ["hole"]),
  new h("💊", "objects", ["pill"]),
  new h("💉", "objects", ["syringe"]),
  new h("🌡", "objects", ["thermometer"]),
  new h("🚽", "objects", ["toilet"]),
  new h("🚰", "objects", ["potable_water"]),
  new h("🚿", "objects", ["shower"]),
  new h("🛁", "objects", ["bathtub"]),
  new h("🛀", "objects", ["bath"]),
  new h("🛎", "objects", ["bellhop_bell"]),
  new h("🔑", "objects", ["key"]),
  new h("🗝", "objects", ["old_key"]),
  new h("🚪", "objects", ["door"]),
  new h("🛋", "objects", ["couch_and_lamp"]),
  new h("🛏", "objects", ["bed"]),
  new h("🛌", "objects", ["sleeping_bed"]),
  new h("🖼", "objects", ["framed_picture"]),
  new h("🛍", "objects", ["shopping"]),
  new h("🛒", "objects", ["shopping_cart"]),
  new h("🎁", "objects", ["gift"]),
  new h("🎈", "objects", ["balloon"]),
  new h("🎏", "objects", ["flags"]),
  new h("🎀", "objects", ["ribbon"]),
  new h("🎊", "objects", ["confetti_ball"]),
  new h("🎉", "objects", ["tada"]),
  new h("🎎", "objects", ["dolls"]),
  new h("🏮", "objects", ["izakaya_lantern", "lantern"]),
  new h("🎐", "objects", ["wind_chime"]),
  new h("✉️", "objects", ["email", "envelope"]),
  new h("📩", "objects", ["envelope_with_arrow"]),
  new h("📨", "objects", ["incoming_envelope"]),
  new h("📧", "objects", ["e-mail"]),
  new h("💌", "objects", ["love_letter"]),
  new h("📥", "objects", ["inbox_tray"]),
  new h("📤", "objects", ["outbox_tray"]),
  new h("📦", "objects", ["package"]),
  new h("🏷", "objects", ["label"]),
  new h("📪", "objects", ["mailbox_closed"]),
  new h("📫", "objects", ["mailbox"]),
  new h("📬", "objects", ["mailbox_with_mail"]),
  new h("📭", "objects", ["mailbox_with_no_mail"]),
  new h("📮", "objects", ["postbox"]),
  new h("📯", "objects", ["postal_horn"]),
  new h("📜", "objects", ["scroll"]),
  new h("📃", "objects", ["page_with_curl"]),
  new h("📄", "objects", ["page_facing_up"]),
  new h("📑", "objects", ["bookmark_tabs"]),
  new h("📊", "objects", ["bar_chart"]),
  new h("📈", "objects", ["chart_with_upwards_trend"]),
  new h("📉", "objects", ["chart_with_downwards_trend"]),
  new h("🗒", "objects", ["spiral_notepad"]),
  new h("🗓", "objects", ["spiral_calendar"]),
  new h("📆", "objects", ["calendar"]),
  new h("📅", "objects", ["date"]),
  new h("📇", "objects", ["card_index"]),
  new h("🗃", "objects", ["card_file_box"]),
  new h("🗳", "objects", ["ballot_box"]),
  new h("🗄", "objects", ["file_cabinet"]),
  new h("📋", "objects", ["clipboard"]),
  new h("📁", "objects", ["file_folder"]),
  new h("📂", "objects", ["open_file_folder"]),
  new h("🗂", "objects", ["card_index_dividers"]),
  new h("🗞", "objects", ["newspaper_roll"]),
  new h("📰", "objects", ["newspaper"]),
  new h("📓", "objects", ["notebook"]),
  new h("📔", "objects", ["notebook_with_decorative_cover"]),
  new h("📒", "objects", ["ledger"]),
  new h("📕", "objects", ["closed_book"]),
  new h("📗", "objects", ["green_book"]),
  new h("📘", "objects", ["blue_book"]),
  new h("📙", "objects", ["orange_book"]),
  new h("📚", "objects", ["books"]),
  new h("📖", "objects", ["book", "open_book"]),
  new h("🔖", "objects", ["bookmark"]),
  new h("🔗", "objects", ["link"]),
  new h("📎", "objects", ["paperclip"]),
  new h("🖇", "objects", ["paperclips"]),
  new h("📐", "objects", ["triangular_ruler"]),
  new h("📏", "objects", ["straight_ruler"]),
  new h("📌", "objects", ["pushpin"]),
  new h("📍", "objects", ["round_pushpin"]),
  new h("✂️", "objects", ["scissors"]),
  new h("🖊", "objects", ["pen"]),
  new h("🖋", "objects", ["fountain_pen"]),
  new h("✒️", "objects", ["black_nib"]),
  new h("🖌", "objects", ["paintbrush"]),
  new h("🖍", "objects", ["crayon"]),
  new h("📝", "objects", ["memo", "pencil"]),
  new h("✏️", "objects", ["pencil2"]),
  new h("🔍", "objects", ["mag"]),
  new h("🔎", "objects", ["mag_right"]),
  new h("🔏", "objects", ["lock_with_ink_pen"]),
  new h("🔐", "objects", ["closed_lock_with_key"]),
  new h("🔒", "objects", ["lock"]),
  new h("🔓", "objects", ["unlock"]),
  new h("❤️", "symbols", ["heart"]),
  new h("💛", "symbols", ["yellow_heart"]),
  new h("💚", "symbols", ["green_heart"]),
  new h("💙", "symbols", ["blue_heart"]),
  new h("💜", "symbols", ["purple_heart"]),
  new h("🖤", "symbols", ["black_heart"]),
  new h("💔", "symbols", ["broken_heart"]),
  new h("❣️", "symbols", ["heavy_heart_exclamation"]),
  new h("💕", "symbols", ["two_hearts"]),
  new h("💞", "symbols", ["revolving_hearts"]),
  new h("💓", "symbols", ["heartbeat"]),
  new h("💗", "symbols", ["heartpulse"]),
  new h("💖", "symbols", ["sparkling_heart"]),
  new h("💘", "symbols", ["cupid"]),
  new h("💝", "symbols", ["gift_heart"]),
  new h("💟", "symbols", ["heart_decoration"]),
  new h("☮️", "symbols", ["peace_symbol"]),
  new h("✝️", "symbols", ["latin_cross"]),
  new h("☪️", "symbols", ["star_and_crescent"]),
  new h("🕉", "symbols", ["om"]),
  new h("☸️", "symbols", ["wheel_of_dharma"]),
  new h("✡️", "symbols", ["star_of_david"]),
  new h("🔯", "symbols", ["six_pointed_star"]),
  new h("🕎", "symbols", ["menorah"]),
  new h("☯️", "symbols", ["yin_yang"]),
  new h("☦️", "symbols", ["orthodox_cross"]),
  new h("🛐", "symbols", ["place_of_worship"]),
  new h("⛎", "symbols", ["ophiuchus"]),
  new h("♈️", "symbols", ["aries"]),
  new h("♉️", "symbols", ["taurus"]),
  new h("♊️", "symbols", ["gemini"]),
  new h("♋️", "symbols", ["cancer"]),
  new h("♌️", "symbols", ["leo"]),
  new h("♍️", "symbols", ["virgo"]),
  new h("♎️", "symbols", ["libra"]),
  new h("♏️", "symbols", ["scorpius"]),
  new h("♐️", "symbols", ["sagittarius"]),
  new h("♑️", "symbols", ["capricorn"]),
  new h("♒️", "symbols", ["aquarius"]),
  new h("♓️", "symbols", ["pisces"]),
  new h("🆔", "symbols", ["id"]),
  new h("⚛️", "symbols", ["atom_symbol"]),
  new h("🉑", "symbols", ["accept"]),
  new h("☢️", "symbols", ["radioactive"]),
  new h("☣️", "symbols", ["biohazard"]),
  new h("📴", "symbols", ["mobile_phone_off"]),
  new h("📳", "symbols", ["vibration_mode"]),
  new h("🈶", "symbols", ["u6709"]),
  new h("🈚️", "symbols", ["u7121"]),
  new h("🈸", "symbols", ["u7533"]),
  new h("🈺", "symbols", ["u55b6"]),
  new h("🈷️", "symbols", ["u6708"]),
  new h("✴️", "symbols", ["eight_pointed_black_star"]),
  new h("🆚", "symbols", ["vs"]),
  new h("💮", "symbols", ["white_flower"]),
  new h("🉐", "symbols", ["ideograph_advantage"]),
  new h("㊙️", "symbols", ["secret"]),
  new h("㊗️", "symbols", ["congratulations"]),
  new h("🈴", "symbols", ["u5408"]),
  new h("🈵", "symbols", ["u6e80"]),
  new h("🈹", "symbols", ["u5272"]),
  new h("🈲", "symbols", ["u7981"]),
  new h("🅰️", "symbols", ["a"]),
  new h("🅱️", "symbols", ["b"]),
  new h("🆎", "symbols", ["ab"]),
  new h("🆑", "symbols", ["cl"]),
  new h("🅾️", "symbols", ["o2"]),
  new h("🆘", "symbols", ["sos"]),
  new h("❌", "symbols", ["x"]),
  new h("⭕️", "symbols", ["o"]),
  new h("🛑", "symbols", ["stop_sign"]),
  new h("⛔️", "symbols", ["no_entry"]),
  new h("📛", "symbols", ["name_badge"]),
  new h("🚫", "symbols", ["no_entry_sign"]),
  new h("💯", "symbols", ["100"]),
  new h("💢", "symbols", ["anger"]),
  new h("♨️", "symbols", ["hotsprings"]),
  new h("🚷", "symbols", ["no_pedestrians"]),
  new h("🚯", "symbols", ["do_not_litter"]),
  new h("🚳", "symbols", ["no_bicycles"]),
  new h("🚱", "symbols", ["non-potable_water"]),
  new h("🔞", "symbols", ["underage"]),
  new h("📵", "symbols", ["no_mobile_phones"]),
  new h("🚭", "symbols", ["no_smoking"]),
  new h("❗️", "symbols", ["exclamation", "heavy_exclamation_mark"]),
  new h("❕", "symbols", ["grey_exclamation"]),
  new h("❓", "symbols", ["question"]),
  new h("❔", "symbols", ["grey_question"]),
  new h("‼️", "symbols", ["bangbang"]),
  new h("⁉️", "symbols", ["interrobang"]),
  new h("🔅", "symbols", ["low_brightness"]),
  new h("🔆", "symbols", ["high_brightness"]),
  new h("〽️", "symbols", ["part_alternation_mark"]),
  new h("⚠️", "symbols", ["warning"]),
  new h("🚸", "symbols", ["children_crossing"]),
  new h("🔱", "symbols", ["trident"]),
  new h("⚜️", "symbols", ["fleur_de_lis"]),
  new h("🔰", "symbols", ["beginner"]),
  new h("♻️", "symbols", ["recycle"]),
  new h("✅", "symbols", ["white_check_mark"]),
  new h("🈯️", "symbols", ["u6307"]),
  new h("💹", "symbols", ["chart"]),
  new h("❇️", "symbols", ["sparkle"]),
  new h("✳️", "symbols", ["eight_spoked_asterisk"]),
  new h("❎", "symbols", ["negative_squared_cross_mark"]),
  new h("🌐", "symbols", ["globe_with_meridians"]),
  new h("💠", "symbols", ["diamond_shape_with_a_dot_inside"]),
  new h("Ⓜ️", "symbols", ["m"]),
  new h("🌀", "symbols", ["cyclone"]),
  new h("💤", "symbols", ["zzz"]),
  new h("🏧", "symbols", ["atm"]),
  new h("🚾", "symbols", ["wc"]),
  new h("♿️", "symbols", ["wheelchair"]),
  new h("🅿️", "symbols", ["parking"]),
  new h("🈳", "symbols", ["u7a7a"]),
  new h("🈂️", "symbols", ["sa"]),
  new h("🛂", "symbols", ["passport_control"]),
  new h("🛃", "symbols", ["customs"]),
  new h("🛄", "symbols", ["baggage_claim"]),
  new h("🛅", "symbols", ["left_luggage"]),
  new h("🚹", "symbols", ["mens"]),
  new h("🚺", "symbols", ["womens"]),
  new h("🚼", "symbols", ["baby_symbol"]),
  new h("🚻", "symbols", ["restroom"]),
  new h("🚮", "symbols", ["put_litter_in_its_place"]),
  new h("🎦", "symbols", ["cinema"]),
  new h("📶", "symbols", ["signal_strength"]),
  new h("🈁", "symbols", ["koko"]),
  new h("🔣", "symbols", ["symbols"]),
  new h("ℹ️", "symbols", ["information_source"]),
  new h("🔤", "symbols", ["abc"]),
  new h("🔡", "symbols", ["abcd"]),
  new h("🔠", "symbols", ["capital_abcd"]),
  new h("🆖", "symbols", ["ng"]),
  new h("🆗", "symbols", ["ok"]),
  new h("🆙", "symbols", ["up"]),
  new h("🆒", "symbols", ["cool"]),
  new h("🆕", "symbols", ["new"]),
  new h("🆓", "symbols", ["free"]),
  new h("0️⃣", "symbols", ["zero"]),
  new h("1️⃣", "symbols", ["one"]),
  new h("2️⃣", "symbols", ["two"]),
  new h("3️⃣", "symbols", ["three"]),
  new h("4️⃣", "symbols", ["four"]),
  new h("5️⃣", "symbols", ["five"]),
  new h("6️⃣", "symbols", ["six"]),
  new h("7️⃣", "symbols", ["seven"]),
  new h("8️⃣", "symbols", ["eight"]),
  new h("9️⃣", "symbols", ["nine"]),
  new h("🔟", "symbols", ["keycap_ten"]),
  new h("🔢", "symbols", ["1234"]),
  new h("#️⃣", "symbols", ["hash"]),
  new h("*️⃣", "symbols", ["asterisk"]),
  new h("▶️", "symbols", ["arrow_forward"]),
  new h("⏸", "symbols", ["pause_button"]),
  new h("⏯", "symbols", ["play_or_pause_button"]),
  new h("⏹", "symbols", ["stop_button"]),
  new h("⏺", "symbols", ["record_button"]),
  new h("⏭", "symbols", ["next_track_button"]),
  new h("⏮", "symbols", ["previous_track_button"]),
  new h("⏩", "symbols", ["fast_forward"]),
  new h("⏪", "symbols", ["rewind"]),
  new h("⏫", "symbols", ["arrow_double_up"]),
  new h("⏬", "symbols", ["arrow_double_down"]),
  new h("◀️", "symbols", ["arrow_backward"]),
  new h("🔼", "symbols", ["arrow_up_small"]),
  new h("🔽", "symbols", ["arrow_down_small"]),
  new h("➡️", "symbols", ["arrow_right"]),
  new h("⬅️", "symbols", ["arrow_left"]),
  new h("⬆️", "symbols", ["arrow_up"]),
  new h("⬇️", "symbols", ["arrow_down"]),
  new h("↗️", "symbols", ["arrow_upper_right"]),
  new h("↘️", "symbols", ["arrow_lower_right"]),
  new h("↙️", "symbols", ["arrow_lower_left"]),
  new h("↖️", "symbols", ["arrow_upper_left"]),
  new h("↕️", "symbols", ["arrow_up_down"]),
  new h("↔️", "symbols", ["left_right_arrow"]),
  new h("↪️", "symbols", ["arrow_right_hook"]),
  new h("↩️", "symbols", ["leftwards_arrow_with_hook"]),
  new h("⤴️", "symbols", ["arrow_heading_up"]),
  new h("⤵️", "symbols", ["arrow_heading_down"]),
  new h("🔀", "symbols", ["twisted_rightwards_arrows"]),
  new h("🔁", "symbols", ["repeat"]),
  new h("🔂", "symbols", ["repeat_one"]),
  new h("🔄", "symbols", ["arrows_counterclockwise"]),
  new h("🔃", "symbols", ["arrows_clockwise"]),
  new h("🎵", "symbols", ["musical_note"]),
  new h("🎶", "symbols", ["notes"]),
  new h("➕", "symbols", ["heavy_plus_sign"]),
  new h("➖", "symbols", ["heavy_minus_sign"]),
  new h("➗", "symbols", ["heavy_division_sign"]),
  new h("✖️", "symbols", ["heavy_multiplication_x"]),
  new h("💲", "symbols", ["heavy_dollar_sign"]),
  new h("💱", "symbols", ["currency_exchange"]),
  new h("™️", "symbols", ["tm"]),
  new h("©️", "symbols", ["copyright"]),
  new h("®️", "symbols", ["registered"]),
  new h("〰️", "symbols", ["wavy_dash"]),
  new h("➰", "symbols", ["curly_loop"]),
  new h("➿", "symbols", ["loop"]),
  new h("🔚", "symbols", ["end"]),
  new h("🔙", "symbols", ["back"]),
  new h("🔛", "symbols", ["on"]),
  new h("🔝", "symbols", ["top"]),
  new h("🔜", "symbols", ["soon"]),
  new h("✔️", "symbols", ["heavy_check_mark"]),
  new h("☑️", "symbols", ["ballot_box_with_check"]),
  new h("🔘", "symbols", ["radio_button"]),
  new h("⚪️", "symbols", ["white_circle"]),
  new h("⚫️", "symbols", ["black_circle"]),
  new h("🔴", "symbols", ["red_circle"]),
  new h("🔵", "symbols", ["large_blue_circle"]),
  new h("🔺", "symbols", ["small_red_triangle"]),
  new h("🔻", "symbols", ["small_red_triangle_down"]),
  new h("🔸", "symbols", ["small_orange_diamond"]),
  new h("🔹", "symbols", ["small_blue_diamond"]),
  new h("🔶", "symbols", ["large_orange_diamond"]),
  new h("🔷", "symbols", ["large_blue_diamond"]),
  new h("🔳", "symbols", ["white_square_button"]),
  new h("🔲", "symbols", ["black_square_button"]),
  new h("▪️", "symbols", ["black_small_square"]),
  new h("▫️", "symbols", ["white_small_square"]),
  new h("◾️", "symbols", ["black_medium_small_square"]),
  new h("◽️", "symbols", ["white_medium_small_square"]),
  new h("◼️", "symbols", ["black_medium_square"]),
  new h("◻️", "symbols", ["white_medium_square"]),
  new h("⬛️", "symbols", ["black_large_square"]),
  new h("⬜️", "symbols", ["white_large_square"]),
  new h("🔈", "symbols", ["speaker"]),
  new h("🔇", "symbols", ["mute"]),
  new h("🔉", "symbols", ["sound"]),
  new h("🔊", "symbols", ["loud_sound"]),
  new h("🔔", "symbols", ["bell"]),
  new h("🔕", "symbols", ["no_bell"]),
  new h("📣", "symbols", ["mega"]),
  new h("📢", "symbols", ["loudspeaker"]),
  new h("👁‍🗨", "symbols", ["eye_speech_bubble"]),
  new h("💬", "symbols", ["speech_balloon"]),
  new h("💭", "symbols", ["thought_balloon"]),
  new h("🗯", "symbols", ["right_anger_bubble"]),
  new h("♠️", "symbols", ["spades"]),
  new h("♣️", "symbols", ["clubs"]),
  new h("♥️", "symbols", ["hearts"]),
  new h("♦️", "symbols", ["diamonds"]),
  new h("🃏", "symbols", ["black_joker"]),
  new h("🎴", "symbols", ["flower_playing_cards"]),
  new h("🀄️", "symbols", ["mahjong"]),
  new h("🕐", "symbols", ["clock1"]),
  new h("🕑", "symbols", ["clock2"]),
  new h("🕒", "symbols", ["clock3"]),
  new h("🕓", "symbols", ["clock4"]),
  new h("🕔", "symbols", ["clock5"]),
  new h("🕕", "symbols", ["clock6"]),
  new h("🕖", "symbols", ["clock7"]),
  new h("🕗", "symbols", ["clock8"]),
  new h("🕘", "symbols", ["clock9"]),
  new h("🕙", "symbols", ["clock10"]),
  new h("🕚", "symbols", ["clock11"]),
  new h("🕛", "symbols", ["clock12"]),
  new h("🕜", "symbols", ["clock130"]),
  new h("🕝", "symbols", ["clock230"]),
  new h("🕞", "symbols", ["clock330"]),
  new h("🕟", "symbols", ["clock430"]),
  new h("🕠", "symbols", ["clock530"]),
  new h("🕡", "symbols", ["clock630"]),
  new h("🕢", "symbols", ["clock730"]),
  new h("🕣", "symbols", ["clock830"]),
  new h("🕤", "symbols", ["clock930"]),
  new h("🕥", "symbols", ["clock1030"]),
  new h("🕦", "symbols", ["clock1130"]),
  new h("🕧", "symbols", ["clock1230"]),
  new h("🏳️", "flags", ["white_flag"]),
  new h("🏴", "flags", ["black_flag"]),
  new h("🏁", "flags", ["checkered_flag"]),
  new h("🚩", "flags", ["triangular_flag_on_post"]),
  new h("🏳️‍🌈", "flags", ["rainbow_flag"]),
  new h("🇦🇫", "flags", ["afghanistan"]),
  new h("🇦🇽", "flags", ["aland_islands"]),
  new h("🇦🇱", "flags", ["albania"]),
  new h("🇩🇿", "flags", ["algeria"]),
  new h("🇦🇸", "flags", ["american_samoa"]),
  new h("🇦🇩", "flags", ["andorra"]),
  new h("🇦🇴", "flags", ["angola"]),
  new h("🇦🇮", "flags", ["anguilla"]),
  new h("🇦🇶", "flags", ["antarctica"]),
  new h("🇦🇬", "flags", ["antigua_barbuda"]),
  new h("🇦🇷", "flags", ["argentina"]),
  new h("🇦🇲", "flags", ["armenia"]),
  new h("🇦🇼", "flags", ["aruba"]),
  new h("🇦🇺", "flags", ["australia"]),
  new h("🇦🇹", "flags", ["austria"]),
  new h("🇦🇿", "flags", ["azerbaijan"]),
  new h("🇧🇸", "flags", ["bahamas"]),
  new h("🇧🇭", "flags", ["bahrain"]),
  new h("🇧🇩", "flags", ["bangladesh"]),
  new h("🇧🇧", "flags", ["barbados"]),
  new h("🇧🇾", "flags", ["belarus"]),
  new h("🇧🇪", "flags", ["belgium"]),
  new h("🇧🇿", "flags", ["belize"]),
  new h("🇧🇯", "flags", ["benin"]),
  new h("🇧🇲", "flags", ["bermuda"]),
  new h("🇧🇹", "flags", ["bhutan"]),
  new h("🇧🇴", "flags", ["bolivia"]),
  new h("🇧🇶", "flags", ["caribbean_netherlands"]),
  new h("🇧🇦", "flags", ["bosnia_herzegovina"]),
  new h("🇧🇼", "flags", ["botswana"]),
  new h("🇧🇷", "flags", ["brazil"]),
  new h("🇮🇴", "flags", ["british_indian_ocean_territory"]),
  new h("🇻🇬", "flags", ["british_virgin_islands"]),
  new h("🇧🇳", "flags", ["brunei"]),
  new h("🇧🇬", "flags", ["bulgaria"]),
  new h("🇧🇫", "flags", ["burkina_faso"]),
  new h("🇧🇮", "flags", ["burundi"]),
  new h("🇨🇻", "flags", ["cape_verde"]),
  new h("🇰🇭", "flags", ["cambodia"]),
  new h("🇨🇲", "flags", ["cameroon"]),
  new h("🇨🇦", "flags", ["canada"]),
  new h("🇮🇨", "flags", ["canary_islands"]),
  new h("🇰🇾", "flags", ["cayman_islands"]),
  new h("🇨🇫", "flags", ["central_african_republic"]),
  new h("🇹🇩", "flags", ["chad"]),
  new h("🇨🇱", "flags", ["chile"]),
  new h("🇨🇳", "flags", ["cn"]),
  new h("🇨🇽", "flags", ["christmas_island"]),
  new h("🇨🇨", "flags", ["cocos_islands"]),
  new h("🇨🇴", "flags", ["colombia"]),
  new h("🇰🇲", "flags", ["comoros"]),
  new h("🇨🇬", "flags", ["congo_brazzaville"]),
  new h("🇨🇩", "flags", ["congo_kinshasa"]),
  new h("🇨🇰", "flags", ["cook_islands"]),
  new h("🇨🇷", "flags", ["costa_rica"]),
  new h("🇨🇮", "flags", ["cote_divoire"]),
  new h("🇭🇷", "flags", ["croatia"]),
  new h("🇨🇺", "flags", ["cuba"]),
  new h("🇨🇼", "flags", ["curacao"]),
  new h("🇨🇾", "flags", ["cyprus"]),
  new h("🇨🇿", "flags", ["czech_republic"]),
  new h("🇩🇰", "flags", ["denmark"]),
  new h("🇩🇯", "flags", ["djibouti"]),
  new h("🇩🇲", "flags", ["dominica"]),
  new h("🇩🇴", "flags", ["dominican_republic"]),
  new h("🇪🇨", "flags", ["ecuador"]),
  new h("🇪🇬", "flags", ["egypt"]),
  new h("🇸🇻", "flags", ["el_salvador"]),
  new h("🇬🇶", "flags", ["equatorial_guinea"]),
  new h("🇪🇷", "flags", ["eritrea"]),
  new h("🇪🇪", "flags", ["estonia"]),
  new h("🇪🇹", "flags", ["ethiopia"]),
  new h("🇪🇺", "flags", ["eu", "european_union"]),
  new h("🇫🇰", "flags", ["falkland_islands"]),
  new h("🇫🇴", "flags", ["faroe_islands"]),
  new h("🇫🇯", "flags", ["fiji"]),
  new h("🇫🇮", "flags", ["finland"]),
  new h("🇫🇷", "flags", ["fr"]),
  new h("🇬🇫", "flags", ["french_guiana"]),
  new h("🇵🇫", "flags", ["french_polynesia"]),
  new h("🇹🇫", "flags", ["french_southern_territories"]),
  new h("🇬🇦", "flags", ["gabon"]),
  new h("🇬🇲", "flags", ["gambia"]),
  new h("🇬🇪", "flags", ["georgia"]),
  new h("🇩🇪", "flags", ["de"]),
  new h("🇬🇭", "flags", ["ghana"]),
  new h("🇬🇮", "flags", ["gibraltar"]),
  new h("🇬🇷", "flags", ["greece"]),
  new h("🇬🇱", "flags", ["greenland"]),
  new h("🇬🇩", "flags", ["grenada"]),
  new h("🇬🇵", "flags", ["guadeloupe"]),
  new h("🇬🇺", "flags", ["guam"]),
  new h("🇬🇹", "flags", ["guatemala"]),
  new h("🇬🇬", "flags", ["guernsey"]),
  new h("🇬🇳", "flags", ["guinea"]),
  new h("🇬🇼", "flags", ["guinea_bissau"]),
  new h("🇬🇾", "flags", ["guyana"]),
  new h("🇭🇹", "flags", ["haiti"]),
  new h("🇭🇳", "flags", ["honduras"]),
  new h("🇭🇰", "flags", ["hong_kong"]),
  new h("🇭🇺", "flags", ["hungary"]),
  new h("🇮🇸", "flags", ["iceland"]),
  new h("🇮🇳", "flags", ["india"]),
  new h("🇮🇩", "flags", ["indonesia"]),
  new h("🇮🇷", "flags", ["iran"]),
  new h("🇮🇶", "flags", ["iraq"]),
  new h("🇮🇪", "flags", ["ireland"]),
  new h("🇮🇲", "flags", ["isle_of_man"]),
  new h("🇮🇱", "flags", ["israel"]),
  new h("🇮🇹", "flags", ["it"]),
  new h("🇯🇲", "flags", ["jamaica"]),
  new h("🇯🇵", "flags", ["jp"]),
  new h("🎌", "flags", ["crossed_flags"]),
  new h("🇯🇪", "flags", ["jersey"]),
  new h("🇯🇴", "flags", ["jordan"]),
  new h("🇰🇿", "flags", ["kazakhstan"]),
  new h("🇰🇪", "flags", ["kenya"]),
  new h("🇰🇮", "flags", ["kiribati"]),
  new h("🇽🇰", "flags", ["kosovo"]),
  new h("🇰🇼", "flags", ["kuwait"]),
  new h("🇰🇬", "flags", ["kyrgyzstan"]),
  new h("🇱🇦", "flags", ["laos"]),
  new h("🇱🇻", "flags", ["latvia"]),
  new h("🇱🇧", "flags", ["lebanon"]),
  new h("🇱🇸", "flags", ["lesotho"]),
  new h("🇱🇷", "flags", ["liberia"]),
  new h("🇱🇾", "flags", ["libya"]),
  new h("🇱🇮", "flags", ["liechtenstein"]),
  new h("🇱🇹", "flags", ["lithuania"]),
  new h("🇱🇺", "flags", ["luxembourg"]),
  new h("🇲🇴", "flags", ["macau"]),
  new h("🇲🇰", "flags", ["macedonia"]),
  new h("🇲🇬", "flags", ["madagascar"]),
  new h("🇲🇼", "flags", ["malawi"]),
  new h("🇲🇾", "flags", ["malaysia"]),
  new h("🇲🇻", "flags", ["maldives"]),
  new h("🇲🇱", "flags", ["mali"]),
  new h("🇲🇹", "flags", ["malta"]),
  new h("🇲🇭", "flags", ["marshall_islands"]),
  new h("🇲🇶", "flags", ["martinique"]),
  new h("🇲🇷", "flags", ["mauritania"]),
  new h("🇲🇺", "flags", ["mauritius"]),
  new h("🇾🇹", "flags", ["mayotte"]),
  new h("🇲🇽", "flags", ["mexico"]),
  new h("🇫🇲", "flags", ["micronesia"]),
  new h("🇲🇩", "flags", ["moldova"]),
  new h("🇲🇨", "flags", ["monaco"]),
  new h("🇲🇳", "flags", ["mongolia"]),
  new h("🇲🇪", "flags", ["montenegro"]),
  new h("🇲🇸", "flags", ["montserrat"]),
  new h("🇲🇦", "flags", ["morocco"]),
  new h("🇲🇿", "flags", ["mozambique"]),
  new h("🇲🇲", "flags", ["myanmar"]),
  new h("🇳🇦", "flags", ["namibia"]),
  new h("🇳🇷", "flags", ["nauru"]),
  new h("🇳🇵", "flags", ["nepal"]),
  new h("🇳🇱", "flags", ["netherlands"]),
  new h("🇳🇨", "flags", ["new_caledonia"]),
  new h("🇳🇿", "flags", ["new_zealand"]),
  new h("🇳🇮", "flags", ["nicaragua"]),
  new h("🇳🇪", "flags", ["niger"]),
  new h("🇳🇬", "flags", ["nigeria"]),
  new h("🇳🇺", "flags", ["niue"]),
  new h("🇳🇫", "flags", ["norfolk_island"]),
  new h("🇲🇵", "flags", ["northern_mariana_islands"]),
  new h("🇰🇵", "flags", ["north_korea"]),
  new h("🇳🇴", "flags", ["norway"]),
  new h("🇴🇲", "flags", ["oman"]),
  new h("🇵🇰", "flags", ["pakistan"]),
  new h("🇵🇼", "flags", ["palau"]),
  new h("🇵🇸", "flags", ["palestinian_territories"]),
  new h("🇵🇦", "flags", ["panama"]),
  new h("🇵🇬", "flags", ["papua_new_guinea"]),
  new h("🇵🇾", "flags", ["paraguay"]),
  new h("🇵🇪", "flags", ["peru"]),
  new h("🇵🇭", "flags", ["philippines"]),
  new h("🇵🇳", "flags", ["pitcairn_islands"]),
  new h("🇵🇱", "flags", ["poland"]),
  new h("🇵🇹", "flags", ["portugal"]),
  new h("🇵🇷", "flags", ["puerto_rico"]),
  new h("🇶🇦", "flags", ["qatar"]),
  new h("🇷🇪", "flags", ["reunion"]),
  new h("🇷🇴", "flags", ["romania"]),
  new h("🇷🇺", "flags", ["ru"]),
  new h("🇷🇼", "flags", ["rwanda"]),
  new h("🇧🇱", "flags", ["st_barthelemy"]),
  new h("🇸🇭", "flags", ["st_helena"]),
  new h("🇰🇳", "flags", ["st_kitts_nevis"]),
  new h("🇱🇨", "flags", ["st_lucia"]),
  new h("🇵🇲", "flags", ["st_pierre_miquelon"]),
  new h("🇻🇨", "flags", ["st_vincent_grenadines"]),
  new h("🇼🇸", "flags", ["samoa"]),
  new h("🇸🇲", "flags", ["san_marino"]),
  new h("🇸🇹", "flags", ["sao_tome_principe"]),
  new h("🇸🇦", "flags", ["saudi_arabia"]),
  new h("🇸🇳", "flags", ["senegal"]),
  new h("🇷🇸", "flags", ["serbia"]),
  new h("🇸🇨", "flags", ["seychelles"]),
  new h("🇸🇱", "flags", ["sierra_leone"]),
  new h("🇸🇬", "flags", ["singapore"]),
  new h("🇸🇽", "flags", ["sint_maarten"]),
  new h("🇸🇰", "flags", ["slovakia"]),
  new h("🇸🇮", "flags", ["slovenia"]),
  new h("🇸🇧", "flags", ["solomon_islands"]),
  new h("🇸🇴", "flags", ["somalia"]),
  new h("🇿🇦", "flags", ["south_africa"]),
  new h("🇬🇸", "flags", ["south_georgia_south_sandwich_islands"]),
  new h("🇰🇷", "flags", ["kr"]),
  new h("🇸🇸", "flags", ["south_sudan"]),
  new h("🇪🇸", "flags", ["es"]),
  new h("🇱🇰", "flags", ["sri_lanka"]),
  new h("🇸🇩", "flags", ["sudan"]),
  new h("🇸🇷", "flags", ["suriname"]),
  new h("🇸🇿", "flags", ["swaziland"]),
  new h("🇸🇪", "flags", ["sweden"]),
  new h("🇨🇭", "flags", ["switzerland"]),
  new h("🇸🇾", "flags", ["syria"]),
  new h("🇹🇼", "flags", ["taiwan"]),
  new h("🇹🇯", "flags", ["tajikistan"]),
  new h("🇹🇿", "flags", ["tanzania"]),
  new h("🇹🇭", "flags", ["thailand"]),
  new h("🇹🇱", "flags", ["timor_leste"]),
  new h("🇹🇬", "flags", ["togo"]),
  new h("🇹🇰", "flags", ["tokelau"]),
  new h("🇹🇴", "flags", ["tonga"]),
  new h("🇹🇹", "flags", ["trinidad_tobago"]),
  new h("🇹🇳", "flags", ["tunisia"]),
  new h("🇹🇷", "flags", ["tr"]),
  new h("🇹🇲", "flags", ["turkmenistan"]),
  new h("🇹🇨", "flags", ["turks_caicos_islands"]),
  new h("🇹🇻", "flags", ["tuvalu"]),
  new h("🇺🇬", "flags", ["uganda"]),
  new h("🇺🇦", "flags", ["ukraine"]),
  new h("🇦🇪", "flags", ["united_arab_emirates"]),
  new h("🇬🇧", "flags", ["gb", "uk"]),
  new h("🇺🇸", "flags", ["us"]),
  new h("🇻🇮", "flags", ["us_virgin_islands"]),
  new h("🇺🇾", "flags", ["uruguay"]),
  new h("🇺🇿", "flags", ["uzbekistan"]),
  new h("🇻🇺", "flags", ["vanuatu"]),
  new h("🇻🇦", "flags", ["vatican_city"]),
  new h("🇻🇪", "flags", ["venezuela"]),
  new h("🇻🇳", "flags", ["vietnam"]),
  new h("🇼🇫", "flags", ["wallis_futuna"]),
  new h("🇪🇭", "flags", ["western_sahara"]),
  new h("🇾🇪", "flags", ["yemen"]),
  new h("🇿🇲", "flags", ["zambia"]),
  new h("🇿🇼", "flags", ["zimbabwe"])
], Kt = {
  activity: '\n    <svg width="1em" height="1em"\n      xmlns="http://www.w3.org/2000/svg" viewBox="0 0 303.6 303.6">\n      <path d="M291.503 11.6c-10.4-10.4-37.2-11.6-48.4-11.6-50.4 0-122.4 18.4-173.6 69.6-77.2 76.8-78.4 201.6-58.4 222 10.8 10.4 35.6 12 49.2 12 49.6 0 121.2-18.4 173.2-70 76.4-76.4 80.4-199.6 58-222zm-231.2 277.2c-24.4 0-36-4.8-38.8-7.6-5.2-5.2-8.4-24.4-6.8-49.6l57.2 56.8c-4 .4-8 .4-11.6.4zm162.8-66c-38.8 38.8-90.4 57.2-132.4 63.6l-74-73.6c6-42 24-94 63.2-133.2 38-38 88-56.4 130.8-62.8l75.6 75.6c-6 40.8-24.4 91.6-63.2 130.4zm65.2-148.8l-58.8-59.2c4.8-.4 9.2-.4 13.6-.4 24.4 0 35.6 4.8 38 7.2 5.6 5.6 9.2 25.6 7.2 52.4z"/>\n      <path d="M215.103 139.6l-20.8-20.8 13.2-13.2c2.8-2.8 2.8-7.6 0-10.4s-7.6-2.8-10.4 0l-13.2 13.6-20.8-20.8c-2.8-2.8-7.6-2.8-10.4 0-2.8 2.8-2.8 7.6 0 10.4l20.8 20.8-22 22-20.8-20.8c-2.8-2.8-7.6-2.8-10.4 0s-2.8 7.6 0 10.4l20.8 20.8-22 22-20.8-20.8c-2.8-2.8-7.6-2.8-10.4 0s-2.8 7.6 0 10.4l20.8 20.8-13.2 13.2c-2.8 2.8-2.8 7.6 0 10.4 1.6 1.6 3.2 2 5.2 2s3.6-.8 5.2-2l13.2-13.2 20.8 20.8c1.6 1.6 3.2 2 5.2 2s3.6-.8 5.2-2c2.8-2.8 2.8-7.6 0-10.4l-20.8-21.2 22-22 20.8 20.8c1.6 1.6 3.2 2 5.2 2s3.6-.8 5.2-2c2.8-2.8 2.8-7.6 0-10.4l-20.8-20.8 22-22 20.8 20.8c1.6 1.6 3.2 2 5.2 2s3.6-.8 5.2-2c2.8-2.8 2.8-7.6 0-10.4zM169.103 47.6c-1.2-4-5.2-6-9.2-4.8-3.2 1.2-80.8 25.6-110.4 98-1.6 4 0 8.4 4 9.6.8.4 2 .4 2.8.4 2.8 0 5.6-1.6 6.8-4.4 27.2-66 100.4-89.6 101.2-89.6 4-1.2 6-5.2 4.8-9.2z"/>\n    </svg>\n    ',
  flags: '\n    <svg width="1em" height="1em"\n      xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512">\n      <path d="M472.928 34.72c-4.384-2.944-9.984-3.52-14.912-1.568-1.088.448-106.528 42.176-195.168.384C186.752-2.4 102.944 14.4 64 25.76V16c0-8.832-7.168-16-16-16S32 7.168 32 16v480c0 8.832 7.168 16 16 16s16-7.168 16-16V315.296c28.352-9.248 112.384-31.232 185.184 3.168 34.592 16.352 70.784 21.792 103.648 21.792 63.2 0 114.016-20.128 117.184-21.408 6.016-2.464 9.984-8.32 9.984-14.848V48c0-5.312-2.656-10.272-7.072-13.28zM448 292.672c-28.512 9.248-112.512 31.136-185.184-3.168C186.752 253.6 102.944 270.4 64 281.76V59.328c28.352-9.248 112.384-31.232 185.184 3.168 76 35.872 159.872 19.104 198.816 7.712v222.464z"/>\n    </svg>\n    ',
  foods: '\n    <svg width="1em" height="1em"\n      xmlns="http://www.w3.org/2000/svg" viewBox="0 0 511.999 511.999">\n      <path d="M413.949 155.583a10.153 10.153 0 0 0-3.24-2.16c-.61-.25-1.24-.44-1.87-.57-3.25-.66-6.701.41-9.03 2.73a10.093 10.093 0 0 0-2.93 7.07 10.098 10.098 0 0 0 1.69 5.56c.36.54.779 1.05 1.24 1.52 1.86 1.86 4.44 2.93 7.07 2.93.65 0 1.31-.07 1.96-.2.63-.13 1.26-.32 1.87-.57a10.146 10.146 0 0 0 3.24-2.16c.47-.47.88-.98 1.25-1.52a10.098 10.098 0 0 0 1.49-3.6 10.038 10.038 0 0 0-2.74-9.03zM115.289 385.873c-.12-.64-.32-1.27-.57-1.87-.25-.6-.55-1.18-.91-1.73-.37-.54-.79-1.06-1.25-1.52a9.57 9.57 0 0 0-1.52-1.24c-.54-.36-1.12-.67-1.72-.92-.61-.25-1.24-.44-1.88-.57a9.847 9.847 0 0 0-3.9 0c-.64.13-1.27.32-1.87.57-.61.25-1.19.56-1.73.92-.55.36-1.06.78-1.52 1.24-.46.46-.88.98-1.24 1.52-.36.55-.67 1.13-.92 1.73-.25.6-.45 1.23-.57 1.87-.13.651-.2 1.3-.2 1.96 0 .65.07 1.3.2 1.95.12.64.32 1.27.57 1.87.25.6.56 1.18.92 1.73.36.54.78 1.06 1.24 1.52.46.46.97.88 1.52 1.24.54.36 1.12.67 1.73.92.6.25 1.23.44 1.87.57s1.3.2 1.95.2c.65 0 1.31-.07 1.95-.2.64-.13 1.27-.32 1.88-.57.6-.25 1.18-.56 1.72-.92.55-.36 1.059-.78 1.52-1.24.46-.46.88-.98 1.25-1.52.36-.55.66-1.13.91-1.73.25-.6.45-1.23.57-1.87.13-.65.2-1.3.2-1.95 0-.66-.07-1.31-.2-1.96z"/>\n      <path d="M511.999 222.726c0-14.215-9.228-26.315-22.007-30.624-1.628-74.155-62.456-133.978-136.994-133.978H159.002c-74.538 0-135.366 59.823-136.994 133.978C9.228 196.411 0 208.51 0 222.726a32.076 32.076 0 0 0 3.847 15.203 44.931 44.931 0 0 0-.795 8.427v.708c0 14.06 6.519 26.625 16.693 34.833-10.178 8.275-16.693 20.891-16.693 35.001 0 15.114 7.475 28.515 18.921 36.702v26.668c0 40.588 33.021 73.608 73.608 73.608h320.836c40.588 0 73.608-33.021 73.608-73.608V353.6c11.446-8.186 18.921-21.587 18.921-36.702 0-13.852-6.354-26.385-16.361-34.702 9.983-8.212 16.361-20.656 16.361-34.562v-.708c0-2.985-.294-5.944-.877-8.845a32.082 32.082 0 0 0 3.93-15.355zM44.033 173.229h322.441c5.523 0 10-4.477 10-10s-4.477-10-10-10H49.737c16.896-43.883 59.503-75.106 109.265-75.106h193.996c62.942 0 114.438 49.953 116.934 112.295H42.068c.234-5.848.9-11.588 1.965-17.189zM23.052 316.896c0-13.837 11.257-25.094 25.094-25.094h117.298l55.346 50.188H48.146c-13.837 0-25.094-11.256-25.094-25.094zm.976-62.945c.422.111.847.215 1.275.309 7.421 1.634 14.68 8.002 22.365 14.744a576.29 576.29 0 0 0 3.206 2.799h-3.081c-11.253-.001-20.774-7.551-23.765-17.852zm308.727 89.752l57.233-51.899 49.904.57-81.871 74.24-25.266-22.911zm7.861 34.126H295.12l17.467-15.839h10.563l17.466 15.839zm19.599-86.027l-82.499 74.811-82.499-74.811h164.998zm-59.529-20c.849-.842 1.677-1.675 2.49-2.493 9.531-9.587 17.059-17.16 32.89-17.16 15.832 0 23.359 7.573 32.89 17.162.812.817 1.64 1.65 2.489 2.491h-70.759zm-160.13 0a485.82 485.82 0 0 0 2.489-2.492c9.531-9.588 17.059-17.161 32.89-17.161 15.83 0 23.358 7.573 32.888 17.16.813.818 1.641 1.651 2.49 2.493h-70.757zm275.862 162.073H95.582c-29.56 0-53.608-24.049-53.608-53.608v-18.275h200.872l17.467 15.839H145.897c-5.523 0-10 4.477-10 10s4.477 10 10 10H467.07c-7.288 20.958-27.242 36.044-50.652 36.044zm53.608-56.046h-94.6l17.467-15.839h77.133v15.839zm-6.174-35.837h-48.906l54.624-49.533c11.135 2.604 19.376 12.665 19.376 24.439 0 13.836-11.257 25.094-25.094 25.094zm-2.728-70.19l.262-.227.101-.087.342-.298c.848-.738 1.682-1.469 2.501-2.187 4.105-3.601 8.089-7.095 12.04-9.819 3.446-2.375 6.868-4.164 10.326-4.925l.359-.081.04-.01.317-.076.065-.016a22.897 22.897 0 0 0 .42-.107l.196-.052a.374.374 0 0 0 .048-.012c-2.433 9.276-10.129 16.443-19.691 18.102a9.984 9.984 0 0 0-2.016-.205h-5.31zm21.271-37.073a40.746 40.746 0 0 0-4.536 1.281c-10.109 3.489-18.327 10.602-26.283 17.58l-.434.381c-9.178 8.052-17.923 15.723-29.033 17.834h-13.146c-11.249-1.93-17.833-8.552-25.823-16.591-10.213-10.275-22.923-23.062-47.074-23.062-24.15 0-36.86 12.786-47.074 23.06-7.992 8.04-14.576 14.663-25.829 16.593h-14.327c-11.253-1.93-17.837-8.553-25.829-16.593-10.213-10.274-22.923-23.06-47.072-23.06-24.151 0-36.861 12.787-47.074 23.062-7.991 8.039-14.574 14.661-25.824 16.591h-7.065c-14.134 0-24.325-8.939-35.113-18.404-9.248-8.112-18.81-16.501-31.252-19.241a12.237 12.237 0 0 1-7.025-4.453 10.027 10.027 0 0 0-1.153-1.252 12.234 12.234 0 0 1-1.428-5.727c-.001-6.788 5.52-12.309 12.307-12.309h447.384c6.787 0 12.308 5.521 12.308 12.308 0 5.729-4.039 10.776-9.605 12.002z"/>\n    </svg>\n    ',
  frequently: '\n    <svg\n      xmlns="http://www.w3.org/2000/svg" viewBox="0 0 219.15 219.15" width="1em" height="1em">\n      <path d="M109.575 0C49.156 0 .001 49.155.001 109.574c0 60.42 49.154 109.576 109.573 109.576 60.42 0 109.574-49.156 109.574-109.576C219.149 49.155 169.995 0 109.575 0zm0 204.15c-52.148 0-94.573-42.427-94.573-94.576C15.001 57.426 57.427 15 109.575 15c52.148 0 94.574 42.426 94.574 94.574 0 52.15-42.426 94.576-94.574 94.576z"/>\n      <path d="M166.112 108.111h-52.051V51.249a7.5 7.5 0 0 0-15 0v64.362a7.5 7.5 0 0 0 7.5 7.5h59.551a7.5 7.5 0 0 0 0-15z"/>\n    </svg>\n    ',
  nature: '\n    <svg\n      xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" width="1em" height="1em">\n      <path d="M490.815 3.784C480.082 5.7 227.049 51.632 148.477 130.203c-39.153 39.153-64.259 87.884-70.694 137.218-5.881 45.081 4.347 85.929 28.878 116.708L.001 490.789 21.212 512l106.657-106.657c33.094 26.378 75.092 34.302 116.711 28.874 49.334-6.435 98.065-31.541 137.218-70.695C460.368 284.951 506.3 31.918 508.216 21.185L511.999 0l-21.184 3.784zm-43.303 39.493L309.407 181.383l-7.544-98.076c46.386-15.873 97.819-29.415 145.649-40.03zm-174.919 50.64l8.877 115.402-78.119 78.119-11.816-153.606c19.947-13.468 47.183-26.875 81.058-39.915zm-109.281 64.119l12.103 157.338-47.36 47.36c-39.246-52.892-24.821-139.885 35.257-204.698zm57.113 247.849c-26.548-.001-51.267-7.176-71.161-21.938l47.363-47.363 157.32 12.102c-40.432 37.475-89.488 57.201-133.522 57.199zm157.743-85.421l-153.605-11.816 78.118-78.118 115.403 8.877c-13.04 33.876-26.448 61.111-39.916 81.057zm50.526-110.326l-98.076-7.544L468.725 64.485c-10.589 47.717-24.147 99.232-40.031 145.653z"/>\n    </svg>\n    ',
  objects: '\n    <svg\n      xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 792 792">\n      <path d="M425.512 741.214H365.58c-14.183 0-25.164 11.439-25.164 25.622S351.397 792 365.58 792h59.932c15.101 0 26.54-10.981 26.54-25.164s-11.44-25.622-26.54-25.622zM472.638 671.209H319.821c-14.183 0-26.081 10.98-26.081 25.163s11.898 25.164 26.081 25.164h152.817c14.183 0 25.164-10.981 25.164-25.164s-10.982-25.163-25.164-25.163zM639.188 138.634c-25.164-42.548-59.181-76.135-102.49-101.113C493.526 12.621 446.566 0 395.771 0 320.28 0 247.19 31.684 197.205 81.445c-49.761 49.527-81.904 121.24-81.904 196.282 0 33.861 7.779 68.629 22.879 103.866 15.1 35.228 38.565 78.614 70.005 130.396 7.448 12.269 15.764 31.205 25.623 56.271 12.104 30.757 22.87 51.713 31.566 63.602 5.027 6.872 11.899 10.063 20.596 10.063h228.766c9.605 0 16.359-4.188 21.504-11.898 6.754-10.132 13.987-27.516 22.42-51.693 8.951-25.691 16.838-43.982 23.329-55.364 30.571-53.587 54.446-99.747 70.464-137.717 16.018-37.979 24.246-74.124 24.246-107.526 0-49.878-12.347-96.545-37.511-139.093zm-35.696 232.437c-15.012 34.348-36.398 76.974-65.427 126.736-9.41 16.125-18.458 37.003-26.989 63.592-3.367 10.474-7.32 20.596-11.439 30.2H300.153c-6.862-11.439-12.26-25.837-18.761-42.089-12.718-31.801-23.338-52.621-30.2-64.061-28.824-48.043-49.868-87.39-64.051-118.957s-20.537-60.859-21.044-88.766c-2.235-121.718 106.13-228.991 229.674-226.941 41.631.693 80.527 10.063 115.765 30.659 35.227 20.586 63.134 48.043 83.729 82.812 20.586 34.768 31.108 72.748 31.108 113.47-.001 27.449-7.692 58.596-22.881 93.345z"/>\n    </svg>\n    ',
  peoples: '\n    <svg\n      xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 106.059 106.059">\n      <path d="M90.544 90.542c20.687-20.684 20.685-54.341.002-75.024-20.688-20.689-54.347-20.689-75.031-.006-20.688 20.687-20.686 54.346.002 75.034 20.682 20.684 54.341 20.684 75.027-.004zM21.302 21.3c17.494-17.493 45.959-17.495 63.457.002 17.494 17.494 17.492 45.963-.002 63.455-17.494 17.494-45.96 17.496-63.455.003-17.498-17.498-17.496-45.966 0-63.46zM27 69.865s-2.958-11.438 6.705-8.874c0 0 17.144 9.295 38.651 0 9.662-2.563 6.705 8.874 6.705 8.874C73.539 86.824 53.03 85.444 53.03 85.444S32.521 86.824 27 69.865zm6.24-31.194a6.202 6.202 0 1 1 12.399.001 6.202 6.202 0 0 1-12.399-.001zm28.117 0a6.202 6.202 0 1 1 12.403.001 6.202 6.202 0 0 1-12.403-.001z"/>\n    </svg>\n    ',
  places: '\n    <svg\n      xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 611.999 611.998">\n      <path d="M596.583 15.454C586.226 5.224 573.354.523 558.423.523c-15.597 0-31.901 4.906-49.452 14.599-17.296 9.551-32.851 20.574-46.458 32.524h-.665c-2.655 2.322-10.953 10.287-25.219 24.553-14.272 14.272-26.217 26.223-35.845 36.51L112.401 26.406c-6.896-1.968-12.928.014-17.593 4.645L46.687 78.839c-4.326 4.297-5.805 9.268-4.977 15.597.829 6.287 3.979 10.627 9.629 13.607L280.32 228.839 161.514 347.978l-95.91 3.32c-4.645.164-8.637 1.643-12.276 5.311L5.872 404.397c-4.312 4.34-6.641 9.289-5.643 16.262 1.657 6.967 5.31 11.611 11.618 13.602l117.142 48.787 48.787 117.148c2.421 5.812 6.634 9.621 13.607 11.279h3.313c4.977 0 9.296-1.658 12.942-5.311l47.456-47.457c3.653-3.645 5.494-7.965 5.643-12.275l3.32-95.91 118.807-118.807 121.128 228.99c2.988 5.643 7.32 8.793 13.607 9.621 6.329.836 11.271-1.316 15.597-5.643l47.456-47.457c4.978-4.977 6.945-10.697 4.978-17.586l-82.296-288.389 59.732-59.739c10.287-10.287 21.699-24.149 33.183-45.134 5.777-10.542 10.032-20.886 12.942-31.194 5.722-20.218 3.258-44.07-12.608-59.73zm-59.4 110.176l-67.039 67.372c-5.628 5.657-6.811 11.122-4.977 17.586l81.637 288.388-22.563 22.238L403.438 292.89c-2.98-5.643-7.299-8.963-12.941-9.621-6.301-1.331-11.611.325-16.263 4.977l-141.37 141.37c-2.987 2.986-4.644 6.973-5.643 11.949l-3.32 95.904-22.896 23.236-41.48-98.566c-1.331-4.645-4.553-8.184-9.629-10.287L51.338 411.03l23.229-22.895 95.578-3.654c5.643-.99 9.622-2.654 12.276-5.309l141.37-141.371c4.651-4.645 6.308-9.954 4.984-16.262-.666-5.643-3.986-9.954-9.629-12.942L90.829 87.47l22.231-22.238 288.389 81.637c6.464 1.833 11.951.666 17.587-4.977l28.545-28.539 26.217-25.884 11.278-11.285 1.331-.666c27.873-23.895 55.088-38.16 72.016-38.16 5.969 0 9.954 1.324 11.611 3.979 18.917 18.585-21.099 72.484-32.851 84.293z"/>\n    </svg>\n    ',
  symbols: '\n    <svg\n      xmlns="http://www.w3.org/2000/svg" width="1em" height="1em" viewBox="0 0 511.626 511.626">\n      <path d="M475.366 71.949c-24.175-23.606-57.575-35.404-100.215-35.404-11.8 0-23.843 2.046-36.117 6.136-12.279 4.093-23.702 9.615-34.256 16.562-10.568 6.945-19.65 13.467-27.269 19.556a263.828 263.828 0 0 0-21.696 19.414 264.184 264.184 0 0 0-21.698-19.414c-7.616-6.089-16.702-12.607-27.268-19.556-10.564-6.95-21.985-12.468-34.261-16.562-12.275-4.089-24.316-6.136-36.116-6.136-42.637 0-76.039 11.801-100.211 35.404C12.087 95.55 0 128.286 0 170.16c0 12.753 2.24 25.891 6.711 39.398 4.471 13.514 9.566 25.031 15.275 34.546 5.708 9.514 12.181 18.792 19.414 27.834 7.233 9.041 12.519 15.272 15.846 18.698 3.33 3.426 5.948 5.903 7.851 7.427L243.25 469.938c3.427 3.426 7.614 5.144 12.562 5.144s9.138-1.718 12.563-5.144l177.87-171.31c43.588-43.58 65.38-86.406 65.38-128.472.001-41.877-12.085-74.61-36.259-98.207zm-53.961 199.846L255.813 431.391 89.938 271.507C54.344 235.922 36.55 202.133 36.55 170.156c0-15.415 2.046-29.026 6.136-40.824 4.093-11.8 9.327-21.177 15.703-28.124 6.377-6.949 14.132-12.607 23.268-16.988 9.141-4.377 18.086-7.328 26.84-8.85 8.754-1.52 18.079-2.281 27.978-2.281 9.896 0 20.557 2.424 31.977 7.279 11.418 4.853 21.934 10.944 31.545 18.271 9.613 7.332 17.845 14.183 24.7 20.557 6.851 6.38 12.559 12.229 17.128 17.559 3.424 4.189 8.091 6.283 13.989 6.283 5.9 0 10.562-2.094 13.99-6.283 4.568-5.33 10.28-11.182 17.131-17.559 6.852-6.374 15.085-13.222 24.694-20.557 9.613-7.327 20.129-13.418 31.553-18.271 11.416-4.854 22.08-7.279 31.977-7.279s19.219.761 27.977 2.281c8.757 1.521 17.702 4.473 26.84 8.85 9.137 4.38 16.892 10.042 23.267 16.988 6.376 6.947 11.612 16.324 15.705 28.124 4.086 11.798 6.132 25.409 6.132 40.824-.002 31.977-17.89 65.86-53.675 101.639z"/>\n    </svg>\n    '
}, N2 = () => [
  new Zt("frequently", Kt.frequently, "常用"),
  new Zt("peoples", Kt.peoples, "情绪"),
  new Zt("nature", Kt.nature, "自然"),
  new Zt("foods", Kt.foods, "食物与饮料"),
  new Zt("activity", Kt.activity, "活动"),
  new Zt("objects", Kt.objects, "对象"),
  new Zt("places", Kt.places, "旅行与地方"),
  new Zt("symbols", Kt.symbols, "符号"),
  new Zt("flags", Kt.flags, "旗帜")
], I2 = () => M("svg", {
  viewBox: "0 0 16 16",
  xmlns: "http://www.w3.org/2000/svg",
  height: "1em",
  width: "1em",
  focusable: "false"
}, [M("g", {
  "stroke-width": "1"
}, [M("path", {
  d: "M6.751 12.303A5.557 5.557 0 0 1 1.2 6.751C1.2 3.691 3.69 1.2 6.751 1.2a5.558 5.558 0 0 1 5.551 5.551 5.557 5.557 0 0 1-5.551 5.552M6.751 0a6.751 6.751 0 1 0 4.309 11.949l3.855 3.855a.6.6 0 1 0 .849-.849l-3.854-3.853A6.751 6.751 0 0 0 6.751 0"
}, null)])]);
const j2 = /* @__PURE__ */ me({
  name: "IBizCategories",
  props: {
    categories: {
      type: Array,
      required: !0,
      default: () => []
    },
    current: {
      type: String,
      required: !0
    }
  },
  emits: ["select"],
  setup(s, {
    emit: e
  }) {
    return {
      ns: we("emoji-categories"),
      onSelect: (i) => {
        e("select", i);
      }
    };
  },
  render() {
    return M("div", {
      class: this.ns.b()
    }, [this.categories.map((s) => M("div", {
      class: [this.ns.e("category"), this.ns.is("active", s.name === this.current)],
      onClick: () => this.onSelect(s)
    }, [M("span", {
      class: this.ns.em("category", "svg"),
      title: s.label,
      innerHTML: s.icon
    }, null)]))]);
  }
});
const R2 = /* @__PURE__ */ me({
  name: "IBizCategoryLabel",
  props: {
    name: {
      type: String,
      default: ""
    }
  },
  emits: ["select"],
  setup() {
    return {
      ns: we("emoji-category-label")
    };
  },
  render() {
    return M("div", {
      class: this.ns.b()
    }, [this.name]);
  }
});
const B2 = /* @__PURE__ */ me({
  name: "IBizEmojiItem",
  props: {
    emoji: {
      type: Object,
      required: !0,
      default: () => {
      }
    },
    size: {
      type: Number,
      required: !0
    },
    withBorder: {
      type: Boolean,
      required: !0
    }
  },
  emits: ["click"],
  setup(s, {
    emit: e
  }) {
    const t = we("emoji-item"), n = Ge(() => ({
      fontSize: "".concat(s.size - 5, "px"),
      lineHeight: "".concat(s.size, "px"),
      height: "".concat(s.size, "px"),
      width: "".concat(s.size, "px")
    }));
    return {
      ns: t,
      styleSize: n,
      onClick: () => {
        e("click", s.emoji);
      }
    };
  },
  render() {
    return M("span", {
      class: [this.ns.b(), this.ns.is("border", this.withBorder)],
      style: this.styleSize,
      onClick: this.onClick,
      innerHTML: this.emoji.data
    }, null);
  }
});
const ah = (s, e) => {
  const t = (n) => n.toLowerCase().includes(s);
  return e.aliases.some((n) => t(n));
}, $2 = /* @__PURE__ */ me({
  name: "IBizEmojiList",
  props: {
    data: {
      type: Object,
      required: !0
    },
    emojisByRow: {
      type: Number,
      required: !0
    },
    emojiWithBorder: {
      type: Boolean
    },
    emojiSize: {
      type: Number
    },
    filter: {
      type: String,
      default: ""
    },
    continuousList: {
      type: Boolean
    },
    category: {
      type: String,
      default: ""
    },
    categories: {
      type: Object,
      required: !0,
      default: () => {
      }
    },
    hasSearch: {
      type: Boolean
    }
  },
  emits: ["select", "data"],
  setup(s, {
    emit: e
  }) {
    const t = we("emoji-list"), n = T({}), i = T({}), r = Ge(() => {
      let g = s.data[s.category];
      const p = s.filter.trim().toLowerCase();
      return p && (g = g.filter((m) => ah(p, m))), g;
    }), o = Ge(() => Object.keys(s.data)), a = (g, p) => {
      p && (i.value[g] = p);
    }, l = () => s.hasSearch ? 88 : 44, c = Ge(() => {
      const g = 100 / s.emojisByRow;
      return {
        gridTemplateColumns: "repeat(".concat(s.emojisByRow, ", ").concat(g, "%)")
      };
    }), u = Ge(() => {
      const g = {};
      Object.assign(g, s.data);
      const p = s.filter.trim().toLowerCase();
      return p && o.value.forEach((m) => {
        g[m] = s.data[m].filter((w) => ah(p, w));
      }), g;
    }), f = (g) => {
      e("select", g);
    };
    return Ne(() => s.data, () => {
      n.value.$el.scrollTop = 0;
    }), Ne(() => s.category, (g) => {
      if (s.continuousList) {
        const p = i.value[g].$el;
        n.value.scrollTop = p.offsetTop - l();
      }
    }), {
      ns: t,
      emojisRef: n,
      gridDynamic: c,
      dataFiltered: r,
      dataFilteredByCategory: u,
      onSelect: f,
      setCategoryRef: a,
      renderGridEmojis: (g) => {
        const {
          emojis: p,
          style: m,
          size: w,
          withBorder: v
        } = g;
        return p && p.length > 0 ? M("div", {
          class: [t.m("grid-emojis")],
          style: m
        }, [p.map((y) => M(B2, {
          emoji: y,
          size: w,
          withBorder: v,
          onClick: () => f(y)
        }, null))]) : "";
      }
    };
  },
  render() {
    return M("div", {
      class: [this.ns.b()]
    }, [M("div", {
      ref: "emojisRef",
      class: [this.ns.e("container")]
    }, [this.continuousList ? Object.keys(this.dataFilteredByCategory).map((s) => {
      const e = this.dataFilteredByCategory[s], t = this.categories[s], n = t ? t.text : s;
      return M("div", null, [e.length ? M(R2, {
        name: n,
        ref: (i) => this.setCategoryRef(s, i)
      }, null) : "", this.renderGridEmojis({
        emojis: e,
        style: this.gridDynamic,
        size: this.emojiSize,
        withBorder: this.emojiWithBorder
      })]);
    }) : this.renderGridEmojis({
      emojis: this.dataFiltered || [],
      style: this.gridDynamic,
      size: this.emojiSize,
      withBorder: this.emojiWithBorder
    })])]);
  }
});
const F2 = /* @__PURE__ */ me({
  name: "IBizInputSearch",
  emits: ["update"],
  setup(s, {
    emit: e
  }) {
    const t = we("emoji-input-search"), n = T(""), i = () => {
      e("update", n.value);
    };
    return {
      ns: t,
      inputSearch: n,
      onSearch: i,
      handleKeyUp: (o) => {
        o && o.code === "Enter" && i();
      }
    };
  },
  render() {
    return M("div", {
      class: [this.ns.b()]
    }, [M("div", {
      class: this.ns.e("container"),
      onKeyup: this.handleKeyUp
    }, [M("div", {
      class: this.ns.em("container", "search"),
      onClick: this.onSearch
    }, [I2()]), ri(M("input", {
      class: this.ns.em("container", "input"),
      type: "text",
      "onUpdate:modelValue": (s) => this.inputSearch = s,
      placeholder: ibiz.i18n.t("app.search")
    }, null), [[fl, this.inputSearch]])])]);
  }
});
const z2 = /* @__PURE__ */ me({
  name: "IBizEmojiSelectHtmlComment",
  props: {
    // 自定义表情符号数组，类型为IEmoji[]，必填项，默认值为emojisDefault
    customEmojis: {
      type: Array,
      required: !0,
      default: () => D2
    },
    // 自定义分类数组，类型为ICategory[]，必填项，默认值为categoriesDefault
    customCategories: {
      type: Array,
      required: !0,
      default: () => []
    },
    // 频繁使用表情符号的数量限制
    limitFrequently: {
      type: Number,
      default: 15
    },
    // 每行显示的表情符号数量
    emojisByRow: {
      type: Number,
      default: 8
    },
    // 是否使用连续列表显示表情符号
    continuousList: {
      type: Boolean,
      default: !1
    },
    // 表情符号的大小
    emojiSize: {
      type: Number,
      default: 27
    },
    // 表情符号是否带有边框
    emojiWithBorder: {
      type: Boolean,
      default: !0
    },
    // 是否显示搜索框
    showSearch: {
      type: Boolean,
      default: !0
    },
    // 是否显示分类
    showCategories: {
      type: Boolean,
      default: !0
    },
    // 是否使用深色模式
    dark: {
      type: Boolean,
      default: !1
    },
    // 初始选择的分类
    initialCategory: {
      type: String,
      default: "peoples"
    },
    // 需要排除的分类数组
    exceptCategories: {
      type: Array,
      default: () => []
    },
    // 需要排除的表情符号数组
    exceptEmojis: {
      type: Array,
      default: () => []
    }
  },
  emits: ["select", "changeCategory", "customEmojis"],
  setup(s, {
    emit: e
  }) {
    const t = we("emoji-select"), n = T([]), i = T([]), r = T("peoples"), o = T([]), a = T([]), l = T([]), c = T({}), u = T({}), f = T("");
    f.value = r.value;
    const d = T(""), g = i.value.map((P) => P.name);
    g.includes(r.value) || (r.value = g[0]);
    const p = async (P) => {
      d.value = P;
    }, m = Ge(() => i.value.filter((P) => !o.value.includes(P))), w = (P) => {
      P.forEach((O) => {
        Object.assign(c.value, {
          [O.name]: O
        });
      });
    }, v = (P) => {
      Object.assign(u.value, {
        frequently: []
      }), P.filter((O) => !a.value.includes(O)).forEach((O) => {
        const k = O.category;
        u.value[k] || Object.assign(u.value, {
          [k]: []
        }), u.value[k].push(O);
      });
    }, y = async () => {
      const P = l.value || [];
      Object.assign(u.value, {
        frequently: P.map((O) => n.value[O])
      });
    }, b = (P) => {
      const O = P.map((k) => n.value.indexOf(k));
      l.value = O;
    }, x = async (P) => {
      const O = u.value.frequently, k = [.../* @__PURE__ */ new Set([P, ...O])];
      u.value.frequently = k.slice(0, s.limitFrequently), b(k);
    }, C = async (P) => {
      const O = u.value[P.name].length;
      f.value = P.name, O && e("changeCategory", P);
    }, A = async (P) => {
      await x(P), e("select", P);
    };
    return Ne(() => s.customEmojis, (P) => {
      n.value = s.customEmojis, P && P.length && (u.value = {}, v(P));
    }, {
      immediate: !0,
      deep: !0
    }), Ne(() => s.customCategories, (P) => {
      P && P.length > 0 ? i.value = P : i.value = N2(), w(i.value);
    }, {
      immediate: !0,
      deep: !0
    }), Ne(() => s.initialCategory, () => {
      r.value = s.initialCategory;
    }), Ne(() => s.exceptCategories, () => {
      o.value = s.exceptCategories;
    }), Ne(() => s.exceptEmojis, () => {
      a.value = s.exceptEmojis;
    }), hn(() => {
      v(n.value), y();
    }), or(() => {
      u.value = {}, l.value = [];
    }), {
      ns: t,
      mapEmojis: u,
      filterEmoji: d,
      mapCategories: c,
      currentCategory: f,
      categoriesFiltered: m,
      onSearch: p,
      onSelectEmoji: A,
      changeCategory: C
    };
  },
  render() {
    return M("div", {
      class: [this.ns.b(), this.ns.is("dark", this.dark)]
    }, [this.showCategories && M(j2, {
      categories: this.categoriesFiltered,
      current: this.currentCategory,
      onSelect: this.changeCategory
    }, null), this.showSearch && M(F2, {
      onUpdate: this.onSearch
    }, null), M($2, {
      data: this.mapEmojis,
      category: this.currentCategory,
      filter: this.filterEmoji,
      categories: this.mapCategories,
      emojiWithBorder: this.emojiWithBorder,
      emojiSize: this.emojiSize,
      emojisByRow: this.emojisByRow,
      continuousList: this.continuousList,
      hasSearch: this.showSearch,
      onSelect: this.onSelectEmoji
    }, null)]);
  }
});
class ma {
  constructor(e, t, n) {
    E(this, "type");
    E(this, "icon");
    E(this, "text");
    this.type = e, this.icon = t, this.text = n;
  }
  get label() {
    return this.type;
  }
}
class Gn {
  constructor(e, t, n, i, r, o) {
    E(this, "type");
    E(this, "icon");
    E(this, "category");
    E(this, "text");
    E(this, "value");
    E(this, "isInline");
    this.type = e, this.icon = t, this.category = n, this.text = i, this.value = r, this.isInline = o === !0;
  }
}
const Wn = {
  layout: '<svg width="1em" height="1em" viewBox="0 0 28 28" version="1.1" xmlns="http://www.w3.org/2000/svg" fit="" preserveAspectRatio="xMidYMid meet" focusable="false"> <title>布局</title> <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"> <g id="icon"> <rect fill="#FFFFFF" x="0" y="0" width="28" height="28" rx="4"></rect> <path d="M24,0 C26.209139,0 28,1.790861 28,4 L28,24 C28,26.209139 26.209139,28 24,28 L4,28 C1.790861,28 0,26.209139 0,24 L0,4 C0,1.790861 1.790861,0 4,0 L24,0 Z M24,1 L4,1 C2.34314575,1 1,2.34314575 1,4 L1,24 C1,25.6568542 2.34314575,27 4,27 L24,27 C25.6568542,27 27,25.6568542 27,24 L27,4 C27,2.34314575 25.6568542,1 24,1 Z" id="矩形" fill="#EEEEEE" fill-rule="nonzero"></path> <g transform="translate(4.666667, 4.666667)"> <path d="M1.6,0 L6.95555556,0 C7.83921116,5.97197047e-17 8.55555556,0.7163444 8.55555556,1.6 L8.55555556,9.28888889 C8.55555556,10.1725445 7.83921116,10.8888889 6.95555556,10.8888889 L1.6,10.8888889 C0.7163444,10.8888889 1.082166e-16,10.1725445 0,9.28888889 L0,1.6 C-1.082166e-16,0.7163444 0.7163444,1.623249e-16 1.6,0 Z M11.6512821,0 L17.0068376,0 C17.8904932,5.97197047e-17 18.6068376,0.7163444 18.6068376,1.6 L18.6068376,9.28888889 C18.6068376,10.1725445 17.8904932,10.8888889 17.0068376,10.8888889 L11.6512821,10.8888889 C10.7676265,10.8888889 10.0512821,10.1725445 10.0512821,9.28888889 L10.0512821,1.6 C10.0512821,0.7163444 10.7676265,1.623249e-16 11.6512821,0 Z" id="形状结合" fill="#6698FF" opacity="0.300000012"></path> <path d="M0.466666667,17.8888889 L18.2,17.8888889 C18.4577329,17.8888889 18.6666667,18.0978227 18.6666667,18.3555556 C18.6666667,18.6132884 18.4577329,18.8222222 18.2,18.8222222 L0.466666667,18.8222222 C0.208933783,18.8222222 3.15631751e-17,18.6132884 0,18.3555556 C-3.15631751e-17,18.0978227 0.208933783,17.8888889 0.466666667,17.8888889 Z M0.466666667,14 L10.3025641,14 C10.560297,14 10.7692308,14.2089338 10.7692308,14.4666667 C10.7692308,14.7243995 10.560297,14.9333333 10.3025641,14.9333333 L0.466666667,14.9333333 C0.208933783,14.9333333 3.15631751e-17,14.7243995 0,14.4666667 C-3.15631751e-17,14.2089338 0.208933783,14 0.466666667,14 Z" id="形状结合" fill="#CACACA"></path> <path d="M4.2,4.82222222 L2.8,4.82222222 C2.54226712,4.82222222 2.33333333,4.61328844 2.33333333,4.35555556 C2.33333333,4.09782267 2.54226712,3.88888889 2.8,3.88888889 L4.2,3.88888889 C4.45773288,3.88888889 4.66666667,4.09782267 4.66666667,4.35555556 C4.66666667,4.61328844 4.45773288,4.82222222 4.2,4.82222222 Z M15.0888889,4.82222222 L12.9111111,4.82222222 C12.6533782,4.82222222 12.4444444,4.61328844 12.4444444,4.35555556 C12.4444444,4.09782267 12.6533782,3.88888889 12.9111111,3.88888889 L15.0888889,3.88888889 C15.3466218,3.88888889 15.5555556,4.09782267 15.5555556,4.35555556 C15.5555556,4.61328844 15.3466218,4.82222222 15.0888889,4.82222222 Z M5.75555556,7.93333333 L2.8,7.93333333 C2.54226712,7.93333333 2.33333333,7.72439955 2.33333333,7.46666667 C2.33333333,7.20893378 2.54226712,7 2.8,7 L5.75555556,7 C6.01328844,7 6.22222222,7.20893378 6.22222222,7.46666667 C6.22222222,7.72439955 6.01328844,7.93333333 5.75555556,7.93333333 Z M15.8666667,7.93333333 L12.9111111,7.93333333 C12.6533782,7.93333333 12.4444444,7.72439955 12.4444444,7.46666667 C12.4444444,7.20893378 12.6533782,7 12.9111111,7 L15.8666667,7 C16.1243995,7 16.3333333,7.20893378 16.3333333,7.46666667 C16.3333333,7.72439955 16.1243995,7.93333333 15.8666667,7.93333333 Z" id="形状结合" fill="#6698FF"></path> </g> </g> </g> </svg>',
  date: "<svg width='1em' height='1em' viewBox='0 0 28 28' version='1.1' xmlns='http://www.w3.org/2000/svg'> <title>日期</title> <g stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'> <g> <rect fill='#FFFFFF' x='0' y='0' width='28' height='28' rx='4'></rect> <path d='M24,0 C26.209139,0 28,1.790861 28,4 L28,24 C28,26.209139 26.209139,28 24,28 L4,28 C1.790861,28 0,26.209139 0,24 L0,4 C0,1.790861 1.790861,0 4,0 L24,0 Z M24,1 L4,1 C2.34314575,1 1,2.34314575 1,4 L1,24 C1,25.6568542 2.34314575,27 4,27 L24,27 C25.6568542,27 27,25.6568542 27,24 L27,4 C27,2.34314575 25.6568542,1 24,1 Z' fill='#EEEEEE' fill-rule='nonzero' ></path> <g transform='translate(4.666667, 4.666667)'> <path d='M18.2666667,6.62222222 L18.2666667,17.1111111 C18.2666667,17.430209 18.1373267,17.7190979 17.9282123,17.9282123 C17.7190979,18.1373267 17.430209,18.2666667 17.1111111,18.2666667 L1.55555556,18.2666667 C1.2364577,18.2666667 0.947568811,18.1373267 0.738454386,17.9282123 C0.529339961,17.7190979 0.4,17.430209 0.4,17.1111111 L0.4,6.62222222 L18.2666667,6.62222222 Z M18.1333333,6.75555556 L0.509112478,6.75555556 L1.17926226,18.1481019 L18.1333333,17.4960222 L18.1333333,6.75555556 Z M17.0666667,1.95555556 C17.3980375,1.95555556 17.6980375,2.08987013 17.9151948,2.30702742 C18.1323521,2.52418471 18.2666667,2.82418471 18.2666667,3.15555556 L18.2666667,5.80985059 L0.4,5.80985059 L0.4,3.15555556 C0.4,2.82418471 0.534314575,2.52418471 0.751471863,2.30702742 C0.96862915,2.08987013 1.26862915,1.95555556 1.6,1.95555556 Z' stroke='#EEEEEE' stroke-width='0.8' fill='#EEEEEE' ></path> <rect fill='#DDDDDD' x='3.88888889' y='0' width='1.55555556' height='3.88888889' rx='0.777777778' ></rect> <rect fill='#DDDDDD' x='13.2222222' y='0' width='1.55555556' height='3.88888889' rx='0.777777778' ></rect> <path d='M2.8,10.1111111 L4.2,10.1111111 C4.45773288,10.1111111 4.66666667,10.3200449 4.66666667,10.5777778 C4.66666667,10.8355107 4.45773288,11.0444444 4.2,11.0444444 L2.8,11.0444444 C2.54226712,11.0444444 2.33333333,10.8355107 2.33333333,10.5777778 C2.33333333,10.3200449 2.54226712,10.1111111 2.8,10.1111111 Z M2.8,14 L4.2,14 C4.45773288,14 4.66666667,14.2089338 4.66666667,14.4666667 C4.66666667,14.7243995 4.45773288,14.9333333 4.2,14.9333333 L2.8,14.9333333 C2.54226712,14.9333333 2.33333333,14.7243995 2.33333333,14.4666667 C2.33333333,14.2089338 2.54226712,14 2.8,14 Z M6.68888889,10.1111111 L8.08888889,10.1111111 C8.34662177,10.1111111 8.55555556,10.3200449 8.55555556,10.5777778 C8.55555556,10.8355107 8.34662177,11.0444444 8.08888889,11.0444444 L6.68888889,11.0444444 C6.43115601,11.0444444 6.22222222,10.8355107 6.22222222,10.5777778 C6.22222222,10.3200449 6.43115601,10.1111111 6.68888889,10.1111111 Z M14.4666667,14 L15.8666667,14 C16.1243995,14 16.3333333,14.2089338 16.3333333,14.4666667 C16.3333333,14.7243995 16.1243995,14.9333333 15.8666667,14.9333333 L14.4666667,14.9333333 C14.2089338,14.9333333 14,14.7243995 14,14.4666667 C14,14.2089338 14.2089338,14 14.4666667,14 Z' fill='#CACACA' ></path> <path d='M6.68888889,14 L11.9777778,14 C12.2355107,14 12.4444444,14.2089338 12.4444444,14.4666667 C12.4444444,14.7243995 12.2355107,14.9333333 11.9777778,14.9333333 L6.68888889,14.9333333 C6.43115601,14.9333333 6.22222222,14.7243995 6.22222222,14.4666667 C6.22222222,14.2089338 6.43115601,14 6.68888889,14 Z' fill='#FF7575' ></path> <path d='M10.5777778,10.1111111 L15.8666667,10.1111111 C16.1243995,10.1111111 16.3333333,10.3200449 16.3333333,10.5777778 C16.3333333,10.8355107 16.1243995,11.0444444 15.8666667,11.0444444 L10.5777778,11.0444444 C10.3200449,11.0444444 10.1111111,10.8355107 10.1111111,10.5777778 C10.1111111,10.3200449 10.3200449,10.1111111 10.5777778,10.1111111 Z' fill='#6698FF' ></path> </g> </g> </g></svg>",
  label: "<svg width='1em' height='1em' viewBox='0 0 28 28' version='1.1' xmlns='http://www.w3.org/2000/svg'> <title>标签</title> <g stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'> <g> <rect fill='#FFFFFF' x='0' y='0' width='28' height='28' rx='4'></rect> <path d='M24,0 C26.209139,0 28,1.790861 28,4 L28,24 C28,26.209139 26.209139,28 24,28 L4,28 C1.790861,28 0,26.209139 0,24 L0,4 C0,1.790861 1.790861,0 4,0 L24,0 Z M24,1 L4,1 C2.34314575,1 1,2.34314575 1,4 L1,24 C1,25.6568542 2.34314575,27 4,27 L24,27 C25.6568542,27 27,25.6568542 27,24 L27,4 C27,2.34314575 25.6568542,1 24,1 Z' fill='#EEEEEE' fill-rule='nonzero' ></path> <g transform='translate(3.888889, 6.222222)'> <rect fill='#EEEEEE' x='0' y='0' width='9.33333333' height='3.88888889' rx='1.94444444' ></rect> <rect fill='#F6C659' opacity='0.300000012' x='0' y='6.22222222' width='9.33333333' height='3.88888889' rx='1.94444444' ></rect> <rect fill='#D287F8' opacity='0.300000012' x='0' y='12.4444444' width='9.33333333' height='3.88888889' rx='1.94444444' ></rect> <rect fill='#FF7575' opacity='0.300000012' x='10.8888889' y='0' width='9.33333333' height='3.88888889' rx='1.94444444' ></rect> <rect fill='#73D897' opacity='0.300000012' x='10.8888889' y='6.22222222' width='9.33333333' height='3.88888889' rx='1.94444444' ></rect> <rect fill='#56ABFB' opacity='0.300000012' x='10.8888889' y='12.4444444' width='9.33333333' height='3.88888889' rx='1.94444444' ></rect> <path d='M7.77777778,2.02222222 C7.77777778,2.27995511 7.56884399,2.48888889 7.31111111,2.48888889 L2.02222222,2.48888889 C1.76448934,2.48888889 1.55555556,2.27995511 1.55555556,2.02222222 C1.55555556,1.76448934 1.76448934,1.55555556 2.02222222,1.55555556 L7.31111111,1.55555556 C7.56884399,1.55555556 7.77777778,1.76448934 7.77777778,2.02222222 Z' fill='#CACACA' fill-rule='nonzero' ></path> <path d='M7.77777778,8.24444444 C7.77777778,8.50217733 7.56884399,8.71111111 7.31111111,8.71111111 L2.02222222,8.71111111 C1.76448934,8.71111111 1.55555556,8.50217733 1.55555556,8.24444444 C1.55555556,7.98671156 1.76448934,7.77777778 2.02222222,7.77777778 L7.31111111,7.77777778 C7.56884399,7.77777778 7.77777778,7.98671156 7.77777778,8.24444444 Z' fill='#FFCD5D' fill-rule='nonzero' ></path> <path d='M7.77777778,14.4666667 C7.77777778,14.7243995 7.56884399,14.9333333 7.31111111,14.9333333 L2.02222222,14.9333333 C1.76448934,14.9333333 1.55555556,14.7243995 1.55555556,14.4666667 C1.55555556,14.2089338 1.76448934,14 2.02222222,14 L7.31111111,14 C7.56884399,14 7.77777778,14.2089338 7.77777778,14.4666667 Z' fill='#D287F8' fill-rule='nonzero' ></path> <path d='M18.6666667,2.02222222 C18.6666667,2.27995511 18.4577329,2.48888889 18.2,2.48888889 L12.9111111,2.48888889 C12.6533782,2.48888889 12.4444444,2.27995511 12.4444444,2.02222222 C12.4444444,1.76448934 12.6533782,1.55555556 12.9111111,1.55555556 L18.2,1.55555556 C18.4577329,1.55555556 18.6666667,1.76448934 18.6666667,2.02222222 Z' fill='#FF7575' fill-rule='nonzero' ></path> <path d='M18.6666667,8.24444444 C18.6666667,8.50217733 18.4577329,8.71111111 18.2,8.71111111 L12.9111111,8.71111111 C12.6533782,8.71111111 12.4444444,8.50217733 12.4444444,8.24444444 C12.4444444,7.98671156 12.6533782,7.77777778 12.9111111,7.77777778 L18.2,7.77777778 C18.4577329,7.77777778 18.6666667,7.98671156 18.6666667,8.24444444 Z' fill='#73D897' fill-rule='nonzero' ></path> <path d='M18.6666667,14.4666667 C18.6666667,14.7243995 18.4577329,14.9333333 18.2,14.9333333 L12.9111111,14.9333333 C12.6533782,14.9333333 12.4444444,14.7243995 12.4444444,14.4666667 C12.4444444,14.2089338 12.6533782,14 12.9111111,14 L18.2,14 C18.4577329,14 18.6666667,14.2089338 18.6666667,14.4666667 Z' fill='#56ABFB' fill-rule='nonzero' ></path> </g> </g> </g></svg>",
  promptBox: "<svg width='1em' height='1em' viewBox='0 0 28 28' version='1.1' xmlns='http://www.w3.org/2000/svg'> <title>提示框</title> <defs> <rec x='1' y='1' width='26' height='26' rx='4'></rect> </defs> <g stroke='none' stroke-width='1' fill='none' fill-rule='evenodd'> <g > <rect fill='#FFFFFF' x='0' y='0' width='28' height='28' rx='3.2' ></rect> <path d='M24.8,0 C26.5673112,0 28,1.4326888 28,3.2 L28,24.8 C28,26.5673112 26.5673112,28 24.8,28 L3.2,28 C1.4326888,28 0,26.5673112 0,24.8 L0,3.2 C0,1.4326888 1.4326888,0 3.2,0 L24.8,0 Z M24.8,1 L3.2,1 C1.98497355,1 1,1.98497355 1,3.2 L1,24.8 C1,26.0150264 1.98497355,27 3.2,27 L24.8,27 C26.0150264,27 27,26.0150264 27,24.8 L27,3.2 C27,1.98497355 26.0150264,1 24.8,1 Z' fill='#EEEEEE' fill-rule='nonzero' ></path> <mask fill='white'> <use xlink:href='#path-1'></use> </mask> <use fill='#FFFFFF' xlink:href='#path-1'></use> <g mask='url(#mask-2)'> <g transform='translate(4.666667, 7.000000)'> <rect fill='#5DCFFF' opacity='0.200000003' x='0' y='0' width='33.4444444' height='14' rx='1.6' ></rect> <path d='M12.9111111,8.55555556 L15.8666667,8.55555556 C16.1243995,8.55555556 16.3333333,8.76448934 16.3333333,9.02222222 C16.3333333,9.27995511 16.1243995,9.48888889 15.8666667,9.48888889 L12.9111111,9.48888889 C12.6533782,9.48888889 12.4444444,9.27995511 12.4444444,9.02222222 C12.4444444,8.76448934 12.6533782,8.55555556 12.9111111,8.55555556 Z M12.9111111,4.66666667 L23.6444444,4.66666667 C23.9021773,4.66666667 24.1111111,4.87560045 24.1111111,5.13333333 C24.1111111,5.39106622 23.9021773,5.6 23.6444444,5.6 L12.9111111,5.6 C12.6533782,5.6 12.4444444,5.39106622 12.4444444,5.13333333 C12.4444444,4.87560045 12.6533782,4.66666667 12.9111111,4.66666667 Z' fill='#5DCFFF' ></path> <g stroke-width='1' fill='none' transform='translate(3.111111, 3.888889)' > <pat  d='M3.11111111,-8.8817842e-16 C4.82222222,-8.8817842e-16 6.22222222,1.4 6.22222222,3.11111111 C6.22222222,4.82222222 4.82222222,6.22222222 3.11111111,6.22222222 C1.4,6.22222222 0,4.82222222 0,3.11111111 C0,1.4 1.4,-8.8817842e-16 3.11111111,-8.8817842e-16 Z M2.85139179,2.72012729 L2.83967627,4.6768138 L3.3841145,4.6794151 L3.39583002,2.72272859 L2.85139179,2.72012729 Z M2.87813929,1.54282507 L2.87038639,2.32474454 L3.50268048,2.33249744 L3.51043338,1.55057797 L2.87813929,1.54282507 Z'  fill='#5DCFFF' ></path> </g> </g> </g> </g> </g></svg>",
  mindMap: '<svg width="1em" height="1em" viewBox="0 0 28 28" version="1.1" xmlns="http://www.w3.org/2000/svg" fit="" preserveAspectRatio="xMidYMid meet" focusable="false"> <title>思维导图</title> <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"> <g id="icon"> <rect fill="#FFFFFF" x="0" y="0" width="28" height="28" rx="4"></rect> <path d="M24,0 C26.209139,0 28,1.790861 28,4 L28,24 C28,26.209139 26.209139,28 24,28 L4,28 C1.790861,28 0,26.209139 0,24 L0,4 C0,1.790861 1.790861,0 4,0 L24,0 Z M24,1 L4,1 C2.34314575,1 1,2.34314575 1,4 L1,24 C1,25.6568542 2.34314575,27 4,27 L24,27 C25.6568542,27 27,25.6568542 27,24 L27,4 C27,2.34314575 25.6568542,1 24,1 Z" fill="#EEEEEE" fill-rule="nonzero"></path> <g id="编组-26" transform="translate(3.888889, 5.833333)"> <rect id="矩形" fill="#CACACA" x="7" y="7.77777778" width="5.44444444" height="1"></rect> <path d="M12.4444444,14.7777778 L11.3222222,14.7777778 C10.4385666,14.7777778 9.72222222,14.0614334 9.72222222,13.1777778 L9.72222222,3.15555556 C9.72222222,2.27189996 10.4385666,1.55555556 11.3222222,1.55555556 L12.4444444,1.55555556 L12.4444444,1.55555556" stroke="#CACACA" stroke-width="0.96"></path> <path d="M13.2444444,0 L18.6444444,0 C19.0862722,2.00237164e-16 19.4444444,0.3581722 19.4444444,0.8 L19.4444444,2.31111111 C19.4444444,2.75293891 19.0862722,3.11111111 18.6444444,3.11111111 L13.2444444,3.11111111 C12.8026166,3.11111111 12.4444444,2.75293891 12.4444444,2.31111111 L12.4444444,0.8 C12.4444444,0.3581722 12.8026166,-2.98598523e-17 13.2444444,0 Z" id="矩形备份-68" fill="#6698FF" opacity="0.300000012"></path> <rect fill="#73D897" opacity="0.300000012" x="12.4444444" y="6.61111111" width="7" height="3.11111111" rx="0.8"></rect> <path d="M13.2444444,13.2222222 L18.6444444,13.2222222 C19.0862722,13.2222222 19.4444444,13.5803944 19.4444444,14.0222222 L19.4444444,15.5333333 C19.4444444,15.9751611 19.0862722,16.3333333 18.6444444,16.3333333 L13.2444444,16.3333333 C12.8026166,16.3333333 12.4444444,15.9751611 12.4444444,15.5333333 L12.4444444,14.0222222 C12.4444444,13.5803944 12.8026166,13.2222222 13.2444444,13.2222222 Z" fill="#FF7575" opacity="0.300000012"></path> <path d="M17.8888889,1.64666667 C17.8888889,1.91176335 17.6739856,2.12666667 17.4088889,2.12666667 L14.48,2.12666667 C14.2149033,2.12666667 14,1.91176335 14,1.64666667 C14,1.38156999 14.2149033,1.16666667 14.48,1.16666667 L17.4088889,1.16666667 C17.6739856,1.16666667 17.8888889,1.38156999 17.8888889,1.64666667 Z" id="直线-7备份-6" fill="#6698FF" fill-rule="nonzero"></path> <path d="M17.8888889,8.25777778 C17.8888889,8.52287446 17.6739856,8.73777778 17.4088889,8.73777778 L14.48,8.73777778 C14.2149033,8.73777778 14,8.52287446 14,8.25777778 C14,7.9926811 14.2149033,7.77777778 14.48,7.77777778 L17.4088889,7.77777778 C17.6739856,7.77777778 17.8888889,7.9926811 17.8888889,8.25777778 Z" id="直线-7备份-7" fill="#73D897" fill-rule="nonzero"></path> <path d="M17.8888889,14.8688889 C17.8888889,15.1339856 17.6739856,15.3488889 17.4088889,15.3488889 L14.48,15.3488889 C14.2149033,15.3488889 14,15.1339856 14,14.8688889 C14,14.6037922 14.2149033,14.3888889 14.48,14.3888889 L17.4088889,14.3888889 C17.6739856,14.3888889 17.8888889,14.6037922 17.8888889,14.8688889 Z" id="直线-7备份-8" fill="#FF7575" fill-rule="nonzero"></path> <path d="M1.6,5.44444444 L5.4,5.44444444 C6.2836556,5.44444444 7,6.16078884 7,7.04444444 L7,9.28888889 C7,10.1725445 6.2836556,10.8888889 5.4,10.8888889 L1.6,10.8888889 C0.7163444,10.8888889 3.30261205e-16,10.1725445 0,9.28888889 L0,7.04444444 C1.13828005e-16,6.16078884 0.7163444,5.44444444 1.6,5.44444444 Z" fill="#EEEEEE"></path> </g> </g> </g> </svg>',
  audio: '<svg width="1em" height="1em" viewBox="0 0 28 28" version="1.1" xmlns="http://www.w3.org/2000/svg" fit="" preserveAspectRatio="xMidYMid meet" focusable="false"> <title>音频</title> <g id="音频" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"> <g id="icon"> <rect fill="#FFFFFF" x="0" y="0" width="28" height="28" rx="4"></rect> <path d="M24,0 C26.209139,0 28,1.790861 28,4 L28,24 C28,26.209139 26.209139,28 24,28 L4,28 C1.790861,28 0,26.209139 0,24 L0,4 C0,1.790861 1.790861,0 4,0 L24,0 Z M24,1 L4,1 C2.34314575,1 1,2.34314575 1,4 L1,24 C1,25.6568542 2.34314575,27 4,27 L24,27 C25.6568542,27 27,25.6568542 27,24 L27,4 C27,2.34314575 25.6568542,1 24,1 Z" id="矩形" fill="#EEEEEE" fill-rule="nonzero"></path> <g transform="translate(4.666667, 7.000000)"> <ellipse fill="#CACACA" cx="9.33333333" cy="7" rx="2.33333333" ry="3.11111111"></ellipse> <path d="M2.69356086,9.2803178 L0.690789474,9.2803178 C0.309276809,9.2803178 0,8.97105135 0,8.58952833 L0,5.35862792 C0,4.9771049 0.309276809,4.66783845 0.690789474,4.66783845 L2.69356086,4.66783845 C2.69356086,4.66783845 2.69356086,9.2803178 2.69356086,9.2803178 Z" id="路径" fill="#DDDDDD"></path> <path d="M9.24122807,0 L9.24122807,14 C6.82346491,14 2.69356086,9.2803178 2.69356086,9.2803178 L2.69356086,4.66783845 C2.69356086,4.66783845 6.82346491,0 9.24122807,0 Z" id="路径" fill="#F5F5F5"></path> <path d="M14.4666667,6.67859506 L16.7559366,6.67859506 C17.0136695,6.67859506 17.2226033,6.88752885 17.2226033,7.14526173 C17.2226033,7.40299461 17.0136695,7.6119284 16.7559366,7.6119284 L14.4666667,7.6119284 C14.2089338,7.6119284 14,7.40299461 14,7.14526173 C14,6.88752885 14.2089338,6.67859506 14.4666667,6.67859506 Z" id="矩形备份-74" fill="#73D897"></path> <path d="M14.4666667,2.33333333 L18.927827,2.33333333 C19.1855599,2.33333333 19.3944936,2.54226712 19.3944936,2.8 C19.3944936,3.05773288 19.1855599,3.26666667 18.927827,3.26666667 L14.4666667,3.26666667 C14.2089338,3.26666667 14,3.05773288 14,2.8 C14,2.54226712 14.2089338,2.33333333 14.4666667,2.33333333 Z" id="矩形备份-75" fill="#6698FF"></path> <path d="M14.4666667,11.0238568 L18.927827,11.0238568 C19.1855599,11.0238568 19.3944936,11.2327906 19.3944936,11.4905235 C19.3944936,11.7482563 19.1855599,11.9571901 18.927827,11.9571901 L14.4666667,11.9571901 C14.2089338,11.9571901 14,11.7482563 14,11.4905235 C14,11.2327906 14.2089338,11.0238568 14.4666667,11.0238568 Z" id="矩形备份-77" fill="#FF7575"></path> </g> </g> </g> </svg>',
  formula: '<svg width="1em" height="1em" viewBox="0 0 28 28" version="1.1" xmlns="http://www.w3.org/2000/svg" fit="" preserveAspectRatio="xMidYMid meet" focusable="false"> <title>公式</title> <g stroke="none" stroke-width="1" fill="none" fill-rule="evenodd"> <g id="icon"> <rect fill="#FFFFFF" x="0" y="0" width="28" height="28" rx="4"></rect> <path d="M24,0 C26.209139,0 28,1.790861 28,4 L28,24 C28,26.209139 26.209139,28 24,28 L4,28 C1.790861,28 0,26.209139 0,24 L0,4 C0,1.790861 1.790861,0 4,0 L24,0 Z M24,1 L4,1 C2.34314575,1 1,2.34314575 1,4 L1,24 C1,25.6568542 2.34314575,27 4,27 L24,27 C25.6568542,27 27,25.6568542 27,24 L27,4 C27,2.34314575 25.6568542,1 24,1 Z" id="矩形" fill="#EEEEEE" fill-rule="nonzero"></path> <g transform="translate(6.222222, 6.222222)"> <path d="M0.466666667,16.3333333 L8.08888889,16.3333333 C8.34662177,16.3333333 8.55555556,16.5422671 8.55555556,16.8 C8.55555556,17.0577329 8.34662177,17.2666667 8.08888889,17.2666667 L0.466666667,17.2666667 C0.208933783,17.2666667 3.15631751e-17,17.0577329 0,16.8 C-3.15631751e-17,16.5422671 0.208933783,16.3333333 0.466666667,16.3333333 Z M0.466666667,13.2222222 L15.0888889,13.2222222 C15.3466218,13.2222222 15.5555556,13.431156 15.5555556,13.6888889 C15.5555556,13.9466218 15.3466218,14.1555556 15.0888889,14.1555556 L0.466666667,14.1555556 C0.208933783,14.1555556 3.15631751e-17,13.9466218 0,13.6888889 C-3.15631751e-17,13.431156 0.208933783,13.2222222 0.466666667,13.2222222 Z" id="形状结合" fill="#CACACA"></path> <path d="M7.29125451,0 C7.38377228,0 7.47325862,0.03098981 7.54722121,0.0875155065 L7.59958726,0.13461254 L8.32633451,0.900605806 C8.49662199,1.08008919 8.49662199,1.37108926 8.32633451,1.55057265 C8.17496787,1.71011343 7.94000374,1.72784019 7.77005987,1.60375291 L7.70966902,1.55057265 L7.11011022,0.919191919 L2.20294226,0.919191919 L5.86172644,4.73057214 C6.01309309,4.89011292 6.0299116,5.13776566 5.91218199,5.31688688 L5.86172644,5.38053898 L1.48925255,9.19191919 L7.21088891,9.19191919 L7.81117445,8.56053847 C7.9625411,8.40099768 8.19750523,8.38327092 8.3674491,8.5073582 L8.42783995,8.56053847 C8.57920659,8.72007925 8.59602511,8.96773199 8.4782955,9.14685321 L8.42783995,9.21050531 L7.70109269,9.97649857 C7.63567275,10.0454513 7.55160597,10.0902317 7.46138469,10.1053857 L7.39275995,10.1111111 L0.436922523,10.1111111 C0.0727247798,10.1111111 -0.121029049,9.67600851 0.0825161905,9.38305589 L0.128589776,9.32653173 L4.93638527,5.05555556 L0.841552739,0.784579379 C0.584026044,0.513145656 0.738922096,0.0610784438 1.07938574,0.00563033025 L1.14988549,0 L7.29125451,0 Z M13.4123521,6.36326594 C13.4835613,6.26668286 13.5653385,6.17894359 13.6560525,6.10179832 C13.7739326,6.14537625 13.9131899,6.18895419 14.0738245,6.23253213 C14.2338105,6.27601914 14.3985524,6.29798932 14.5639737,6.29789904 C14.8254058,6.30337896 15.0782142,6.20113169 15.2666735,6.0136951 C15.4633399,5.81548898 15.5681255,5.53943359 15.5543498,5.25581792 C15.5625234,5.03769835 15.4836884,4.82568311 15.3363022,4.66941046 C15.1932921,4.51889384 14.9960721,4.43684042 14.7920992,4.44299465 C14.5276073,4.44184652 14.2723055,4.54325127 14.076573,4.72719859 C13.79695,5.00734436 13.5561581,5.32614942 13.3610468,5.67454506 C13.305466,5.76927971 13.2388913,5.87854033 13.1613225,6.00232694 L12.7001548,6.55130253 C12.6378555,6.27846675 12.57464,5.99994689 12.5059275,5.71290091 C12.085407,3.96315198 10.6900851,4.30787901 10.2805586,4.48219077 C9.8389663,4.67166006 9.9571518,5.09512393 10.194439,4.98333705 C10.4166026,4.85295335 10.6857788,4.84072112 10.9181474,4.95044941 C11.1505161,5.0601777 11.3178523,5.27853825 11.3680485,5.53753473 C11.5668567,6.24899193 11.7134433,6.89792426 11.8508683,7.46822683 C11.7478048,7.62153899 11.403818,8.05305748 11.2859293,8.19448666 C11.2112337,8.28582736 11.1304112,8.37161645 11.0440613,8.45121756 C10.9090794,8.40069241 10.7652412,8.35427244 10.6125468,8.31195763 C10.4564339,8.269741 10.2956695,8.2487227 10.1343078,8.24943276 C9.87263241,8.24411775 9.61959814,8.34632312 9.43069178,8.5336367 C9.23123516,8.73520831 9.1254105,9.01585021 9.14026694,9.30382938 C9.13218953,9.51704512 9.20928522,9.72430908 9.35345807,9.87697219 C9.49763092,10.0296353 9.69618572,10.1142547 9.90251761,10.1109686 C10.1692308,10.1154591 10.427396,10.0136988 10.6235408,9.82676463 C10.8971525,9.54472709 11.1359499,9.22875305 11.3344861,8.88604959 C11.4206058,8.747737 11.4862644,8.64037107 11.531462,8.56395179 C11.5736056,8.49195346 11.876521,8.09631754 11.9690538,7.95232088 C12.0491926,8.58451479 12.347946,9.16533971 12.8100948,9.58744088 C13.5199368,9.89948674 14.0990436,10.1179285 14.7536202,9.69603082 C15.044045,9.52456111 14.9478475,9.16078006 14.7536202,9.22804166 C14.4839818,9.40974328 13.8958539,9.57918911 13.646555,9.36871093 C13.1802062,8.68324372 12.8921623,7.88528807 12.8100948,7.05150147 C12.9469091,6.85319028 13.3048553,6.49778914 13.4123521,6.36326594 Z" id="形状结合" fill="#666666" fill-rule="nonzero"></path> </g> </g> </g> </svg>'
}, V2 = () => [
  new ma("base", "", "基础"),
  new ma("graph", "", "图形"),
  new ma("file", "", "文件")
], Fd = () => [
  new Gn("layout", Wn.layout, "base", "布局", "", !1),
  new Gn(
    "date",
    Wn.date,
    "base",
    "日期",
    Oa().format("YYYY-MM-DD"),
    !0
  ),
  new Gn("label", Wn.label, "base", "标签", "", !0),
  new Gn("prompt-box", Wn.promptBox, "base", "提示框", "", !1),
  new Gn("formula", Wn.formula, "base", "LaTex 公式", "", !0),
  new Gn("mind-map", Wn.mindMap, "graph", "思维导图", "", !1),
  new Gn("audio", Wn.audio, "file", "本地音频", "", !1)
];
const H2 = (s, e) => e.text.toLowerCase().includes(s), U2 = /* @__PURE__ */ me({
  name: "IBizInsertItemList",
  props: {
    data: {
      type: Object,
      required: !0
    },
    filter: {
      type: String,
      default: ""
    },
    categories: {
      type: Object,
      required: !0,
      default: () => {
      }
    },
    hasSearch: {
      type: Boolean
    }
  },
  emits: ["select", "data"],
  setup(s, {
    emit: e
  }) {
    const t = we("insert-item-list"), n = T({}), i = Ge(() => Object.keys(s.data)), r = Ge(() => {
      const c = {};
      Object.assign(c, s.data);
      const u = s.filter.trim().toLowerCase();
      return u && i.value.forEach((f) => {
        c[f] = s.data[f].filter((d) => H2(u, d));
      }), c;
    }), o = (c) => {
      e("select", c);
    }, a = (c) => {
      const {
        icon: u,
        text: f
      } = c;
      return M("div", {
        class: [t.e("insert-item")],
        onClick: () => o(c)
      }, [u ? M("div", {
        class: t.em("insert-item", "icon"),
        innerHTML: u
      }, null) : "", M("div", {
        class: t.em("insert-item", "text")
      }, [f])]);
    };
    return {
      ns: t,
      InsertItemsRef: n,
      dataFilteredByCategory: r,
      onSelect: o,
      renderListInsertItems: (c) => {
        const {
          insertSelect: u,
          style: f
        } = c;
        return u && u.length > 0 ? M("div", {
          class: [t.e("list-insert-items")],
          style: f
        }, [u.map((d) => a(d))]) : "";
      }
    };
  },
  render() {
    return M("div", {
      class: [this.ns.b()]
    }, [M("div", {
      ref: "InsertItemsRef",
      class: [this.ns.e("container")]
    }, [Object.keys(this.dataFilteredByCategory).map((s) => {
      const e = this.dataFilteredByCategory[s], t = this.categories[s], n = t ? t.text : s;
      return M("div", null, [e.length ? M("div", {
        class: this.ns.e("label")
      }, [n]) : "", this.renderListInsertItems({
        insertSelect: e
      })]);
    })])]);
  }
});
function q2(s) {
  const e = T([]), t = T({
    Authorization: "Bearer ".concat(pl(ml.TOKEN))
  }), n = T(""), i = T(""), r = {
    count: 0,
    cacheFiles: []
    // iview上传过程中不能改default-file-list,所以需要缓存
  }, o = Ge(() => r.count);
  if (s.context && s.actionParams) {
    const m = ibiz.util.file.calcFileUpDownUrl(
      s.context,
      s.viewParams,
      {},
      s.actionParams
    );
    n.value = m.uploadUrl, i.value = m.downloadUrl;
  }
  const a = () => {
    const m = r.cacheFiles, w = m.length > 0 ? m : null;
    r.cacheFiles = [], s.modal.dismiss({ ok: !0, data: w });
  }, l = (m) => {
    const w = m.size / 1024 / 1024;
    return s.size && w > s.size ? (ibiz.message.error(
      "".concat(ibiz.i18n.t("editor.upload.fileSizeErr"), " ").concat(s.size, "MB!")
    ), !1) : (r.count += 1, !0);
  }, c = (m) => {
    m && (r.cacheFiles.push({
      id: m.fileid,
      name: m.filename,
      ext: m.ext,
      folder: m.folder,
      size: m.size,
      url: m.rul || i.value.replace("%fileId%", m.fileid)
    }), r.count -= 1);
  }, u = (...m) => {
    const w = m[0];
    throw r.count -= 1, new sp({
      response: { data: JSON.parse(w.message), status: w.status }
    });
  }, f = (m) => {
    if (s.disabled)
      return;
    if (r.count === 0) {
      const v = r.cacheFiles.findIndex(
        (y) => m.response && y.id === m.response.id
      );
      v !== -1 && r.cacheFiles.splice(v, 1);
    }
    const w = e.value.findIndex((v) => v.id === m.id);
    w !== -1 && e.value.splice(w, 1);
  }, d = Ge(() => s.multiple ? 9999 : 1);
  return {
    uploadUrl: n,
    headers: t,
    files: e,
    limit: d,
    filesCount: o,
    onError: u,
    onRemove: f,
    onSuccess: c,
    beforeUpload: l,
    onConfirm: () => {
      a();
    },
    onCancel: () => {
      r.cacheFiles = [], a();
    }
  };
}
const G2 = /* @__PURE__ */ me({
  name: "UploadCustom",
  props: {
    modal: {
      type: Object,
      required: !0
    },
    context: {
      type: Object,
      default: () => {
      }
    },
    viewParams: {
      type: Object,
      default: () => {
      }
    },
    actionParams: {
      type: Object,
      default: () => {
      }
    }
  },
  setup(s) {
    const e = we("upload-custom"), {
      uploadUrl: t,
      headers: n,
      files: i,
      limit: r,
      onError: o,
      onRemove: a,
      onSuccess: l,
      beforeUpload: c,
      onConfirm: u,
      onCancel: f
    } = q2({
      ...s,
      multiple: !0
    });
    return {
      ns: e,
      files: i,
      limit: r,
      uploadUrl: t,
      headers: n,
      onError: o,
      onRemove: a,
      onSuccess: l,
      beforeUpload: c,
      onConfirm: u,
      onCancel: f
    };
  },
  render() {
    return M("div", {
      class: [this.ns.b()]
    }, [M("div", {
      class: [this.ns.e("center")]
    }, [M(Ie("el-upload"), {
      class: [this.ns.em("center", "upload")],
      modelValue: this.files,
      "onUpdate:modelValue": (s) => this.files = s,
      action: this.uploadUrl,
      headers: this.headers,
      limit: this.limit,
      multiple: !0,
      accept: "audio/*",
      drag: !0,
      "auto-upload": !0,
      "before-upload": this.beforeUpload,
      onSuccess: this.onSuccess,
      onError: this.onError,
      onRemove: this.onRemove
    }, {
      default: () => M("i", {
        class: "el-icon"
      }, [M("svg", {
        xmlns: "http://www.w3.org/2000/svg",
        viewBox: "0 0 1024 1024"
      }, [M("path", {
        fill: "currentColor",
        d: "M480 480V128a32 32 0 0 1 64 0v352h352a32 32 0 1 1 0 64H544v352a32 32 0 1 1-64 0V544H128a32 32 0 0 1 0-64z"
      }, null)])])
    })]), M("div", {
      class: [this.ns.e("bottom")]
    }, [M(Ie("el-button"), {
      onClick: this.onCancel
    }, {
      default: () => [tt("取消")]
    }), M(Ie("el-button"), {
      onClick: this.onConfirm
    }, {
      default: () => [tt("确认")]
    })])]);
  }
}), W2 = /* @__PURE__ */ me({
  name: "IBizHtmlInsertSelect",
  props: {
    modal: {
      type: Object,
      required: !0
    },
    context: {
      type: Object,
      default: () => {
      }
    },
    viewParams: {
      type: Object,
      default: () => {
      }
    },
    actionParams: {
      type: Object,
      default: () => {
      }
    }
  },
  emits: ["select"],
  setup(s) {
    const e = we("html-insert-select"), t = T(""), n = T([]), i = T({}), r = T([]), o = T({}), a = (d) => {
      Object.assign(i.value, {
        frequently: []
      }), d.filter((g) => !r.value.includes(g)).forEach((g) => {
        const p = g.category;
        i.value[p] || Object.assign(i.value, {
          [p]: []
        }), i.value[p].push(g);
      });
    }, l = (d) => {
      d.forEach((g) => {
        Object.assign(o.value, {
          [g.type]: g
        });
      });
    }, c = async (d) => {
      const g = {
        ok: !0,
        data: []
      }, p = await ibiz.overlay.modal((m) => oi(G2, {
        modal: m,
        context: s.context,
        viewParams: s.viewParams,
        actionParams: s.actionParams
      }), void 0, {
        width: "auto",
        height: "auto"
      });
      p.ok && p.data && p.data.length > 0 && p.data.forEach((m) => {
        var w;
        (w = g.data) == null || w.push({
          type: d.type,
          value: m,
          params: {
            isAdd: !0
          }
        });
      }), s.modal.dismiss(g);
    }, u = (d) => {
      const g = {
        ok: !0,
        data: [{
          type: d.type,
          value: d.value,
          params: {
            isAdd: !0
          }
        }]
      };
      s.modal.dismiss(g);
    }, f = async (d) => {
      switch (d.type) {
        case "audio":
          await c(d);
          break;
        default:
          u(d);
          break;
      }
    };
    return hn(() => {
      i.value = {}, a(Fd()), n.value = V2(), l(n.value);
    }), {
      ns: e,
      mapInsertItems: i,
      mapCategories: o,
      searchVal: t,
      onSelectItem: f
    };
  },
  render() {
    const s = M("div", {
      class: [this.ns.b("search")]
    }, [M("div", {
      class: this.ns.be("search", "container")
    }, [M("div", {
      class: this.ns.bem("search", "container", "search")
    }, [M("svg", {
      viewBox: "0 0 16 16",
      xmlns: "http://www.w3.org/2000/svg",
      height: "1em",
      width: "1em",
      focusable: "false"
    }, [M("g", {
      "stroke-width": "1"
    }, [M("path", {
      d: "M6.751 12.303A5.557 5.557 0 0 1 1.2 6.751C1.2 3.691 3.69 1.2 6.751 1.2a5.558 5.558 0 0 1 5.551 5.551 5.557 5.557 0 0 1-5.551 5.552M6.751 0a6.751 6.751 0 1 0 4.309 11.949l3.855 3.855a.6.6 0 1 0 .849-.849l-3.854-3.853A6.751 6.751 0 0 0 6.751 0"
    }, null)])])]), ri(M("input", {
      class: this.ns.bem("search", "container", "input"),
      type: "text",
      "onUpdate:modelValue": (e) => this.searchVal = e,
      placeholder: ibiz.i18n.t("app.search")
    }, null), [[fl, this.searchVal]])])]);
    return M("div", {
      class: this.ns.b()
    }, [s, M(U2, {
      data: this.mapInsertItems,
      filter: this.searchVal,
      categories: this.mapCategories,
      onSelect: this.onSelectItem
    }, null)]);
  }
});
/*! Element Plus v2.4.3 */
var J2 = {
  name: "zh-cn",
  el: {
    colorpicker: {
      confirm: "确定",
      clear: "清空"
    },
    datepicker: {
      now: "此刻",
      today: "今天",
      cancel: "取消",
      clear: "清空",
      confirm: "确定",
      selectDate: "选择日期",
      selectTime: "选择时间",
      startDate: "开始日期",
      startTime: "开始时间",
      endDate: "结束日期",
      endTime: "结束时间",
      prevYear: "前一年",
      nextYear: "后一年",
      prevMonth: "上个月",
      nextMonth: "下个月",
      year: "年",
      month1: "1 月",
      month2: "2 月",
      month3: "3 月",
      month4: "4 月",
      month5: "5 月",
      month6: "6 月",
      month7: "7 月",
      month8: "8 月",
      month9: "9 月",
      month10: "10 月",
      month11: "11 月",
      month12: "12 月",
      weeks: {
        sun: "日",
        mon: "一",
        tue: "二",
        wed: "三",
        thu: "四",
        fri: "五",
        sat: "六"
      },
      months: {
        jan: "一月",
        feb: "二月",
        mar: "三月",
        apr: "四月",
        may: "五月",
        jun: "六月",
        jul: "七月",
        aug: "八月",
        sep: "九月",
        oct: "十月",
        nov: "十一月",
        dec: "十二月"
      }
    },
    select: {
      loading: "加载中",
      noMatch: "无匹配数据",
      noData: "无数据",
      placeholder: "请选择"
    },
    cascader: {
      noMatch: "无匹配数据",
      loading: "加载中",
      placeholder: "请选择",
      noData: "暂无数据"
    },
    pagination: {
      goto: "前往",
      pagesize: "条/页",
      total: "共 {total} 条",
      pageClassifier: "页",
      page: "页",
      prev: "上一页",
      next: "下一页",
      currentPage: "第 {pager} 页",
      prevPages: "向前 {pager} 页",
      nextPages: "向后 {pager} 页",
      deprecationWarning: "你使用了一些已被废弃的用法，请参考 el-pagination 的官方文档"
    },
    messagebox: {
      title: "提示",
      confirm: "确定",
      cancel: "取消",
      error: "输入的数据不合法!"
    },
    upload: {
      deleteTip: "按 delete 键可删除",
      delete: "删除",
      preview: "查看图片",
      continue: "继续上传"
    },
    table: {
      emptyText: "暂无数据",
      confirmFilter: "筛选",
      resetFilter: "重置",
      clearFilter: "全部",
      sumText: "合计"
    },
    tree: {
      emptyText: "暂无数据"
    },
    transfer: {
      noMatch: "无匹配数据",
      noData: "无数据",
      titles: ["列表 1", "列表 2"],
      filterPlaceholder: "请输入搜索内容",
      noCheckedFormat: "共 {total} 项",
      hasCheckedFormat: "已选 {checked}/{total} 项"
    },
    image: {
      error: "加载失败"
    },
    pageHeader: {
      title: "返回"
    },
    popconfirm: {
      confirmButtonText: "确定",
      cancelButtonText: "取消"
    }
  }
};
const Ds = (s, e = {}, t = {}) => ibiz.overlay.createPopover(
  (n) => oi(s, { modal: n, ...t }),
  void 0,
  {
    width: "auto",
    height: "auto",
    noArrow: !0,
    autoClose: !0,
    placement: "bottom-start",
    ...e
  }
);
function fi() {
  return {
    data: { type: Object, required: !0 },
    change: { type: Function, required: !0 },
    nodeKey: { type: String, default: "" },
    isFocus: { type: Boolean, default: !1 },
    readonly: { type: Boolean, default: !1 }
  };
}
const Ro = (s) => {
  (document.getElementsByClassName(s) || []).forEach((t) => {
    t.remove();
  });
};
const Y2 = /* @__PURE__ */ me({
  name: "IBizDateSelect",
  props: fi(),
  emits: ["change"],
  setup(s) {
    const e = we("date-select"), t = T(), n = T("");
    return s.data && (n.value = Oa(s.data).format("YYYY-MM-DD")), s.isFocus && Ne(t, (r) => {
      r && r.focus && r.focus();
    }), {
      ns: e,
      dateVal: n,
      dateRef: t,
      handleChange: (r) => {
        const o = Oa(r).format("YYYY-MM-DD");
        n.value = o;
        let a = setTimeout(() => {
          s.change(o), clearTimeout(a), a = null;
        }, 200);
      }
    };
  },
  render() {
    return M("div", {
      class: [this.ns.b(), this.readonly ? this.ns.m("readonly") : ""]
    }, [M(Ie("el-date-picker"), {
      ref: "dateRef",
      "popper-class": [this.ns.e("popover"), "".concat(this.nodeKey)],
      modelValue: this.dateVal,
      "onUpdate:modelValue": (s) => this.dateVal = s,
      onChange: this.handleChange
    }, null)]);
  }
});
const X2 = /* @__PURE__ */ me({
  name: "IBizLabelSelect",
  props: fi(),
  setup(s) {
    const e = we("label-select"), t = (p) => p.replace(")", ",0.196)"), n = ["rgba(207, 207, 207)", "rgb(255, 117, 117)", "rgb(246, 198, 89)", "rgb(115, 216, 151)", "rgb(210, 135, 248)", "rgb(86, 171, 251)"], i = T(), r = T(), o = T(), a = Wh({
      color: n[0],
      bgColor: t(n[0]),
      labelName: ""
    }), l = T("");
    s != null && s.data && (Object.assign(a, s == null ? void 0 : s.data), l.value = s == null ? void 0 : s.data.labelName), s.isFocus && Ne(o, (p) => {
      p && p.click && p.click();
    });
    const c = () => {
      let p;
      l.value && (p = {
        color: a.color,
        bgColor: a.bgColor,
        labelName: l.value
      }), s.change(p, {
        isDelete: !l.value
      });
    };
    return {
      ns: e,
      curData: a,
      inputVal: l,
      inputRef: i,
      popoverRef: r,
      labelConfig: n,
      referenceRef: o,
      onInput: () => {
        a.labelName = l.value;
      },
      handleColorItemClick: (p) => {
        a.color = p, a.bgColor = t(p);
      },
      handleAfterEnter: () => {
        s.isFocus && i.value && i.value.focus();
      },
      handleAfterLeave: async () => {
        c();
      },
      calcAlpha: t
    };
  },
  render() {
    const s = M("div", {
      ref: "referenceRef",
      class: this.ns.e("reference"),
      style: {
        backgroundColor: "".concat(this.curData.bgColor),
        color: this.curData.color === this.labelConfig[0] ? "" : this.curData.color
      }
    }, [this.curData.labelName || "设置标签"]), e = M(Ie("el-popover"), {
      trigger: "click",
      ref: "popoverRef",
      width: "200px",
      "hide-after": 0,
      "popper-class": [this.ns.e("popover"), "".concat(this.nodeKey)],
      onAfterEnter: this.handleAfterEnter,
      onAfterLeave: this.handleAfterLeave
    }, {
      default: () => M("div", {
        class: this.ns.em("popover", "content")
      }, [ri(M("input", {
        ref: "inputRef",
        class: this.ns.em("popover", "input"),
        type: "text",
        "onUpdate:modelValue": (t) => this.inputVal = t,
        onInput: () => this.onInput(),
        placeholder: "输入标签名称"
      }, null), [[fl, this.inputVal]]), M("div", {
        class: this.ns.em("popover", "color-box")
      }, [this.labelConfig.map((t, n) => M("div", {
        class: this.ns.em("popover", "color-item"),
        style: "background-color: ".concat(n === 0 ? this.calcAlpha(t) : t),
        onClick: () => this.handleColorItemClick(t)
      }, [t === this.curData.color ? M("svg", {
        viewBox: "0 0 16 16",
        xmlns: "http://www.w3.org/2000/svg",
        height: "1em",
        width: "1em"
      }, [M("g", {
        "stroke-width": "1",
        "fill-rule": "evenodd"
      }, [M("path", {
        d: "M13.993 3l1.364 1.364-9.311 9.31-.01-.01-.008.01L0 7.645l1.362-1.363 4.674 4.673L13.993 3z"
      }, null)])]) : ""]))])]),
      reference: () => s
    });
    return M("div", {
      class: [this.ns.b(), this.readonly ? this.ns.m("readonly") : ""]
    }, [this.readonly ? s : e]);
  }
});
const Z2 = [
  "rgb(0, 0, 0)",
  "rgb(38, 38, 38)",
  "rgb(89, 89, 89)",
  "rgb(140, 140, 140)",
  "rgb(191, 191, 191)",
  "rgb(217, 217, 217)",
  "rgb(233, 233, 233)",
  "rgb(245, 245, 245)",
  "rgb(250, 250, 250)",
  "rgb(255, 255, 255)",
  // 10
  "rgb(225, 60, 57)",
  "rgb(231, 95, 51)",
  "rgb(235, 144, 58)",
  "rgb(245, 219, 77)",
  "rgb(114, 192, 64)",
  "rgb(89, 191, 192)",
  "rgb(66, 144, 247)",
  "rgb(54, 88, 226)",
  "rgb(106, 57, 201)",
  "rgb(216, 68, 147)",
  // 10
  "rgb(251, 233, 230)",
  "rgb(252, 237, 225)",
  "rgb(252, 239, 212)",
  "rgb(252, 251, 207)",
  "rgb(231, 246, 213)",
  "rgb(218, 244, 240)",
  "rgb(217, 237, 250)",
  "rgb(224, 232, 250)",
  "rgb(237, 225, 248)",
  "rgb(246, 226, 234)",
  // 10
  "rgb(255, 163, 158)",
  "rgb(255, 187, 150)",
  "rgb(255, 213, 145)",
  "rgb(255, 251, 143)",
  "rgb(183, 235, 143)",
  "rgb(135, 232, 222)",
  "rgb(145, 213, 255)",
  "rgb(173, 198, 255)",
  "rgb(211, 173, 247)",
  "rgb(255, 173, 210)",
  // 10
  "rgb(255, 77, 79)",
  "rgb(255, 122, 69)",
  "rgb(255, 169, 64)",
  "rgb(255, 236, 61)",
  "rgb(115, 209, 61)",
  "rgb(54, 207, 201)",
  "rgb(64, 169, 255)",
  "rgb(89, 126, 247)",
  "rgb(146, 84, 222)",
  "rgb(247, 89, 171)",
  // 10
  "rgb(207, 19, 34)",
  "rgb(212, 56, 13)",
  "rgb(212, 107, 8)",
  "rgb(212, 177, 6)",
  "rgb(56, 158, 13)",
  "rgb(8, 151, 156)",
  "rgb(9, 109, 217)",
  "rgb(29, 57, 196)",
  "rgb(83, 29, 171)",
  "rgb(196, 29, 127)",
  // 10
  "rgb(130, 0, 20)",
  "rgb(135, 20, 0)",
  "rgb(135, 56, 0)",
  "rgb(97, 71, 0)",
  "rgb(19, 82, 0)",
  "rgb(0, 71, 79)",
  "rgb(0, 58, 140)",
  "rgb(6, 17, 120)",
  "rgb(34, 7, 94)",
  "rgb(120, 6, 80)"
  // 10
], K2 = [
  {
    type: "success",
    text: "成功",
    color: "rgb(103,194,58,0.2)",
    icon: "<svg viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em' style='fill:rgb(103,194,58)'> <g stroke-width='1' fill-rule='evenodd'> <path d='M0 8c0-4.4 3.6-8 8-8s8 3.6 8 8-3.6 8-8 8-8-3.6-8-8zm7.097.758L5.199 6.905l-.978 1.001 2.9 2.833 4.563-4.685-1.003-.977-3.584 3.68z'></path> </g></svg>"
  },
  {
    type: "danger",
    text: "危险",
    color: "rgb(245,108,108,0.2)",
    icon: "<svg viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em' style='fill:rgb(245,108,108)'> <g stroke-width='1' fill-rule='evenodd'> <path d='M0 8c0-4.4 3.6-8 8-8s8 3.6 8 8-3.6 8-8 8-8-3.6-8-8zm9.005.021l1.777-1.793-.994-.986-1.769 1.784L6.28 5.27l-.995.985 1.75 1.767-1.766 1.782.995.985 1.756-1.772 1.702 1.718.995-.985L9.005 8.02z'></path> </g></svg>"
  },
  {
    type: "warning",
    text: "警告",
    color: "rgb(230,162,60,0.2)",
    icon: "<svg viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em' style='fill:rgb(230,162,60)'> <g stroke-width='1' fill-rule='evenodd'> <path d='M9.718 2.496l5.588 9.387a2 2 0 0 1-1.718 3.023H2.412a2 2 0 0 1-1.718-3.023L6.28 2.496a2 2 0 0 1 3.437 0zm-2.447 9.496v1.457h1.457v-1.457H7.271zm-.363-5.84l.363 4.384h1.457l.376-4.385H6.908z'></path> </g></svg>"
  },
  {
    type: "prompt",
    text: "提示",
    color: "rgb(64,158,255,0.2)",
    icon: "<svg viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em' style='fill:rgb(64,158,255)'> <g stroke-width='1' fill-rule='evenodd'> <path d='M0 8c0-4.4 3.6-8 8-8s8 3.6 8 8-3.6 8-8 8-8-3.6-8-8zm7.332-1.005l-.03 5.031 1.4.007L8.732 7l-1.4-.006zm0-3.052l-.03 1.732 1.4.006.03-1.731-1.4-.007z'></path> </g></svg>"
  },
  {
    type: "add-emoji",
    text: "添加表情",
    icon: "<svg viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em'> <g stroke-width='1' fill-rule='evenodd'> <path d='M14.727 7h1.211A8 8 0 1 1 11.206.668L10.795 1.8A6.8 6.8 0 1 0 14.727 7zm-.226-1h1.247-1.247zM5 8a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm6.97 1.5a4 4 0 0 1-7.94 0h1.215a2.8 2.8 0 0 0 5.51 0h1.214zM11 8a1 1 0 1 1 0-2 1 1 0 0 1 0 2zm2.264-5.177V1.459h1.2v1.364h1.364v1.2h-1.364v1.363h-1.2V4.023H11.9v-1.2h1.364z'></path> </g></svg>"
  },
  {
    type: "delete-emoji",
    text: "删除表情",
    icon: "<svg viewBox='0 0 16 16' version='1.1' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em'> <g stroke-width='1' fill-rule='evenodd'> <path d='M1.90326777,1.07326956 L14.9701984,14.1861127 C15.2041017,14.4208379 15.2034355,14.8007363 14.9687103,15.0346396 C14.7339852,15.2685429 14.3540868,15.2678766 14.1201835,15.0331515 L1.05325285,1.9203083 C0.819349557,1.68558316 0.8200158,1.30568475 1.05474094,1.07178147 C1.28946608,0.837878178 1.66936449,0.838544422 1.90326777,1.07326956 Z M1.78392959,4.77808157 L2.68262793,5.6799605 C2.37220548,6.39042724 2.2,7.17510325 2.2,8 C2.2,11.2032515 4.79674845,13.8 8,13.8 C8.81790048,13.8 9.59625958,13.6307032 10.3019463,13.3252407 L11.199833,14.2274912 C10.2408005,14.7212594 9.15295194,15 8,15 C4.13400675,15 1,11.8659932 1,8 C1,6.83818849 1.28304083,5.7424847 1.78392959,4.77808157 Z M8,1 C11.8659932,1 15,4.13400675 15,8 C15,9.18355772 14.7062644,10.2985098 14.1877157,11.2759337 L13.2919736,10.3773191 C13.6183874,9.65183814 13.8,8.84712801 13.8,8 C13.8,4.79674845 11.2032515,2.2 8,2.2 C7.15989239,2.2 6.36150251,2.37861488 5.640734,2.69994102 L4.7450393,1.80120321 C5.71742699,1.28955298 6.82489914,1 8,1 Z'></path> </g></svg>"
  },
  {
    type: "separator",
    text: "|"
  },
  {
    type: "background-color",
    text: "背景色",
    icon: "<svg viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em'> <g stroke-width='1' fill-rule='evenodd'> <path d='M3.58 8.165l2.092 1.209L3.86 12.51l4.9.01.592-1.021 1.39.803 4.138-7.165L7.717 1 3.58 8.165zm1.639-.44L8.156 2.64l5.085 2.936-2.935 5.087-5.087-2.937z'></path> <path d='M1 15.064h11.997v-1.201H1z'></path> </g></svg>"
  },
  {
    type: "separator",
    text: "|"
  },
  {
    type: "delete",
    text: "删除",
    icon: "<svg viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em'> <g stroke-width='1' fill-rule='evenodd'> <path d='M4.002 3.403V1a1 1 0 0 1 1-1h6.003a1 1 0 0 1 1 1v2.403h3.396a.6.6 0 1 1 0 1.2h-1.395V15a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V4.603H.6a.6.6 0 1 1 0-1.2h3.4zm8.804 1.205H3.2V14.8h9.605V4.608zM5.202 1.2v2.155h5.603V1.2H5.202zm.6 6.417a.6.6 0 0 1 1.201 0v4.758a.6.6 0 0 1-1.2 0V7.617zm3.202 0a.6.6 0 0 1 1.2 0v4.758a.6.6 0 0 1-1.2 0V7.617z'></path> </g></svg>"
  }
];
function Q2() {
  return Z2;
}
function ey() {
  return K2;
}
const ty = /* @__PURE__ */ me({
  name: "IBizPromptBoxSelect",
  props: fi(),
  emits: ["change"],
  setup(s) {
    const e = we("prompt-box-select"), t = T(""), n = T(""), i = T(""), r = T(null), o = T(null), a = T(null), l = T(), c = T(), u = T([]), f = T([]);
    if (u.value = Q2(), f.value = ey(), t.value = f.value[0].color, n.value = f.value[0].icon, s.data) {
      const {
        color: k,
        icon: D,
        text: L
      } = s.data;
      t.value = k, n.value = Pa(D), i.value = L;
    }
    let d = new ResizeObserver(() => {
      var k;
      c.value && c.value.offsetWidth !== 0 && ((k = c.value) == null || k.click(), d = null);
    });
    s.isFocus && (Ne(c, (k) => {
      k && k.click && d.observe(k);
    }), Ne(l, (k) => {
      k && k.focus && k.focus();
    }));
    const g = () => {
      const k = {
        color: t.value,
        icon: ka(n.value),
        text: i.value
      };
      s.change(k);
    }, p = (k) => {
      var L;
      const D = {
        ok: !0,
        data: [{
          emoji: ka(k.data)
        }]
      };
      (L = o.value) == null || L.dismiss(D);
    }, m = (k) => {
      var D;
      (D = a.value) == null || D.dismiss({
        ok: !0,
        data: [k]
      });
    }, w = (k) => {
      var D;
      k.color && (t.value = k.color, n.value = k.icon), (D = l.value) == null || D.focus();
    }, v = (k) => M("div", {
      class: e.be("background-popover", "content")
    }, [M("ul", {
      class: e.be("background-popover", "list")
    }, [M("li", {
      class: e.be("background-popover", "list-item-clear"),
      onClick: () => m("")
    }, [M("svg", {
      viewBox: "0 0 1024 1024",
      width: "1em",
      height: "1em"
    }, [M("path", {
      d: "M236.8 128L896 787.2V128H236.8z m614.4 704L192 172.8V832h659.2zM192 64h704c38.4 0 64 25.6 64 64v704c0 38.4-25.6 64-64 64H192c-38.4 0-64-25.6-64-64V128c0-38.4 25.6-64 64-64z"
    }, null)]), tt("清除背景色")]), k.map((D) => M("li", {
      class: e.be("background-popover", "list-item"),
      onClick: () => m(D)
    }, [M("div", {
      class: e.bem("background-popover", "list-item", "color-block"),
      style: {
        backgroundColor: D
      }
    }, null)]))])]), y = async (k) => {
      var B, ee;
      o.value || (o.value = Ds(z2, {}, {
        dark: !0,
        continuousList: !0,
        onSelect: p
      })), await o.value.present(k.target);
      const D = await o.value.onWillDismiss(), L = (B = D.data) == null ? void 0 : B[0];
      D.ok && L && (n.value = "".concat(Pa(L.emoji))), o.value = null, (ee = l.value) == null || ee.focus();
    }, b = async (k) => {
      var B, ee;
      a.value || (a.value = Ds(v(u.value))), await a.value.present(k.target);
      const D = await a.value.onWillDismiss(), L = (B = D.data) == null ? void 0 : B[0];
      D.ok && (t.value = "".concat(L)), a.value = null, (ee = l.value) == null || ee.focus();
    }, x = async () => {
      var k, D, L;
      await ((k = r.value) == null ? void 0 : k.dismiss()), await ((D = o.value) == null ? void 0 : D.dismiss()), await ((L = a.value) == null ? void 0 : L.dismiss()), s.change("", {
        isDelete: !0
      });
    }, C = () => {
      n.value = "";
    }, A = (k, D) => {
      var L;
      if (k.type !== "separator")
        switch ((L = l.value) == null || L.focus(), k.type) {
          case "add-emoji":
            y(D);
            break;
          case "background-color":
            b(D);
            break;
          case "delete":
            x();
            break;
          case "delete-emoji":
            C();
            break;
          default:
            w(k);
            break;
        }
    }, P = () => M("div", {
      class: e.be("popover", "content")
    }, [f.value.map((k) => M("div", {
      class: [e.be("popover", "tool-item"), e.be("popover", "tool-item-".concat(k.type)), e.is("activated", n.value === k.icon)],
      title: k.text,
      onClick: (D) => A(k, D)
    }, [M("div", {
      class: e.bem("popover", "tool-item", "content"),
      innerHTML: k.icon || k.text
    }, null)]))]);
    return {
      ns: e,
      curColor: t,
      curIcon: n,
      curText: i,
      inputRef: l,
      referenceRef: c,
      toolBars: f,
      handleToolItemClick: A,
      onOpenTopPopover: async () => {
        var k;
        (k = l.value) == null || k.focus(), r.value = Ds(P(), {
          placement: "top-start"
        }), await r.value.present(c.value), await r.value.onWillDismiss(), g(), r.value = null;
      }
    };
  },
  render() {
    return M("div", {
      class: [this.ns.b(), this.readonly ? this.ns.m("readonly") : ""]
    }, [M("div", {
      ref: "referenceRef",
      class: this.ns.e("reference"),
      style: {
        backgroundColor: this.curColor
      },
      onClick: this.onOpenTopPopover
    }, [this.curIcon ? M("div", {
      class: [this.ns.em("reference", "icon")],
      innerHTML: this.curIcon
    }, null) : "", M(Ie("el-input"), {
      ref: "inputRef",
      modelValue: this.curText,
      "onUpdate:modelValue": (s) => this.curText = s,
      type: "text",
      autofocus: !0
    }, null)])]);
  }
});
const ny = new Wg(import.meta.url);
class Bo {
  /**
   * @description 获取Luckysheet对象
   * @static
   * @return {*}  {*}
   * @memberof MathJax
   */
  static getMathJax() {
    return window.MathJax;
  }
  /**
   * 动态加载脚本
   *
   * @static
   * @return {*}
   * @memberof MathJax
   */
  static loadScript(e) {
    return new Promise((t, n) => {
      const i = document.createElement("script");
      i.src = e, i.onload = t, i.onerror = n, document.head.appendChild(i);
    });
  }
  /**
   * 配置全局 MathJax
   * @param {FnType} callback Mathjax 加载完成的回调
   */
  static initMathJax(e) {
    window.MathJax = {
      tex: {
        inlineMath: [["$", "$"]],
        processEnvironments: !0,
        processRefs: !0
      },
      options: {
        skipHtmlTags: ["noscript", "style", "textarea", "pre", "code"],
        ignoreHtmlClass: "tex2jax_ignore"
      },
      startup: {
        pageReady: () => e && e()
      },
      svg: {
        fontCache: "global"
      }
    };
  }
  /**
   * 手动渲染公式
   * @param {HTMLElement} el 需要触发渲染的节点
   * @returns Promise
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  static renderFormula(e) {
    return !window.MathJax || !window.MathJax.typesetPromise ? Promise.reject() : (e && !Array.isArray(e) && (e = [e]), window.MathJax.typesetPromise(e));
  }
  /**
   * 加载MathJax
   *
   * @static
   * @return {*}
   * @memberof MathJax
   */
  static loadMathJax() {
    return new Promise((e, t) => {
      if (this.getMathJax())
        e();
      else {
        this.initMathJax();
        const i = [
          this.loadScript(
            // 插件中使用 resource.dir
            ny.dir("assets/mathjax/plugins/js/tex-svg.js")
            // 模板中使用
            // '/assets/mathjax/plugins/js/tex-svg.js',
          )
        ];
        Promise.all(i).then(() => {
          e();
        }).catch(() => {
          ibiz.message.error(
            "加载mathJax静态资源失败,请确认静态资源是否存在！"
          ), t();
        });
      }
    });
  }
}
function sy() {
}
const ro = '<p data-we-empty-p=""><br></p>', zd = "#ee7959", iy = [
  "Control",
  "Escape",
  "Tab",
  "CapsLock",
  "Shift",
  "Meta",
  "Alt",
  "ArrowLeft",
  "ArrowUp",
  "ArrowDown",
  "ArrowRight",
  "Enter",
  "Backspace",
  "Delete",
  "Insert",
  "c",
  "v",
  "z"
], ry = [" ", "{", "}"];
function oy(s, e = 200) {
  let t = 0;
  return function(...n) {
    t && window.clearTimeout(t), t = window.setTimeout(() => {
      t = 0, s.call(this, ...n);
    }, e);
  };
}
function zl(s) {
  return Array.prototype.slice.call(s);
}
function ay(s) {
  return '<span style="color: '.concat(zd, '">').concat(s !== " " ? s : "&nbsp;", "</span>");
}
function Vd(s) {
  const e = /[A-Za-z0-9]+/g;
  return s = s.replace(
    e,
    (t) => '<span style="color: '.concat(zd, '">').concat(t, "</span>")
  ), "<span>".concat(s, "</span>&nbsp;");
}
function Rn(s) {
  return '<div class="me-menu-item"><span class="icon">$'.concat(s, "$</span></div>");
}
class ly {
  constructor() {
    E(this, "_ua");
    // 是否为旧版 Edge
    E(this, "isOldEdge");
    // 是否为 Firefox
    E(this, "isFirefox");
    this._ua = navigator.userAgent;
    const e = this._ua.match(/(Edge?)\/(\d+)/);
    this.isOldEdge = !!(e && e[1] === "Edge" && parseInt(e[2]) < 19), this.isFirefox = !!(/Firefox\/\d+/.test(this._ua) && !/Seamonkey\/\d+/.test(this._ua));
  }
  /** 是否为 IE */
  isIE() {
    return "ActiveXObject" in window;
  }
  /** 是否为 webkit */
  isWebkit() {
    return /webkit/i.test(this._ua);
  }
}
const lh = new ly(), Or = [];
function cy(s) {
  const e = document.createElement("div");
  e.innerHTML = s;
  const t = e.children;
  return zl(t);
}
function hy(s) {
  return s ? s instanceof HTMLCollection || s instanceof NodeList : !1;
}
function uy(s) {
  const e = document.querySelectorAll(s);
  return zl(e);
}
function ch(s) {
  let e = [];
  const t = [];
  return Array.isArray(s) ? e = s : e = s.split(";"), e.forEach((n) => {
    const i = n.split(":").map((r) => r.trim());
    i.length === 2 && t.push("".concat(i[0], ":").concat(i[1]));
  }), t;
}
class oo {
  // 通过 getNodeTop 获取顶级段落的时候，可以通过 prior 去回溯来源的子节点
  /**
   * 构造函数
   * @param selector 任一类型的选择器
   */
  constructor(e) {
    // 定义属性
    E(this, "selector");
    E(this, "length");
    E(this, "elems");
    E(this, "dataSource");
    E(this, "prior");
    if (this.elems = [], this.length = this.elems.length, this.dataSource = /* @__PURE__ */ new Map(), !e)
      return;
    if (e instanceof oo)
      return e;
    let t = [];
    const n = e instanceof Node ? e.nodeType : -1;
    if (this.selector = e, n === 1 || n === 9)
      t = [e];
    else if (hy(e))
      t = zl(e);
    else if (e instanceof Array)
      t = e;
    else if (typeof e == "string") {
      const o = e.replace("/\n/mg", "").trim();
      o.indexOf("<") === 0 ? t = cy(o) : t = uy(o);
    }
    const i = t.length;
    if (!i)
      return this;
    let r = 0;
    for (; r < i; r++)
      this.elems.push(t[r]);
    this.length = i;
  }
  /**
   * 获取元素 id
   */
  get id() {
    return this.elems[0].id;
  }
  /**
   * 遍历所有元素，执行回调函数
   * @param fn 回调函数
   */
  forEach(e) {
    for (let t = 0; t < this.length; t++) {
      const n = this.elems[t];
      if (e.call(n, n, t) === !1)
        break;
    }
    return this;
  }
  /**
   * 克隆元素
   * @param deep 是否深度克隆
   */
  clone(e = !1) {
    const t = [];
    return this.elems.forEach((n) => {
      t.push(n.cloneNode(!!e));
    }), J(t);
  }
  /**
   * 获取第几个元素
   * @param index index
   */
  get(e = 0) {
    const t = this.length;
    return e >= t && (e %= t), J(this.elems[e]);
  }
  /**
   * 获取第一个元素
   */
  first() {
    return this.get(0);
  }
  /**
   * 获取最后一个元素
   */
  last() {
    const e = this.length;
    return this.get(e - 1);
  }
  on(e, t, n) {
    return e ? (typeof t == "function" && (n = t, t = ""), this.forEach((i) => {
      if (!t) {
        i.addEventListener(e, n);
        return;
      }
      const r = function(o) {
        const a = o.target;
        a.matches(t) && n.call(a, o);
      };
      i.addEventListener(e, r), Or.push({
        elem: i,
        selector: t,
        fn: n,
        agentFn: r
      });
    })) : this;
  }
  off(e, t, n) {
    return e ? (typeof t == "function" && (n = t, t = ""), this.forEach(function(i) {
      if (t) {
        let r = -1;
        for (let o = 0; o < Or.length; o++) {
          const a = Or[o];
          if (a.selector === t && a.fn === n && a.elem === i) {
            r = o;
            break;
          }
        }
        if (r !== -1) {
          const { agentFn: o } = Or.splice(r, 1)[0];
          i.removeEventListener(e, o);
        }
      } else
        i.removeEventListener(e, n);
    })) : this;
  }
  attr(e, t) {
    return t === void 0 ? this.elems[0].getAttribute(e) || "" : this.forEach(function(n) {
      n.setAttribute(e, t);
    });
  }
  /**
   * 删除 属性
   * @param key key
   */
  removeAttr(e) {
    this.forEach(function(t) {
      t.removeAttribute(e);
    });
  }
  /**
   * 添加 css class
   * @param className css class
   */
  addClass(e) {
    return e ? this.forEach(function(t) {
      if (t.className) {
        let n = t.className.split(/\s/);
        n = n.filter((i) => !!i.trim()), n.indexOf(e) < 0 && n.push(e), t.className = n.join(" ");
      } else
        t.className = e;
    }) : this;
  }
  /**
   * 添加 css class
   * @param className css class
   */
  removeClass(e) {
    return e ? this.forEach(function(t) {
      if (!t.className)
        return;
      let n = t.className.split(/\s/);
      n = n.filter((i) => (i = i.trim(), !(!i || i === e))), t.className = n.join(" ");
    }) : this;
  }
  /**
   * 是否有传入的 css class
   * @param className css class
   */
  hasClass(e) {
    if (!e)
      return !1;
    const t = this.elems[0];
    return t.className ? t.className.split(/\s/).includes(e) : !1;
  }
  /**
   * 修改 css
   * @param key css key
   * @param val css value
   */
  // css(key: string): string
  css(e, t) {
    let n;
    return t === "" ? n = "" : n = "".concat(e, ":").concat(t, ";"), this.forEach((i) => {
      const r = (i.getAttribute("style") || "").trim();
      if (r) {
        let o = ch(r);
        o = o.map((a) => a.indexOf(e) === 0 ? n : a), n !== "" && o.indexOf(n) < 0 && o.push(n), n === "" && (o = ch(o)), i.setAttribute("style", o.join("; "));
      } else
        i.setAttribute("style", n);
    });
  }
  /**
   * 封装 getBoundingClientRect
   */
  getBoundingClientRect() {
    return this.elems[0].getBoundingClientRect();
  }
  /**
   * 显示
   */
  show() {
    return this.css("display", "block");
  }
  /**
   * 隐藏
   */
  hide() {
    return this.css("display", "none");
  }
  /**
   * 获取子节点（只有 DOM 元素）
   */
  children() {
    const e = this.elems[0];
    return e ? J(e.children) : null;
  }
  /**
   * 获取子节点（包括文本节点）
   */
  childNodes() {
    const e = this.elems[0];
    return e ? J(e.childNodes) : null;
  }
  /**
   * 将子元素全部替换
   * @param $children 新的child节点
   */
  replaceChildAll(e) {
    const t = this.getNode(), n = this.elems[0];
    for (; n.hasChildNodes(); )
      t.firstChild && n.removeChild(t.firstChild);
    this.append(e);
  }
  /**
   * 增加子节点
   * @param $children 子节点
   */
  append(e) {
    return this.forEach((t) => {
      e.forEach(function(n) {
        t.appendChild(n);
      });
    });
  }
  /**
   * 移除当前节点
   */
  remove() {
    return this.forEach((e) => {
      if (e.remove)
        e.remove();
      else {
        const t = e.parentElement;
        t && t.removeChild(e);
      }
    });
  }
  /**
   * 当前元素，是否包含某个子元素
   * @param $child 子元素
   */
  isContain(e) {
    const t = this.elems[0], n = e.elems[0];
    return t.contains(n);
  }
  /**
   * 获取当前元素 nodeName
   */
  getNodeName() {
    return this.elems[0].nodeName;
  }
  /**
   * 根据元素位置获取元素节点（默认获取0位置的节点）
   * @param n 元素节点位置
   */
  getNode(e = 0) {
    return this.elems[e];
  }
  /**
   * 查询
   * @param selector css 选择器
   */
  find(e) {
    const t = this.elems[0];
    return J(t.querySelectorAll(e));
  }
  text(e) {
    return e === void 0 ? this.elems[0].innerHTML.replace(/<[^>]+>/g, () => "") : this.forEach(function(t) {
      t.innerHTML = e;
    });
  }
  html(e) {
    const t = this.elems[0];
    return e === void 0 ? t.innerHTML : (t.innerHTML = e, this);
  }
  /**
   * 获取元素 value
   */
  val() {
    return this.elems[0].value.trim();
  }
  /**
   * focus 到当前元素
   */
  focus() {
    return this.forEach((e) => {
      e.focus();
    });
  }
  /**
   * 当前元素前一个兄弟节点
   */
  prev() {
    const e = this.elems[0];
    return J(e.previousElementSibling);
  }
  /**
   * 当前元素后一个兄弟节点
   * 不包括文本节点、注释节点）
   */
  next() {
    const e = this.elems[0];
    return J(e.nextElementSibling);
  }
  /**
   * 获取当前节点的下一个兄弟节点
   * 包括文本节点、注释节点即回车、换行、空格、文本等等）
   */
  getNextSibling() {
    const e = this.elems[0];
    return J(e.nextSibling);
  }
  /**
   * 获取父元素
   */
  parent() {
    const e = this.elems[0];
    return J(e.parentElement);
  }
  /**
   * 查找父元素，直到满足 selector 条件
   * @param selector css 选择器
   * @param curElem 从哪个元素开始查找，默认为当前元素
   */
  parentUntil(e, t) {
    const n = t || this.elems[0];
    if (n.nodeName === "BODY")
      return null;
    const i = n.parentElement;
    return i ? i.matches(e) ? J(i) : this.parentUntil(e, i) : null;
  }
  /**
   * 判读是否相等
   * @param $elem 元素
   */
  equal(e) {
    return e instanceof oo ? this.elems[0] === e.elems[0] : e instanceof HTMLElement ? this.elems[0] === e : !1;
  }
  /**
   * 将该元素插入到某个元素前面
   * @param selector css 选择器
   */
  insertBefore(e) {
    const n = J(e).elems[0];
    return n ? this.forEach((i) => {
      const r = n.parentNode;
      r == null || r.insertBefore(i, n);
    }) : this;
  }
  /**
   * 将该元素插入到selector元素后面
   * @param selector css 选择器
   */
  insertAfter(e) {
    const n = J(e).elems[0], i = n && n.nextSibling;
    return n ? this.forEach(function(r) {
      const o = n.parentNode;
      i ? o.insertBefore(r, i) : o.appendChild(r);
    }) : this;
  }
  /**
   * 设置/获取 数据
   * @param key key
   * @param value value
   */
  data(e, t) {
    if (t === void 0)
      return this.dataSource.get(e);
    this.dataSource.set(e, t);
  }
  /**
   * 获取当前节点的顶级(段落)
   * @param editor 富文本实例
   */
  getNodeTop(e) {
    if (this.length < 1)
      return this;
    const t = this.parent();
    return e.$textLatexElem.equal(this) || e.$textLatexElem.equal(t) ? this : (t.prior = this, t.getNodeTop(e));
  }
  /**
   * 获取当前 节点 基与上一个拥有相对或者解决定位的父容器的位置
   * @param editor 富文本实例
   */
  getOffsetData() {
    const e = this.elems[0];
    return {
      top: e.offsetTop,
      left: e.offsetLeft,
      width: e.offsetWidth,
      height: e.offsetHeight,
      parent: e.offsetParent
    };
  }
  /**
   * 从上至下进行滚动
   * @param top 滚动的值
   */
  scrollTop(e) {
    this.elems[0].scrollTo({ top: e });
  }
  renderFormula() {
    return Bo.renderFormula(this.elems);
  }
}
function J(...s) {
  return new oo(...s);
}
const dy = {
  width: 620,
  height: 272,
  menuHeight: 38,
  mathJaxUrl: "https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/mathjax/3.2.0/es5/tex-svg.min.js"
}, fy = {
  menus: [
    "presets",
    "operators",
    "greekLetters",
    "inequation",
    "AdvancedMath",
    "LinearAlgebra",
    "arrows",
    "Trigonometric"
  ],
  presets(s) {
    return [
      // 勾股定理
      {
        label: s("fe.pt"),
        value: "a^2+b^2=c^2"
      },
      // 双曲线
      {
        label: s("fe.h"),
        value: "\\frac{x^2}{a^2}-\\frac{y^2}{b^2}=1"
      },
      // 三角函数关系
      {
        label: s("fe.tfr"),
        value: "\\sin^2\\theta +\\cos^2\\theta = 1"
      },
      // 导数
      {
        label: s("fe.d"),
        value: "\\left( e^x \\right) ' = e^x"
      },
      // 牛莱公式
      {
        label: s("fe.nl"),
        value: "\\int_a^b f(x) dx = F(b) - F(a)"
      }
    ];
  },
  operators: [
    "+",
    "-",
    "\\pm",
    "\\mp",
    "\\times",
    "\\div",
    "\\ast",
    "\\cdot",
    "\\cap",
    "\\cup",
    "\\aleph",
    "\\Re",
    "\\top",
    "\\bot",
    "\\infty",
    "\\partial",
    "\\forall",
    "\\exists",
    "\\neg",
    "\\because",
    "\\therefore",
    "\\varnothing",
    "\\frac{b}{a}",
    "\\circ",
    "\\bullet",
    "\\prime",
    "\\triangle",
    "\\angle",
    "\\surd",
    "\\barwedge",
    "\\veebar",
    "\\odot",
    "\\oplus",
    "\\otimes",
    "\\oslash",
    "\\circledcirc",
    "\\boxdot",
    "\\bigtriangledown",
    "\\dagger",
    "\\diamond",
    "\\star",
    "\\triangleleft",
    "\\triangleright"
  ],
  greekLetters: [
    "\\alpha",
    "\\beta",
    "\\gamma",
    "\\delta",
    "\\epsilon",
    "\\zeta",
    "\\eta",
    "\\theta",
    "\\iota",
    "\\kappa",
    "\\lambda",
    "\\mu",
    "\\nu",
    "\\xi",
    "\\omicron",
    "\\pi",
    "\\rho",
    "\\sigma",
    "\\tau",
    "\\upsilon",
    "\\phi",
    "\\chi",
    "\\psi",
    "\\omega",
    "\\varepsilon",
    "\\vartheta",
    "\\varpi",
    "\\varrho",
    "\\varsigma",
    "\\varphi",
    "\\Gamma",
    "\\Delta",
    "\\Theta",
    "\\Lambda",
    "\\Xi",
    "\\Pi",
    "\\Sigma",
    "\\Upsilon",
    "\\Phi",
    "\\Psi",
    "\\Omega"
  ],
  inequation: [
    "=",
    "\\leq",
    "\\geq",
    "\\prec",
    "\\succ",
    "\\preceq",
    "\\succeq",
    "\\ll",
    "\\gg",
    "\\equiv",
    "\\sim",
    "\\simeq",
    "\\asymp",
    "\\approx",
    "\\ne",
    "\\subset",
    "\\supset",
    "\\subseteq",
    "\\supseteq",
    "\\nsubseteq",
    "\\nsupseteq",
    "\\in",
    "\\ni",
    "\\notin"
  ],
  AdvancedMath: [
    "x_{a}",
    "x^{b}",
    "x_{a}^{b}",
    "\\sqrt{x}",
    "\\sqrt[n]{x}",
    "\\bigcap_{a}^{b}",
    "\\bigcup_{a}^{b}",
    "\\prod_{a}^{b}",
    "\\coprod_{a}^{b}",
    "\\int_{a}^{b}",
    "\\oint_{a}^{b}",
    "\\sum_{a}^{b}{x}",
    "\\lim_{a  \\rightarrow b}{x}",
    "\\frac{dy}{dx}|_{t=0}",
    "\\vec{a}",
    "\\bar{a}",
    "\\tilde{a}",
    "\\dot{a}",
    "\\ddot{a}",
    "\\hat{a}",
    "\\overleftarrow{ab}",
    "\\overline{ab}",
    "\\overrightarrow{ab}",
    "\\underline{ab}",
    "\\overbrace{ab}",
    "\\underbrace{ab}"
  ],
  LinearAlgebra: [
    "A^{*}",
    "A^{T}",
    "A^{-1}",
    "\\left( x  \\right)",
    "\\left[ x  \\right]",
    "\\left \\{ x  \\right \\}",
    "\\left| x  \\right|",
    "\\begin{pmatrix}a&b\\\\c&d\\\\ \\end{pmatrix}",
    "\\begin{bmatrix}a&b\\\\c&d\\\\ \\end{bmatrix}",
    "\\begin{Bmatrix}a&b\\\\c&d\\\\ \\end{Bmatrix}",
    "\\begin{vmatrix}a&b\\\\c&d\\\\ \\end{vmatrix}"
  ],
  arrows: [
    "\\leftarrow",
    "\\rightarrow",
    "\\leftrightarrow",
    "\\Leftarrow",
    "\\Rightarrow",
    "\\Leftrightarrow",
    "\\uparrow",
    "\\downarrow",
    "\\updownarrow",
    "\\Uparrow",
    "\\Downarrow",
    "\\Updownarrow"
  ],
  trigonometric: [
    "\\sin \\theta",
    "\\cos \\theta",
    "\\tan \\theta",
    "\\csc \\theta",
    "\\sec \\theta",
    "\\cot \\theta",
    "\\arcsin \\theta",
    "\\arccos \\theta"
  ]
};
function gy(s) {
  const {
    $editorRootElem: e,
    $toolbarElem: t,
    $textLatexElem: n,
    // $textSvgElem,
    config: i
  } = s;
  e.append(t);
  const r = J("<div></div>");
  r.addClass("clearfix").css("width", "100%").css("height", "".concat(i.height - i.menuHeight, "px")).css("overflow", "hidden"), n.attr("contenteditable", "true").css("outline", "none"), r.append(n), e.css("width", "".concat(i.width, "px")).css("height", "".concat(i.height, "px")), e.append(r);
}
class py {
  constructor(e) {
    E(this, "editor");
    this.editor = e;
  }
  /**
   * 执行富文本操作的命令
   * @param value value
   */
  do(e) {
    const t = this.editor.selection;
    t.getRange() && (t.restoreSelection(), this.insertHtml(e), this.renderFormula(), t.saveRange(), t.restoreSelection());
  }
  /**
   * 公式编辑输入处理
   * @param text 插入的字符串
   * @param isSeparator 是否是定义的分隔符
   */
  insert(e, t) {
    if (t) {
      const r = this.editor.selection.getRange();
      if (r) {
        const o = r.startContainer;
        r.setStart(o, r.endOffset), r.setEnd(o, r.endOffset), r.deleteContents();
      }
      this.insertHtml(e === " " ? "&nbsp;" : e);
      return;
    }
    const n = ay(e);
    this.do(n);
  }
  /**
   * 渲染数学公式
   */
  renderFormula() {
    const e = this.editor, t = e.latex.text();
    e.change(t);
  }
  /**
   * 插入 html 片段
   * @param html html字符串
   */
  insertHtml(e) {
    const t = this.editor, n = t.selection.getRange();
    if (n) {
      if (this.queryCommandSupported("insertHTML"))
        this.execCommand("insertHTML", e);
      else if (n.insertNode) {
        if (n.deleteContents(), J(e).elems.length > 0)
          n.insertNode(J(e).elems[0]);
        else {
          const i = document.createElement("p");
          i.appendChild(document.createTextNode(e)), n.insertNode(i);
        }
        t.selection.collapseRange();
      }
    }
  }
  /**
   * 执行 document.execCommand
   * @param name name
   * @param value value
   */
  execCommand(e, t) {
    document.execCommand(e, !1, t);
  }
  /**
   * 执行 document.queryCommandSupported
   * @param name name
   */
  queryCommandSupported(e) {
    return document.queryCommandSupported(e);
  }
}
class my {
  constructor(e) {
    E(this, "editor");
    E(this, "_currentRange", null);
    this.editor = e;
  }
  /**
   * 获取当前 range
   */
  getRange() {
    return this._currentRange;
  }
  /**
   * 保存选区范围
   * @param _range 选区范围
   */
  saveRange(e) {
    if (e) {
      this._currentRange = e;
      return;
    }
    const t = window.getSelection();
    if (t.rangeCount === 0)
      return;
    const n = t.getRangeAt(0), i = this.getSelectionContainerElem(n);
    if (!(i != null && i.length))
      return;
    const r = this.editor, o = r.$textLatexElem;
    if (o.isContain(i)) {
      if (o.elems[0] === i.elems[0] && o.html().trim() === ro) {
        const a = o.children(), l = a == null ? void 0 : a.last();
        r.selection.createRangeByElem(l, !0, !0), r.selection.restoreSelection();
      }
      this._currentRange = n;
    }
  }
  /**
   * 折叠选区范围
   * @param toStart true 开始位置，false 结束位置
   */
  collapseRange(e = !1) {
    const t = this._currentRange;
    t && t.collapse(e);
  }
  /**
   * 获取选区范围内的文字
   */
  getSelectionText() {
    const e = this._currentRange;
    return e ? e.toString() : "";
  }
  /**
   * 获取选区范围的 DOM 元素
   * @param range 选区范围
   */
  getSelectionContainerElem(e) {
    const t = e || this._currentRange;
    if (t) {
      const n = t.commonAncestorContainer;
      return J(n.nodeType === 1 ? n : n.parentNode);
    }
  }
  /**
   * 选区范围开始的 DOM 元素
   * @param range 选区范围
   */
  getSelectionStartElem(e) {
    const t = e || this._currentRange;
    if (t) {
      const n = t.startContainer;
      return J(n.nodeType === 1 ? n : n.parentNode);
    }
  }
  /**
   * 选区范围结束的 DOM 元素
   * @param range 选区范围
   */
  getSelectionEndElem(e) {
    const t = e || this._currentRange;
    if (t) {
      const n = t.endContainer;
      return J(n.nodeType === 1 ? n : n.parentNode);
    }
  }
  /**
   * 选区是否为空（没有选择文字）
   */
  isSelectionEmpty() {
    const e = this._currentRange;
    return !!(e && e.startContainer && e.startContainer === e.endContainer && e.startOffset === e.endOffset);
  }
  /**
   * 恢复选区范围
   */
  restoreSelection() {
    const e = window.getSelection(), t = this._currentRange;
    e && t && (e.removeAllRanges(), e.addRange(t));
  }
  /**
   * 重新设置选区
   * @param startDom 选区开始的元素
   * @param endDom 选区结束的元素
   */
  createRangeByElems(e, t) {
    const n = window.getSelection ? window.getSelection() : document.getSelection();
    n == null || n.removeAllRanges();
    const i = document.createRange();
    i.setStart(e, 0), i.setEnd(t, t.childNodes.length || 1), this.saveRange(i), this.restoreSelection();
  }
  /**
   * 根据 DOM 元素设置选区
   * @param $elem DOM 元素
   * @param toStart true 开始位置，false 结束位置
   * @param isContent 是否选中 $elem 的内容
   */
  createRangeByElem(e, t, n) {
    if (!e.length)
      return;
    const i = e.elems[0], r = document.createRange();
    n ? r.selectNodeContents(i) : r.selectNode(i), t != null && (r.collapse(t), t || (this.saveRange(r), this.editor.selection.moveCursor(i))), this.saveRange(r);
  }
  /**
   * 获取 当前 选取范围的 顶级(段落) 元素
   * @param $editor
   */
  getSelectionRangeTopNodes() {
    var n, i;
    const e = (n = this.getSelectionStartElem()) == null ? void 0 : n.getNodeTop(this.editor), t = (i = this.getSelectionEndElem()) == null ? void 0 : i.getNodeTop(this.editor);
    return this.recordSelectionNodes(J(e), J(t));
  }
  /**
   * 移动光标位置,默认情况下在尾部
   * 有一个特殊情况是firefox下的文本节点会自动补充一个br元素，会导致自动换行
   * 所以默认情况下在firefox下的文本节点会自动移动到br前面
   * @param {Node} node 元素节点
   * @param {number} position 光标的位置
   */
  moveCursor(e, t) {
    var o;
    const n = this.getRange();
    let i = e.nodeType === 3 ? (o = e.nodeValue) == null ? void 0 : o.length : e.childNodes.length;
    (lh.isFirefox || lh.isIE()) && i !== 0 && (e.nodeType === 3 || e.childNodes[i - 1].nodeName === "BR") && (i -= 1);
    const r = t != null ? t : i;
    n && e && (n.setStart(e, r), n.setEnd(e, r), this.restoreSelection());
  }
  /**
   * 获取光标在当前选区的位置
   */
  getCursorPos() {
    const e = window.getSelection();
    return e == null ? void 0 : e.anchorOffset;
  }
  /**
   * 清除当前选区的Range,notice:不影响已保存的Range
   */
  clearWindowSelectionRange() {
    const e = window.getSelection();
    e && e.removeAllRanges();
  }
  /**
   * 记录节点 - 从选区开始节点开始 一直到匹配到选区结束节点为止
   * @param $node 节点
   */
  recordSelectionNodes(e, t) {
    const n = [];
    let i = !0;
    try {
      let r = e;
      const o = this.editor.$textLatexElem;
      for (; i; ) {
        const a = r == null ? void 0 : r.getNodeTop(this.editor);
        a.getNodeName() === "BODY" && (i = !1), a.length > 0 && (n.push(J(r)), t != null && t.equal(a) || o.equal(a) ? i = !1 : r = a.getNextSibling());
      }
    } catch (r) {
      i = !1;
    }
    return n;
  }
  /**
   * 将当前 range 设置到 node 元素并初始化位置
   * 解决编辑器内容为空时，菜单不生效的问题
   * @param node 元素节点
   */
  setRangeToElem(e) {
    const t = this.getRange();
    t == null || t.setStart(e, 0), t == null || t.setEnd(e, 0);
  }
}
function Xa(s, e) {
  const t = s.$textLatexElem, n = t.children();
  if (!n || !n.length) {
    t.append(J(ro)), Xa(s);
    return;
  }
  const i = n.last();
  if (e) {
    const r = i.html().toLowerCase(), o = i.getNodeName();
    if (r !== "<br>" && r !== "<br/>" || o !== "P") {
      t.append(J(ro)), Xa(s);
      return;
    }
  }
  s.selection.createRangeByElem(i, !1, !0), s.selection.restoreSelection();
}
let wy = class {
  constructor(e, t) {
    E(this, "key");
    E(this, "$elem");
    E(this, "editor");
    /** 菜单是否处于激活状态，如选中一段加粗文字时，bold 菜单要被激活（即高亮显示） */
    E(this, "_active");
    this.$elem = e, this.editor = t, this._active = !1, e.on("click", (n) => {
      n.stopPropagation(), t.selection.getRange() && (e.addClass("active"), this.clickHandler());
    });
  }
  /**
   * 菜单点击事件
   */
  clickHandler() {
  }
  /**
   * 激活菜单，高亮显示
   */
  active() {
    this._active = !0, this.$elem.addClass("me-active");
  }
  /**
   * 取消激活，不再高亮显示
   */
  unActive() {
    this._active = !1, this.$elem.removeClass("me-active");
  }
  /**
   * 是否处于激活状态
   */
  get isActive() {
    return this._active;
  }
};
const yy = 38;
class by {
  constructor(e, t) {
    E(this, "menu");
    E(this, "conf");
    E(this, "$container");
    E(this, "rendered");
    E(this, "_show");
    E(this, "hideTimeoutId");
    this.hideTimeoutId = 0, this.menu = e, this.conf = t;
    const {
      height: n,
      menuHeight: i,
      zIndex: r = 0
    } = this.menu.editor.config, o = J("<p>".concat(t.title, "</p>")).addClass("me-dp-title"), a = J('<div class="me-droplist"></div>').append(o).css("z-index", r + 1), l = t.list || [], c = t.type || "block", u = t.clickHandler || sy, f = J(
      '<ul class="'.concat(c === "list" ? "me-list" : "me-block", '"></ul>')
    ).css("max-height", "".concat(n - i - yy, "px")).css("overflow-y", "auto");
    l.forEach((d) => {
      const g = d.$elem, p = d.value, m = J('<li class="me-item"></li>');
      g && (m.append(g), f.append(m), m.on("click", (w) => {
        u(p), w.stopPropagation(), this.hideTimeoutId = window.setTimeout(() => {
          this.hide();
        });
      }));
    }), a.append(f), a.on("mouseleave", () => {
      this.hideTimeoutId = window.setTimeout(() => {
        this.hide();
      });
    }), this.$container = a, this.rendered = !1, this._show = !1;
  }
  /**
   * 显示 DropList
   */
  show() {
    this.hideTimeoutId && clearTimeout(this.hideTimeoutId);
    const t = this.menu.$elem, n = this.$container;
    if (!this._show) {
      if (this.rendered)
        n.show();
      else {
        const i = this.conf.width || 232;
        n.css("width", "".concat(i, "px")), t.append(n), this.rendered = !0, t.renderFormula();
      }
      this._show = !0;
    }
  }
  /**
   * 隐藏 DropList
   */
  hide() {
    const e = this.$container;
    this._show && (e.hide(), this._show = !1);
  }
  get isShow() {
    return this._show;
  }
}
class Bn extends wy {
  constructor(t, n, i) {
    super(t, n);
    E(this, "dropList");
    const r = new by(this, i);
    this.dropList = r, t.on("mouseover", () => {
      n.selection.getRange() && (t.addClass("active"), r.show());
    }).on("mouseleave", () => {
      t.removeClass("active"), r.hideTimeoutId = window.setTimeout(() => {
        r.hide();
      });
    });
  }
  /**
   * 执行命令
   * @param value value
   */
  command(t) {
    var a;
    const n = this.editor, i = n.selection.isSelectionEmpty();
    if (!((a = n.selection.getSelectionContainerElem()) == null ? void 0 : a.elems[0]))
      return;
    const o = Vd(t);
    n.cmd.do(o), i && (n.selection.collapseRange(), n.selection.restoreSelection());
  }
}
class vy {
  constructor(e) {
    E(this, "itemList");
    this.itemList = e.map(({ label: t, value: n }) => ({
      $elem: J('<p class="title">'.concat(t, "：</p><p>$ ").concat(n, " $</p>")),
      value: n
    }));
  }
  getItemList() {
    return this.itemList;
  }
}
class xy extends Bn {
  constructor(e) {
    const t = J(Rn("f_{(x)}")), n = new vy(e.menusConfig.presets(e.t)), i = {
      width: 252,
      title: e.t("fe.p"),
      type: "list",
      list: n.getItemList(),
      clickHandler: (r) => {
        this.command(r);
      }
    };
    super(t, e, i);
  }
}
class bs {
  constructor(e) {
    E(this, "itemList");
    this.itemList = e.map((t) => ({
      $elem: J("<span>$".concat(t, "$</span>")),
      value: t
    }));
  }
  getItemList() {
    return this.itemList;
  }
}
class Cy extends Bn {
  constructor(e) {
    const t = J(Rn("+")), n = new bs(e.menusConfig.operators), i = {
      title: e.t("fe.o"),
      list: n.getItemList(),
      clickHandler: (r) => {
        this.command(r);
      }
    };
    super(t, e, i);
  }
}
class Ey extends Bn {
  constructor(e) {
    const t = J(Rn("\\alpha")), n = new bs(e.menusConfig.greekLetters), i = {
      title: e.t("fe.gl"),
      list: n.getItemList(),
      clickHandler: (r) => {
        this.command(r);
      }
    };
    super(t, e, i);
  }
}
class Sy extends Bn {
  constructor(e) {
    const t = J(Rn("\\approx")), n = new bs(e.menusConfig.inequation), i = {
      title: e.t("fe.i"),
      list: n.getItemList(),
      clickHandler: (r) => {
        this.command(r);
      }
    };
    super(t, e, i);
  }
}
class Ay extends Bn {
  constructor(e) {
    const t = J(Rn("\\Sigma")), n = new bs(e.menusConfig.AdvancedMath), i = {
      width: 244,
      title: e.t("fe.am"),
      list: n.getItemList(),
      clickHandler: (r) => {
        this.command(r);
      }
    };
    super(t, e, i);
  }
}
class My extends Bn {
  constructor(e) {
    const t = J(Rn("\\left|x\\right|")), n = new bs(e.menusConfig.LinearAlgebra), i = {
      width: 244,
      title: e.t("fe.lg"),
      list: n.getItemList(),
      clickHandler: (r) => {
        this.command(r);
      }
    };
    super(t, e, i);
  }
}
class ky extends Bn {
  constructor(e) {
    const t = J(Rn("\\rightarrow")), n = new bs(e.menusConfig.arrows), i = {
      title: e.t("fe.a"),
      list: n.getItemList(),
      clickHandler: (r) => {
        this.command(r);
      }
    };
    super(t, e, i);
  }
}
class Py extends Bn {
  constructor(e) {
    const t = J(Rn("\\theta")), n = new bs(e.menusConfig.trigonometric), i = {
      title: e.t("fe.t"),
      list: n.getItemList(),
      clickHandler: (r) => {
        this.command(r);
      }
    };
    super(t, e, i);
  }
}
const _y = {
  presets: xy,
  operators: Cy,
  greekLetters: Ey,
  inequation: Sy,
  AdvancedMath: Ay,
  LinearAlgebra: My,
  arrows: ky,
  Trigonometric: Py
};
class Oy {
  constructor(e) {
    E(this, "editor");
    E(this, "menuList");
    E(this, "constructorList");
    this.editor = e, this.menuList = [], this.constructorList = _y;
  }
  /**
   * 自定义添加菜单
   * @param key 菜单 key ，和 editor.menusConfig.menus 对应
   * @param Menu 菜单构造函数
   */
  extend(e, t) {
    !t || typeof t != "function" || (this.constructorList[e] = t);
  }
  // 初始化菜单
  init() {
    this.editor.menusConfig.menus.forEach((t) => {
      const n = this.constructorList[t];
      this._initMenuList(t, n);
    }), this._addToToolbar();
  }
  /**
   * 创建 menu 实例，并放到 menuList 中
   * @param menuKey 菜单 key ，和 editor.menusConfig.menus 对应
   * @param MenuConstructor 菜单构造函数
   */
  _initMenuList(e, t) {
    if (typeof t == "function")
      if (this.menuList.some((n) => n.key === e))
        console.warn("Duplicate menu name:".concat(e));
      else {
        const n = new t(this.editor);
        n.key = e, this.menuList.push(n);
      }
  }
  // 添加到菜单栏
  _addToToolbar() {
    const t = this.editor.$toolbarElem;
    t.addClass("clearfix"), this.menuList.forEach((n) => {
      const i = n.$elem;
      i && t.append(i);
    });
  }
  /**
   * 获取菜单对象
   * @param 菜单名称 小写
   * @return Menus 菜单对象
   */
  menuFind(e) {
    const t = this.menuList;
    for (let n = 0, i = t.length; n < i; n++)
      if (t[n].key === e)
        return t[n];
    return t[0];
  }
}
class Ty {
  constructor(e) {
    E(this, "editor");
    this.editor = e;
  }
  /**
   * 初始化
   */
  init() {
    this._saveRange();
  }
  /**
   * 清空内容
   */
  clear() {
    this.editor.$textLatexElem.replaceChildAll(J(ro));
  }
  /**
   * 设置/获取 text
   */
  text() {
    return this.editor.$textLatexElem.text().replace(/&nbsp;/g, " ");
  }
  /**
   * 每一步操作，都实时保存选区范围
   */
  _saveRange() {
    const e = this.editor, t = e.$textLatexElem, n = J(document);
    function i() {
      e.selection.saveRange();
    }
    function r() {
      i(), e.cmd.renderFormula();
    }
    t.on("keyup", oy(r));
    function o(u) {
      const f = u.key, d = u.ctrlKey && !iy.includes(f), g = ry.includes(f);
      (d || g) && (u.preventDefault(), i(), e.cmd.insert(f, g));
    }
    t.on("keydown", o);
    function a() {
      i(), t.off("click", a);
    }
    t.on("click", a);
    function l() {
      i(), n.off("mouseup", l);
    }
    function c() {
      n.on("mouseup", l), t.off("mouseleave", c);
    }
    t.on("mousedown", () => {
      t.on("mouseleave", c);
    }), t.on("mouseup", () => {
      t.off("mouseleave", c), setTimeout(() => {
        e.selection.getRange() && i();
      }, 0);
    });
  }
}
const Ly = {
  "fe.a": "箭头符号",
  "fe.am": "高数",
  "fe.lg": "线代",
  "fe.gl": "希腊字母",
  "fe.i": "不等式",
  "fe.o": "运算符",
  "fe.p": "预设公式",
  "fe.t": "三角函数",
  "fe.l": "资源加载中...",
  "fe.pt": "勾股定理",
  "fe.h": "双曲线",
  "fe.tfr": "三角函数关系",
  "fe.d": "导数",
  "fe.nl": "牛莱公式"
};
function Dy(s) {
  return Ly[s] || s;
}
class Hd {
  constructor() {
    E(this, "config");
    E(this, "menusConfig");
    E(this, "$editorRootElem");
    E(this, "$toolbarElem");
    E(this, "$textLatexElem");
    E(this, "$textSvgElem");
    E(this, "cmd");
    E(this, "selection");
    E(this, "menus");
    E(this, "latex");
    E(this, "t");
    this.config = dy, this.menusConfig = fy, this.$editorRootElem = J('<div class="math-editor"></div>'), this.$toolbarElem = J('<div class="me-menu"></div>'), this.$textLatexElem = J('<div class="me-latex is-no-data"></div>'), this.$textSvgElem = J('<div class="me-svg"></div>'), this.cmd = new py(this), this.selection = new my(this), this.menus = new Oy(this), this.latex = new Ty(this), this.t = Dy;
  }
  /**
   * 创建编辑器 DOM
   * @param rootSelector 公式弹窗附属DOM selector
   * @param callback mathJax加载完成时执行
   */
  async create(e, t) {
    this.menus.init(), this.latex.init(), gy(this);
    const n = J(e);
    n.text(this.t("fe.l"));
    const i = () => {
      n.text("").append(this.$editorRootElem), this.initSelection(), this.$toolbarElem.renderFormula(), t && t();
    };
    Bo.loadMathJax().then(() => i());
  }
  /**
   * 二次编辑
   */
  append(e) {
    const t = Vd(e);
    this.cmd.do(t);
  }
  /**
   * 值改变
   */
  change(e) {
    e ? this.$textLatexElem.removeClass("is-no-data") : this.$textLatexElem.addClass("is-no-data");
  }
  /**
   * 初始化选区
   */
  initSelection() {
    Xa(this);
  }
  /**
   * 销毁编辑器 DOM
   */
  destroyDom() {
    this.$editorRootElem.remove();
  }
}
// 暴露 $
E(Hd, "$", J);
Bo.loadMathJax();
const Ny = /* @__PURE__ */ me({
  name: "IBizFormula",
  props: fi(),
  setup(s) {
    const e = we("formula-elem"), t = T(), n = T(null), i = T(null), r = T(""), o = T(), a = T("");
    s.data && (a.value = s.data);
    const l = async () => {
      var A, P, O;
      await ((A = n.value) == null ? void 0 : A.dismiss()), await ((P = i.value) == null ? void 0 : P.dismiss()), await ((O = t.value) == null ? void 0 : O.destroyDom());
    }, c = () => {
      if (a.value) {
        const A = a.value.replace(/&nbsp;/g, " ").trim(), P = "$ ".concat(A, " $");
        o.value.innerHTML = P, Bo.renderFormula(o.value);
      } else
        o.value.innerHTML = "输入 LaTeX 公式";
    }, u = () => {
      var A;
      a.value && ((A = t.value) == null || A.append(a.value));
    }, f = () => {
      c(), t.value = new Hd(), t.value.config = {
        width: 570,
        height: 184,
        menuHeight: 40
      }, t.value.change = (A) => {
        A ? t.value.$textLatexElem.removeClass("is-no-data") : t.value.$textLatexElem.addClass("is-no-data"), a.value = A, c();
      };
    }, d = T([{
      type: "edit",
      text: "编辑",
      icon: '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fit="" height="1em" width="1em" preserveAspectRatio="xMidYMid meet" focusable="false"><g id="ajbaction/edit" stroke-width="1" fill-rule="evenodd"><path d="M2 8.34L10.71 0 15 4.17 6.538 13H2V8.34zm1.2.512V11.8h2.826l7.283-7.6-2.606-2.533L3.2 8.852zM0 16v-1.2h16V16H0z"></path></g></svg>'
    }, {
      type: "delete",
      text: "删除",
      icon: "<svg viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em'> <g stroke-width='1' fill-rule='evenodd'> <path d='M4.002 3.403V1a1 1 0 0 1 1-1h6.003a1 1 0 0 1 1 1v2.403h3.396a.6.6 0 1 1 0 1.2h-1.395V15a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V4.603H.6a.6.6 0 1 1 0-1.2h3.4zm8.804 1.205H3.2V14.8h9.605V4.608zM5.202 1.2v2.155h5.603V1.2H5.202zm.6 6.417a.6.6 0 0 1 1.201 0v4.758a.6.6 0 0 1-1.2 0V7.617zm3.202 0a.6.6 0 0 1 1.2 0v4.758a.6.6 0 0 1-1.2 0V7.617z'></path> </g></svg>"
    }]), g = async () => {
      await l(), s.change("", {
        isDelete: !0
      });
    }, p = () => {
      var A;
      (A = i.value) == null || A.dismiss();
    }, m = () => M("div", {
      class: e.b("edit-popover")
    }, [M("div", {
      id: r.value,
      class: e.be("edit-popover", "editor")
    }, null), M("div", {
      class: e.be("edit-popover", "confirm"),
      onClick: p
    }, [M("button", {
      class: ["el-button el-button--default"]
    }, [tt("确定")])])]), w = async () => {
      r.value = rt(), i.value || (i.value = Ds(m(), {
        placement: "top-start"
      })), await i.value.present(o.value), t.value.create(document.getElementById(r.value), u), await i.value.onWillDismiss(), s.change(a.value), t.value.destroyDom(), t.value = null, n.value = null;
    }, v = async (A) => {
      if (A.type !== "separator")
        switch (A.type) {
          case "edit":
            await n.value.dismiss(), w();
            break;
          case "delete":
            g();
            break;
        }
    }, y = () => M("div", {
      class: e.b("tool-popover")
    }, [d.value.map((A) => M("div", {
      class: [e.be("tool-popover", "item"), e.is(A.type, !0)],
      title: A.text,
      onClick: () => v(A)
    }, [M("div", {
      class: e.bem("popover", "item", "content"),
      innerHTML: A.icon || A.text
    }, null)]))]), b = async () => {
      n.value = Ds(y(), {
        placement: "top-start"
      }), await n.value.present(o.value), await n.value.onWillDismiss(), n.value = null;
    }, x = this;
    let C = new ResizeObserver(() => {
      o.value && o.value.offsetWidth !== 0 && (f.bind(x)(), s.isFocus && w(), C.disconnect(), C = null);
    });
    return Ne(o, (A) => {
      A && A.click && C.observe(o.value);
    }), or(() => {
      l();
    }), {
      ns: e,
      nodeRef: o,
      openNodeOverlay: b
    };
  },
  render() {
    return M("div", {
      ref: "nodeRef",
      class: [this.ns.b(), this.readonly ? this.ns.m("readonly") : ""],
      onClick: this.openNodeOverlay
    }, null);
  }
}), Iy = () => [
  {
    id: "1",
    type: "topic",
    shape: "mind-map",
    label: "思维导图",
    width: 120,
    height: 40,
    children: [
      {
        id: "1-1",
        type: "topic-child",
        shape: "mind-map",
        label: "新建节点",
        width: 120,
        height: 30
      },
      {
        id: "1-2",
        type: "topic-child",
        shape: "mind-map",
        label: "新建节点",
        width: 120,
        height: 30
      }
    ]
  }
], jy = () => [
  {
    type: "panning",
    icon: '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fit="" height="1em" width="1em" preserveAspectRatio="xMidYMid meet" focusable="false"><g stroke-width="1" fill-rule="evenodd"><path d="M8.446.5c.628.01 1.101.34 1.416.843.035.056.067.112.096.167l.063.132.041-.018c.135-.056.282-.092.44-.106l.163-.008c.823 0 1.356.483 1.637 1.154.088.21.132.436.132.662l.002.479.08-.022c.096-.022.198-.036.304-.04l.163-.001c.63.024 1.082.338 1.326.82.143.282.19.551.19.772l-.107 6.715a3.688 3.688 0 0 1-.87 2.334 4.249 4.249 0 0 1-.364.377c-.695.637-1.403.894-1.968.94l-3.718-.02a3.014 3.014 0 0 1-.977-.333 3.486 3.486 0 0 1-.608-.398l-3.335-3.448a4.423 4.423 0 0 1-.597-.587c-.376-.443-.62-.9-.652-1.386a1.437 1.437 0 0 1 .28-.96c.242-.33.546-.547.892-.638.483-.128.952-.005 1.39.257.18.108.317.216.397.292l.352.318-.042-5.204.004-.131c.014-.228.065-.505.183-.792.251-.609.738-1.023 1.455-1.062a1.75 1.75 0 0 1 .623.073l.027.009c.021-.054.044-.108.07-.163l.085-.167C7.315.832 7.795.49 8.446.5zm-.02 1.2c-.158-.002-.263.072-.361.248-.025.044-.047.09-.064.13l-.052.126-.005.003-.001.954h.029V7.61h-1.2L6.77 3.338h-.027a.861.861 0 0 0-.044-.227l-.036-.092c-.074-.161-.166-.224-.386-.213-.208.012-.322.108-.41.321-.07.172-.096.36-.096.463l.064 7.935-2.417-2.19-.103-.075-.068-.043c-.187-.113-.355-.157-.466-.127-.072.019-.146.071-.231.188a.24.24 0 0 0-.05.172c.011.173.144.423.369.688.163.191.328.343.486.475l3.329 3.444c.026.02.063.047.109.077l.16.098.097.052c.209.11.412.183.506.201l3.584.017c.01 0 .022-.002.037-.005l.121-.028a2.606 2.606 0 0 0 1.048-.594c.09-.082.177-.172.26-.27.369-.433.576-.991.585-1.575l.108-6.702a.596.596 0 0 0-.061-.224c-.055-.107-.126-.156-.301-.163-.257-.01-.404.17-.462.454v2.132h-1.2V5.688h-.03l-.012-2.36a.513.513 0 0 0-.038-.2c-.114-.27-.276-.418-.531-.418-.208 0-.345.164-.413.403l.001 4.4h-1.2V3.288h-.037l-.028-.989-.025-.076a1.36 1.36 0 0 0-.07-.16l-.049-.084c-.116-.187-.245-.276-.417-.279z" id="arj形状结合"></path></g></svg>',
    text: "平移"
  },
  {
    type: "separator",
    text: "|"
  },
  {
    type: "delete",
    icon: '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fit="" height="1em" width="1em" preserveAspectRatio="xMidYMid meet" focusable="false"><g stroke-width="1" fill-rule="evenodd"><path d="M4.002 3.403V1a1 1 0 0 1 1-1h6.003a1 1 0 0 1 1 1v2.403h3.396a.6.6 0 1 1 0 1.2h-1.395V15a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V4.603H.6a.6.6 0 1 1 0-1.2h3.4zm8.804 1.205H3.2V14.8h9.605V4.608zM5.202 1.2v2.155h5.603V1.2H5.202zm.6 6.417a.6.6 0 0 1 1.201 0v4.758a.6.6 0 0 1-1.2 0V7.617zm3.202 0a.6.6 0 0 1 1.2 0v4.758a.6.6 0 0 1-1.2 0V7.617z" id="azk删除"></path></g></svg>',
    text: "删除"
  }
];
typeof window == "object" && window.NodeList && !NodeList.prototype.forEach && (NodeList.prototype.forEach = Array.prototype.forEach);
typeof window < "u" && function(s) {
  s.forEach((e) => {
    Object.prototype.hasOwnProperty.call(e, "append") || Object.defineProperty(e, "append", {
      configurable: !0,
      enumerable: !0,
      writable: !0,
      value(...t) {
        const n = document.createDocumentFragment();
        t.forEach((i) => {
          const r = i instanceof Node;
          n.appendChild(r ? i : document.createTextNode(String(i)));
        }), this.appendChild(n);
      }
    });
  });
}([Element.prototype, Document.prototype, DocumentFragment.prototype]);
class an {
  get disposed() {
    return this._disposed === !0;
  }
  dispose() {
    this._disposed = !0;
  }
}
(function(s) {
  function e() {
    return (t, n, i) => {
      const r = i.value, o = t.__proto__;
      i.value = function(...a) {
        this.disposed || (r.call(this, ...a), o.dispose.call(this));
      };
    };
  }
  s.dispose = e;
})(an || (an = {}));
class hh {
  constructor() {
    this.isDisposed = !1, this.items = /* @__PURE__ */ new Set();
  }
  /**
   * Test whether the set has been disposed.
   */
  get disposed() {
    return this.isDisposed;
  }
  /**
   * Dispose of the set and the items it contains.
   *
   * #### Notes
   * Items are disposed in the order they are added to the set.
   */
  dispose() {
    this.isDisposed || (this.isDisposed = !0, this.items.forEach((e) => {
      e.dispose();
    }), this.items.clear());
  }
  /**
   * Test whether the set contains a specific item.
   *
   * @param item - The item of interest.
   *
   * @returns `true` if the set contains the item, `false` otherwise.
   */
  contains(e) {
    return this.items.has(e);
  }
  /**
   * Add a disposable item to the set.
   *
   * @param item - The item to add to the set.
   *
   * #### Notes
   * If the item is already contained in the set, this is a no-op.
   */
  add(e) {
    this.items.add(e);
  }
  /**
   * Remove a disposable item from the set.
   *
   * @param item - The item to remove from the set.
   *
   * #### Notes
   * If the item is not contained in the set, this is a no-op.
   */
  remove(e) {
    this.items.delete(e);
  }
  /**
   * Remove all items from the set.
   */
  clear() {
    this.items.clear();
  }
}
(function(s) {
  function e(t) {
    const n = new s();
    return t.forEach((i) => {
      n.add(i);
    }), n;
  }
  s.from = e;
})(hh || (hh = {}));
function Ud(s, e, t) {
  if (t)
    switch (t.length) {
      case 0:
        return s.call(e);
      case 1:
        return s.call(e, t[0]);
      case 2:
        return s.call(e, t[0], t[1]);
      case 3:
        return s.call(e, t[0], t[1], t[2]);
      case 4:
        return s.call(e, t[0], t[1], t[2], t[3]);
      case 5:
        return s.call(e, t[0], t[1], t[2], t[3], t[4]);
      case 6:
        return s.call(e, t[0], t[1], t[2], t[3], t[4], t[5]);
      default:
        return s.apply(e, t);
    }
  return s.call(e);
}
function G(s, e, ...t) {
  return Ud(s, e, t);
}
function Ry(s) {
  return typeof s == "object" && s.then && typeof s.then == "function";
}
function uh(s) {
  return s != null && (s instanceof Promise || Ry(s));
}
function qd(...s) {
  const e = [];
  if (s.forEach((n) => {
    Array.isArray(n) ? e.push(...n) : e.push(n);
  }), e.some((n) => uh(n))) {
    const n = e.map((i) => uh(i) ? i : Promise.resolve(i !== !1));
    return Promise.all(n).then((i) => i.reduce((r, o) => o !== !1 && r, !0));
  }
  return e.every((n) => n !== !1);
}
function wa(s, e) {
  const t = [];
  for (let n = 0; n < s.length; n += 2) {
    const i = s[n], r = s[n + 1], o = Array.isArray(e) ? e : [e], a = Ud(i, r, o);
    t.push(a);
  }
  return qd(t);
}
class By {
  constructor() {
    this.listeners = {};
  }
  on(e, t, n) {
    return t == null ? this : (this.listeners[e] || (this.listeners[e] = []), this.listeners[e].push(t, n), this);
  }
  once(e, t, n) {
    const i = (...r) => (this.off(e, i), wa([t, n], r));
    return this.on(e, i, this);
  }
  off(e, t, n) {
    if (!(e || t || n))
      return this.listeners = {}, this;
    const i = this.listeners;
    return (e ? [e] : Object.keys(i)).forEach((o) => {
      const a = i[o];
      if (a) {
        if (!(t || n)) {
          delete i[o];
          return;
        }
        for (let l = a.length - 2; l >= 0; l -= 2)
          t && a[l] !== t || n && a[l + 1] !== n || a.splice(l, 2);
      }
    }), this;
  }
  trigger(e, ...t) {
    let n = !0;
    if (e !== "*") {
      const r = this.listeners[e];
      r != null && (n = wa([...r], t));
    }
    const i = this.listeners["*"];
    return i != null ? qd([
      n,
      wa([...i], [e, ...t])
    ]) : n;
  }
  emit(e, ...t) {
    return this.trigger(e, ...t);
  }
}
function $y(s, ...e) {
  e.forEach((t) => {
    Object.getOwnPropertyNames(t.prototype).forEach((n) => {
      n !== "constructor" && Object.defineProperty(s.prototype, n, Object.getOwnPropertyDescriptor(t.prototype, n));
    });
  });
}
const Fy = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(s, e) {
  s.__proto__ = e;
} || function(s, e) {
  for (const t in e)
    Object.prototype.hasOwnProperty.call(e, t) && (s[t] = e[t]);
};
function zy(s, e) {
  Fy(s, e);
  function t() {
    this.constructor = s;
  }
  s.prototype = e === null ? Object.create(e) : (t.prototype = e.prototype, new t());
}
class Vy {
}
const Hy = /^\s*class\s+/.test("".concat(Vy)) || /^\s*class\s*\{/.test("".concat(class {
}));
function Vl(s, e) {
  let t;
  return Hy ? t = class extends e {
  } : (t = function() {
    return e.apply(this, arguments);
  }, zy(t, e)), Object.defineProperty(t, "name", { value: s }), t;
}
function dh(s) {
  return s === "__proto__";
}
function Hl(s, e, t = "/") {
  let n;
  const i = Array.isArray(e) ? e : e.split(t);
  if (i.length)
    for (n = s; i.length; ) {
      const r = i.shift();
      if (Object(n) === n && r && r in n)
        n = n[r];
      else
        return;
    }
  return n;
}
function gi(s, e, t, n = "/") {
  const i = Array.isArray(e) ? e : e.split(n), r = i.pop();
  if (r && !dh(r)) {
    let o = s;
    i.forEach((a) => {
      dh(a) || (o[a] == null && (o[a] = {}), o = o[a]);
    }), o[r] = t;
  }
  return s;
}
function fh(s, e, t = "/") {
  const n = Array.isArray(e) ? e.slice() : e.split(t), i = n.pop();
  if (i)
    if (n.length > 0) {
      const r = Hl(s, n);
      r && delete r[i];
    } else
      delete s[i];
  return s;
}
var Uy = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class ft extends By {
  dispose() {
    this.off();
  }
}
Uy([
  an.dispose()
], ft.prototype, "dispose", null);
(function(s) {
  s.dispose = an.dispose;
})(ft || (ft = {}));
$y(ft, an);
const Gd = (s) => {
  const e = /* @__PURE__ */ Object.create(null);
  return (t) => e[t] || (e[t] = s(t));
}, Wd = Gd((s) => s.replace(/\B([A-Z])/g, "-$1").toLowerCase()), Ul = Gd((s) => rp(Eo(s)).replace(/ /g, ""));
function ya(s) {
  let e = 2166136261, t = !1, n = s;
  for (let i = 0, r = n.length; i < r; i += 1) {
    let o = n.charCodeAt(i);
    o > 127 && !t && (n = unescape(encodeURIComponent(n)), o = n.charCodeAt(i), t = !0), e ^= o, e += (e << 1) + (e << 4) + (e << 7) + (e << 8) + (e << 24);
  }
  return e >>> 0;
}
function ao() {
  let s = "";
  const e = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx";
  for (let t = 0, n = e.length; t < n; t += 1) {
    const i = e[t], r = Math.random() * 16 | 0, o = i === "x" ? r : i === "y" ? r & 3 | 8 : i;
    s += o.toString(16);
  }
  return s;
}
function qy(s, e, t) {
  const n = Math.min(2, Math.floor(s.length * 0.34));
  let i = Math.floor(s.length * 0.4) + 1, r, o = !1;
  const a = s.toLowerCase();
  for (const l of e) {
    const c = t(l);
    if (c !== void 0 && Math.abs(c.length - a.length) <= n) {
      const u = c.toLowerCase();
      if (u === a) {
        if (c === s)
          continue;
        return l;
      }
      if (o || c.length < 3)
        continue;
      const f = Gy(a, u, i - 1);
      if (f === void 0)
        continue;
      f < 3 ? (o = !0, r = l) : (i = f, r = l);
    }
  }
  return r;
}
function Gy(s, e, t) {
  let n = new Array(e.length + 1), i = new Array(e.length + 1);
  const r = t + 1;
  for (let a = 0; a <= e.length; a += 1)
    n[a] = a;
  for (let a = 1; a <= s.length; a += 1) {
    const l = s.charCodeAt(a - 1), c = a > t ? a - t : 1, u = e.length > t + a ? t + a : e.length;
    i[0] = a;
    let f = a;
    for (let g = 1; g < c; g += 1)
      i[g] = r;
    for (let g = c; g <= u; g += 1) {
      const p = l === e.charCodeAt(g - 1) ? n[g - 1] : Math.min(
        /* delete */
        n[g] + 1,
        /* insert */
        i[g - 1] + 1,
        /* substitute */
        n[g - 1] + 2
      );
      i[g] = p, f = Math.min(f, p);
    }
    for (let g = u + 1; g <= e.length; g += 1)
      i[g] = r;
    if (f > t)
      return;
    const d = n;
    n = i, i = d;
  }
  const o = n[e.length];
  return o > t ? void 0 : o;
}
function ln(s) {
  return typeof s == "string" && s.slice(-1) === "%";
}
function Ot(s, e) {
  if (s == null)
    return 0;
  let t;
  if (typeof s == "string") {
    if (t = parseFloat(s), ln(s) && (t /= 100, Number.isFinite(t)))
      return t * e;
  } else
    t = s;
  return Number.isFinite(t) ? t > 0 && t < 1 ? t * e : t : 0;
}
function us(s) {
  if (typeof s == "object") {
    let t = 0, n = 0, i = 0, r = 0;
    return s.vertical != null && Number.isFinite(s.vertical) && (n = r = s.vertical), s.horizontal != null && Number.isFinite(s.horizontal) && (i = t = s.horizontal), s.left != null && Number.isFinite(s.left) && (t = s.left), s.top != null && Number.isFinite(s.top) && (n = s.top), s.right != null && Number.isFinite(s.right) && (i = s.right), s.bottom != null && Number.isFinite(s.bottom) && (r = s.bottom), { top: n, right: i, bottom: r, left: t };
  }
  let e = 0;
  return s != null && Number.isFinite(s) && (e = s), { top: e, right: e, bottom: e, left: e };
}
let ql = !1, Jd = !1, Yd = !1, Xd = !1, Zd = !1, Kd = !1, Qd = !1, ef = !1, tf = !1, nf = !1, sf = !1, rf = !1, of = !1, af = !1, lf = !1, cf = !1;
if (typeof navigator == "object") {
  const s = navigator.userAgent;
  ql = s.indexOf("Macintosh") >= 0, Jd = !!s.match(/(iPad|iPhone|iPod)/g), Yd = s.indexOf("Windows") >= 0, Xd = s.indexOf("MSIE") >= 0, Zd = !!s.match(/Trident\/7\./), Kd = !!s.match(/Edge\//), Qd = s.indexOf("Mozilla/") >= 0 && s.indexOf("MSIE") < 0 && s.indexOf("Edge/") < 0, tf = s.indexOf("Chrome/") >= 0 && s.indexOf("Edge/") < 0, nf = s.indexOf("Opera/") >= 0 || s.indexOf("OPR/") >= 0, sf = s.indexOf("Firefox/") >= 0, rf = s.indexOf("AppleWebKit/") >= 0 && s.indexOf("Chrome/") < 0 && s.indexOf("Edge/") < 0, typeof document == "object" && (cf = !document.createElementNS || "".concat(document.createElementNS("http://www.w3.org/2000/svg", "foreignObject")) !== "[object SVGForeignObjectElement]" || s.indexOf("Opera/") >= 0);
}
typeof window == "object" && (ef = window.chrome != null && window.chrome.app != null && window.chrome.app.runtime != null, af = window.PointerEvent != null && !ql);
if (typeof document == "object") {
  of = "ontouchstart" in document.documentElement;
  try {
    const s = Object.defineProperty({}, "passive", {
      get() {
        lf = !0;
      }
    }), e = document.createElement("div");
    e.addEventListener && e.addEventListener("click", () => {
    }, s);
  } catch (s) {
  }
}
var On;
(function(s) {
  s.IS_MAC = ql, s.IS_IOS = Jd, s.IS_WINDOWS = Yd, s.IS_IE = Xd, s.IS_IE11 = Zd, s.IS_EDGE = Kd, s.IS_NETSCAPE = Qd, s.IS_CHROME_APP = ef, s.IS_CHROME = tf, s.IS_OPERA = nf, s.IS_FIREFOX = sf, s.IS_SAFARI = rf, s.SUPPORT_TOUCH = of, s.SUPPORT_POINTER = af, s.SUPPORT_PASSIVE = lf, s.NO_FOREIGNOBJECT = cf, s.SUPPORT_FOREIGNOBJECT = !s.NO_FOREIGNOBJECT;
})(On || (On = {}));
(function(s) {
  function e() {
    const r = window.module;
    return r != null && r.hot != null && r.hot.status != null ? r.hot.status() : "unkonwn";
  }
  s.getHMRStatus = e;
  function t() {
    return e() === "apply";
  }
  s.isApplyingHMR = t;
  const n = {
    select: "input",
    change: "input",
    submit: "form",
    reset: "form",
    error: "img",
    load: "img",
    abort: "img"
  };
  function i(r) {
    const o = document.createElement(n[r] || "div"), a = "on".concat(r);
    let l = a in o;
    return l || (o.setAttribute(a, "return;"), l = typeof o[a] == "function"), l;
  }
  s.isEventSupported = i;
})(On || (On = {}));
const Gl = /[\t\r\n\f]/g, Wl = /\S+/g, Vs = (s) => " ".concat(s, " ");
function Hs(s) {
  return s && s.getAttribute && s.getAttribute("class") || "";
}
function gr(s, e) {
  if (s == null || e == null)
    return !1;
  const t = Vs(Hs(s)), n = Vs(e);
  return s.nodeType === 1 ? t.replace(Gl, " ").includes(n) : !1;
}
function se(s, e) {
  if (!(s == null || e == null)) {
    if (typeof e == "function")
      return se(s, e(Hs(s)));
    if (typeof e == "string" && s.nodeType === 1) {
      const t = e.match(Wl) || [], n = Vs(Hs(s)).replace(Gl, " ");
      let i = t.reduce((r, o) => r.indexOf(Vs(o)) < 0 ? "".concat(r).concat(o, " ") : r, n);
      i = i.trim(), n !== i && s.setAttribute("class", i);
    }
  }
}
function Et(s, e) {
  if (s != null) {
    if (typeof e == "function")
      return Et(s, e(Hs(s)));
    if ((!e || typeof e == "string") && s.nodeType === 1) {
      const t = (e || "").match(Wl) || [], n = Vs(Hs(s)).replace(Gl, " ");
      let i = t.reduce((r, o) => {
        const a = Vs(o);
        return r.indexOf(a) > -1 ? r.replace(a, " ") : r;
      }, n);
      i = e ? i.trim() : "", n !== i && s.setAttribute("class", i);
    }
  }
}
function hf(s, e, t) {
  if (!(s == null || e == null)) {
    if (t != null && typeof e == "string") {
      t ? se(s, e) : Et(s, e);
      return;
    }
    if (typeof e == "function")
      return hf(s, e(Hs(s), t), t);
    typeof e == "string" && (e.match(Wl) || []).forEach((i) => {
      gr(s, i) ? Et(s, i) : se(s, i);
    });
  }
}
let gh = 0;
function Wy() {
  return gh += 1, "v".concat(gh);
}
function Jl(s) {
  return (s.id == null || s.id === "") && (s.id = Wy()), s.id;
}
function Tn(s) {
  return s == null ? !1 : typeof s.getScreenCTM == "function" && s instanceof SVGElement;
}
const Fe = {
  svg: "http://www.w3.org/2000/svg",
  xmlns: "http://www.w3.org/2000/xmlns/",
  xml: "http://www.w3.org/XML/1998/namespace",
  xlink: "http://www.w3.org/1999/xlink",
  xhtml: "http://www.w3.org/1999/xhtml"
}, ph = "1.1";
function mh(s, e = document) {
  return e.createElement(s);
}
function Yl(s, e = Fe.xhtml, t = document) {
  return t.createElementNS(e, s);
}
function jt(s, e = document) {
  return Yl(s, Fe.svg, e);
}
function lo(s) {
  if (s) {
    const t = '<svg xmlns="'.concat(Fe.svg, '" xmlns:xlink="').concat(Fe.xlink, '" version="').concat(ph, '">').concat(s, "</svg>"), { documentElement: n } = Jy(t, { async: !1 });
    return n;
  }
  const e = document.createElementNS(Fe.svg, "svg");
  return e.setAttributeNS(Fe.xmlns, "xmlns:xlink", Fe.xlink), e.setAttribute("version", ph), e;
}
function Jy(s, e = {}) {
  let t;
  try {
    const n = new DOMParser();
    if (e.async != null) {
      const i = n;
      i.async = e.async;
    }
    t = n.parseFromString(s, e.mimeType || "text/xml");
  } catch (n) {
    t = void 0;
  }
  if (!t || t.getElementsByTagName("parsererror").length)
    throw new Error("Invalid XML: ".concat(s));
  return t;
}
function Yy(s, e = !0) {
  const t = s.nodeName;
  return e ? t.toLowerCase() : t.toUpperCase();
}
function Xl(s) {
  let e = 0, t = s.previousSibling;
  for (; t; )
    t.nodeType === 1 && (e += 1), t = t.previousSibling;
  return e;
}
function Xy(s, e) {
  return s.querySelectorAll(e);
}
function Zy(s, e) {
  return s.querySelector(e);
}
function uf(s, e, t) {
  const n = s.ownerSVGElement;
  let i = s.parentNode;
  for (; i && i !== t && i !== n; ) {
    if (gr(i, e))
      return i;
    i = i.parentNode;
  }
  return null;
}
function df(s, e) {
  const t = e && e.parentNode;
  return s === t || !!(t && t.nodeType === 1 && s.compareDocumentPosition(t) & 16);
}
function Us(s) {
  s && (Array.isArray(s) ? s : [s]).forEach((t) => {
    t.parentNode && t.parentNode.removeChild(t);
  });
}
function pr(s) {
  for (; s.firstChild; )
    s.removeChild(s.firstChild);
}
function mr(s, e) {
  (Array.isArray(e) ? e : [e]).forEach((n) => {
    n != null && s.appendChild(n);
  });
}
function Ky(s, e) {
  const t = s.firstChild;
  return t ? Zl(t, e) : mr(s, e);
}
function Zl(s, e) {
  const t = s.parentNode;
  t && (Array.isArray(e) ? e : [e]).forEach((i) => {
    i != null && t.insertBefore(i, s);
  });
}
function Qy(s, e) {
  e != null && e.appendChild(s);
}
function wh(s) {
  try {
    return s instanceof HTMLElement;
  } catch (e) {
    return typeof s == "object" && s.nodeType === 1 && typeof s.style == "object" && typeof s.ownerDocument == "object";
  }
}
const ff = [
  "viewBox",
  "attributeName",
  "attributeType",
  "repeatCount",
  "textLength",
  "lengthAdjust",
  "gradientUnits"
];
function eb(s, e) {
  return s.getAttribute(e);
}
function gf(s, e) {
  const t = mf(e);
  t.ns ? s.hasAttributeNS(t.ns, t.local) && s.removeAttributeNS(t.ns, t.local) : s.hasAttribute(e) && s.removeAttribute(e);
}
function Kl(s, e, t) {
  if (t == null)
    return gf(s, e);
  const n = mf(e);
  n.ns && typeof t == "string" ? s.setAttributeNS(n.ns, e, t) : e === "id" ? s.id = "".concat(t) : s.setAttribute(e, "".concat(t));
}
function pf(s, e) {
  Object.keys(e).forEach((t) => {
    Kl(s, t, e[t]);
  });
}
function ue(s, e, t) {
  if (e == null) {
    const n = s.attributes, i = {};
    for (let r = 0; r < n.length; r += 1)
      i[n[r].name] = n[r].value;
    return i;
  }
  if (typeof e == "string" && t === void 0)
    return s.getAttribute(e);
  typeof e == "object" ? pf(s, e) : Kl(s, e, t);
}
function mf(s) {
  if (s.indexOf(":") !== -1) {
    const e = s.split(":");
    return {
      ns: Fe[e[0]],
      local: e[1]
    };
  }
  return {
    ns: null,
    local: s
  };
}
function Xi(s) {
  const e = {};
  return Object.keys(s).forEach((t) => {
    const n = ff.includes(t) ? t : Wd(t);
    e[n] = s[t];
  }), e;
}
function Tr(s) {
  const e = {};
  return s.split(";").forEach((n) => {
    const i = n.trim();
    if (i) {
      const r = i.split("=");
      r.length && (e[r[0].trim()] = r[1] ? r[1].trim() : "");
    }
  }), e;
}
function Za(s, e) {
  return Object.keys(e).forEach((t) => {
    if (t === "class")
      s[t] = s[t] ? "".concat(s[t], " ").concat(e[t]) : e[t];
    else if (t === "style") {
      const n = typeof s[t] == "object", i = typeof e[t] == "object";
      let r, o;
      n && i ? (r = s[t], o = e[t]) : n ? (r = s[t], o = Tr(e[t])) : i ? (r = Tr(s[t]), o = e[t]) : (r = Tr(s[t]), o = Tr(e[t])), s[t] = Za(r, o);
    } else
      s[t] = e[t];
  }), s;
}
function tb(s, e, t = {}) {
  const n = t.offset || 0, i = [], r = [];
  let o, a, l = null;
  for (let c = 0; c < s.length; c += 1) {
    o = r[c] = s[c];
    for (let u = 0, f = e.length; u < f; u += 1) {
      const d = e[u], g = d.start + n, p = d.end + n;
      c >= g && c < p && (typeof o == "string" ? o = r[c] = {
        t: s[c],
        attrs: d.attrs
      } : o.attrs = Za(Za({}, o.attrs), d.attrs), t.includeAnnotationIndices && (o.annotations == null && (o.annotations = []), o.annotations.push(u)));
    }
    a = r[c - 1], a ? Ci(o) && Ci(a) ? (l = l, JSON.stringify(o.attrs) === JSON.stringify(a.attrs) ? l.t += o.t : (i.push(l), l = o)) : Ci(o) || Ci(a) ? (l = l, i.push(l), l = o) : l = (l || "") + o : l = o;
  }
  return l != null && i.push(l), i;
}
function nb(s) {
  return s.replace(/ /g, " ");
}
var yh;
(function(s) {
  function e(c) {
    const u = "data:";
    return c.substr(0, u.length) === u;
  }
  s.isDataUrl = e;
  function t(c, u) {
    if (!c || e(c)) {
      setTimeout(() => u(null, c));
      return;
    }
    const f = () => {
      u(new Error("Failed to load image: ".concat(c)));
    }, d = window.FileReader ? (
      // chrome, IE10+
      (p) => {
        if (p.status === 200) {
          const m = new FileReader();
          m.onload = (w) => {
            const v = w.target.result;
            u(null, v);
          }, m.onerror = f, m.readAsDataURL(p.response);
        } else
          f();
      }
    ) : (p) => {
      const m = (w) => {
        const y = [];
        for (let b = 0; b < w.length; b += 32768)
          y.push(String.fromCharCode.apply(null, w.subarray(b, b + 32768)));
        return y.join("");
      };
      if (p.status === 200) {
        let w = c.split(".").pop() || "png";
        w === "svg" && (w = "svg+xml");
        const v = "data:image/".concat(w, ";base64,"), y = new Uint8Array(p.response), b = v + btoa(m(y));
        u(null, b);
      } else
        f();
    }, g = new XMLHttpRequest();
    g.responseType = window.FileReader ? "blob" : "arraybuffer", g.open("GET", c, !0), g.addEventListener("error", f), g.addEventListener("load", () => d(g)), g.send();
  }
  s.imageToDataUri = t;
  function n(c) {
    let u = c.replace(/\s/g, "");
    u = decodeURIComponent(u);
    const f = u.indexOf(","), d = u.slice(0, f), g = d.split(":")[1].split(";")[0], p = u.slice(f + 1);
    let m;
    d.indexOf("base64") >= 0 ? m = atob(p) : m = unescape(encodeURIComponent(p));
    const w = new Uint8Array(m.length);
    for (let v = 0; v < m.length; v += 1)
      w[v] = m.charCodeAt(v);
    return new Blob([w], { type: g });
  }
  s.dataUriToBlob = n;
  function i(c, u) {
    const f = window.navigator.msSaveBlob;
    if (f)
      f(c, u);
    else {
      const d = window.URL.createObjectURL(c), g = document.createElement("a");
      g.href = d, g.download = u, document.body.appendChild(g), g.click(), document.body.removeChild(g), window.URL.revokeObjectURL(d);
    }
  }
  s.downloadBlob = i;
  function r(c, u) {
    const f = n(c);
    i(f, u);
  }
  s.downloadDataUri = r;
  function o(c) {
    const u = c.match(/<svg[^>]*viewBox\s*=\s*(["']?)(.+?)\1[^>]*>/i);
    return u && u[2] ? u[2].replace(/\s+/, " ").split(" ") : null;
  }
  function a(c) {
    const u = parseFloat(c);
    return Number.isNaN(u) ? null : u;
  }
  function l(c, u = {}) {
    let f = null;
    const d = (b) => (f == null && (f = o(c)), f != null ? a(f[b]) : null), g = (b) => {
      const x = c.match(b);
      return x && x[2] ? a(x[2]) : null;
    };
    let p = u.width;
    if (p == null && (p = g(/<svg[^>]*width\s*=\s*(["']?)(.+?)\1[^>]*>/i)), p == null && (p = d(2)), p == null)
      throw new Error("Can not parse width from svg string");
    let m = u.height;
    if (m == null && (m = g(/<svg[^>]*height\s*=\s*(["']?)(.+?)\1[^>]*>/i)), m == null && (m = d(3)), m == null)
      throw new Error("Can not parse height from svg string");
    const w = encodeURIComponent(c).replace(/'/g, "%27").replace(/"/g, "%22"), v = "data:image/svg+xml";
    return "".concat(v, ",").concat(w);
  }
  s.svgToDataUrl = l;
})(yh || (yh = {}));
let Yn;
const sb = {
  px(s) {
    return s;
  },
  mm(s) {
    return Yn * s;
  },
  cm(s) {
    return Yn * s * 10;
  },
  in(s) {
    return Yn * s * 25.4;
  },
  pt(s) {
    return Yn * (25.4 * s / 72);
  },
  pc(s) {
    return Yn * (25.4 * s / 6);
  }
};
var bh;
(function(s) {
  function e(n, i, r) {
    const o = document.createElement("div"), a = o.style;
    a.display = "inline-block", a.position = "absolute", a.left = "-15000px", a.top = "-15000px", a.width = n + (r || "px"), a.height = i + (r || "px"), document.body.appendChild(o);
    const l = o.getBoundingClientRect(), c = {
      width: l.width || 0,
      height: l.height || 0
    };
    return document.body.removeChild(o), c;
  }
  s.measure = e;
  function t(n, i) {
    Yn == null && (Yn = e("1", "1", "mm").width);
    const r = i ? sb[i] : null;
    return r ? r(n) : n;
  }
  s.toPx = t;
})(bh || (bh = {}));
const ib = /-(.)/g;
function rb(s) {
  return s.replace(ib, (e, t) => t.toUpperCase());
}
const ba = {}, vh = ["webkit", "ms", "moz", "o"], wf = typeof document < "u" ? document.createElement("div").style : {};
function ob(s) {
  for (let e = 0; e < vh.length; e += 1) {
    const t = vh[e] + s;
    if (t in wf)
      return t;
  }
  return null;
}
function ab(s) {
  const e = rb(s);
  if (ba[e] == null) {
    const t = e.charAt(0).toUpperCase() + e.slice(1);
    ba[e] = e in wf ? e : ob(t);
  }
  return ba[e];
}
function xh(s, e) {
  const t = s.ownerDocument && s.ownerDocument.defaultView && s.ownerDocument.defaultView.opener ? s.ownerDocument.defaultView.getComputedStyle(s, null) : window.getComputedStyle(s, null);
  return t && e ? t.getPropertyValue(e) || t[e] : t;
}
const lb = {
  animationIterationCount: !0,
  columnCount: !0,
  flexGrow: !0,
  flexShrink: !0,
  fontWeight: !0,
  gridArea: !0,
  gridColumn: !0,
  gridColumnEnd: !0,
  gridColumnStart: !0,
  gridRow: !0,
  gridRowEnd: !0,
  gridRowStart: !0,
  lineHeight: !0,
  opacity: !0,
  order: !0,
  orphans: !0,
  widows: !0,
  zIndex: !0
};
function cb(s) {
  return /^--/.test(s);
}
function hb(s, e, t) {
  const n = window.getComputedStyle(s, null);
  return t ? n.getPropertyValue(e) || void 0 : n[e] || s.style[e];
}
function ub(s, e) {
  return !lb[s] && typeof e == "number" ? "".concat(e, "px") : e;
}
function wr(s, e, t) {
  if (typeof e == "string") {
    const n = cb(e);
    if (n || (e = ab(e)), t === void 0)
      return hb(s, e, n);
    n || (t = ub(e, t));
    const i = s.style;
    n ? i.setProperty(e, t) : i[e] = t;
    return;
  }
  for (const n in e)
    wr(s, n, e[n]);
}
const co = /* @__PURE__ */ new WeakMap();
function Ch(s, e) {
  const t = Eo(e), n = co.get(s);
  if (n)
    return n[t];
}
function db(s, e, t) {
  const n = Eo(e), i = co.get(s);
  i ? i[n] = t : co.set(s, {
    [n]: t
  });
}
function ds(s, e, t) {
  if (!e) {
    const n = {};
    return Object.keys(co).forEach((i) => {
      n[i] = Ch(s, i);
    }), n;
  }
  if (typeof e == "string") {
    if (t === void 0)
      return Ch(s, e);
    db(s, e, t);
    return;
  }
  for (const n in e)
    ds(s, n, e[n]);
}
class U {
  get [Symbol.toStringTag]() {
    return U.toStringTag;
  }
  get type() {
    return this.node.nodeName;
  }
  get id() {
    return this.node.id;
  }
  set id(e) {
    this.node.id = e;
  }
  constructor(e, t, n) {
    if (!e)
      throw new TypeError("Invalid element to create vector");
    let i;
    if (U.isVector(e))
      i = e.node;
    else if (typeof e == "string")
      if (e.toLowerCase() === "svg")
        i = lo();
      else if (e[0] === "<") {
        const r = lo(e);
        i = document.importNode(r.firstChild, !0);
      } else
        i = document.createElementNS(Fe.svg, e);
    else
      i = e;
    this.node = i, t && this.setAttributes(t), n && this.append(n);
  }
  transform(e, t) {
    return e == null ? qs(this.node) : (qs(this.node, e, t), this);
  }
  translate(e, t = 0, n = {}) {
    return e == null ? Sh(this.node) : (Sh(this.node, e, t, n), this);
  }
  rotate(e, t, n, i = {}) {
    return e == null ? el(this.node) : (el(this.node, e, t, n, i), this);
  }
  scale(e, t) {
    return e == null ? tl(this.node) : (tl(this.node, e, t), this);
  }
  /**
   * Returns an SVGMatrix that specifies the transformation necessary
   * to convert this coordinate system into `target` coordinate system.
   */
  getTransformToElement(e) {
    const t = U.toNode(e);
    return Li(this.node, t);
  }
  removeAttribute(e) {
    return gf(this.node, e), this;
  }
  getAttribute(e) {
    return eb(this.node, e);
  }
  setAttribute(e, t) {
    return Kl(this.node, e, t), this;
  }
  setAttributes(e) {
    return pf(this.node, e), this;
  }
  attr(e, t) {
    return e == null ? ue(this.node) : typeof e == "string" && t === void 0 ? ue(this.node, e) : (typeof e == "object" ? ue(this.node, e) : ue(this.node, e, t), this);
  }
  svg() {
    return this.node instanceof SVGSVGElement ? this : U.create(this.node.ownerSVGElement);
  }
  defs() {
    const e = this.svg() || this, t = e.node.getElementsByTagName("defs")[0];
    return t ? U.create(t) : U.create("defs").appendTo(e);
  }
  text(e, t = {}) {
    return bf(this.node, e, t), this;
  }
  tagName() {
    return Yy(this.node);
  }
  clone() {
    return U.create(this.node.cloneNode(!0));
  }
  remove() {
    return Us(this.node), this;
  }
  empty() {
    return pr(this.node), this;
  }
  append(e) {
    return mr(this.node, U.toNodes(e)), this;
  }
  appendTo(e) {
    return Qy(this.node, U.isVector(e) ? e.node : e), this;
  }
  prepend(e) {
    return Ky(this.node, U.toNodes(e)), this;
  }
  before(e) {
    return Zl(this.node, U.toNodes(e)), this;
  }
  replace(e) {
    return this.node.parentNode && this.node.parentNode.replaceChild(U.toNode(e), this.node), U.create(e);
  }
  first() {
    return this.node.firstChild ? U.create(this.node.firstChild) : null;
  }
  last() {
    return this.node.lastChild ? U.create(this.node.lastChild) : null;
  }
  get(e) {
    const t = this.node.childNodes[e];
    return t ? U.create(t) : null;
  }
  indexOf(e) {
    return Array.prototype.slice.call(this.node.childNodes).indexOf(U.toNode(e));
  }
  find(e) {
    const t = [], n = Xy(this.node, e);
    if (n)
      for (let i = 0, r = n.length; i < r; i += 1)
        t.push(U.create(n[i]));
    return t;
  }
  findOne(e) {
    const t = Zy(this.node, e);
    return t ? U.create(t) : null;
  }
  findParentByClass(e, t) {
    const n = uf(this.node, e, t);
    return n ? U.create(n) : null;
  }
  matches(e) {
    const t = this.node;
    this.node.matches;
    const n = t.matches || t.matchesSelector || t.msMatchesSelector || t.mozMatchesSelector || t.webkitMatchesSelector || t.oMatchesSelector || null;
    return n && n.call(t, e);
  }
  contains(e) {
    return df(this.node, U.isVector(e) ? e.node : e);
  }
  wrap(e) {
    const t = U.create(e), n = this.node.parentNode;
    return n != null && n.insertBefore(t.node, this.node), t.append(this);
  }
  parent(e) {
    let t = this;
    if (t.node.parentNode == null)
      return null;
    if (t = U.create(t.node.parentNode), e == null)
      return t;
    do
      if (typeof e == "string" ? t.matches(e) : t instanceof e)
        return t;
    while (t = U.create(t.node.parentNode));
    return t;
  }
  children() {
    const e = this.node.childNodes, t = [];
    for (let n = 0; n < e.length; n += 1)
      e[n].nodeType === 1 && t.push(U.create(e[n]));
    return t;
  }
  eachChild(e, t) {
    const n = this.children();
    for (let i = 0, r = n.length; i < r; i += 1)
      e.call(n[i], n[i], i, n), t && n[i].eachChild(e, t);
    return this;
  }
  index() {
    return Xl(this.node);
  }
  hasClass(e) {
    return gr(this.node, e);
  }
  addClass(e) {
    return se(this.node, e), this;
  }
  removeClass(e) {
    return Et(this.node, e), this;
  }
  toggleClass(e, t) {
    return hf(this.node, e, t), this;
  }
  toLocalPoint(e, t) {
    return Lb(this.node, e, t);
  }
  /**
   * Samples the underlying SVG element (it currently works only on
   * paths - where it is most useful anyway). Returns an array of objects
   * of the form `{ x: Number, y: Number, distance: Number }`. Each of these
   * objects represent a point on the path. This basically creates a discrete
   * representation of the path (which is possible a curve). The sampling
   * interval defines the accuracy of the sampling. In other words, we travel
   * from the beginning of the path to the end by interval distance (on the
   * path, not between the resulting points) and collect the discrete points
   * on the path. This is very useful in many situations. For example, SVG
   * does not provide a built-in mechanism to find intersections between two
   * paths. Using sampling, we can just generate bunch of points for each of
   * the path and find the closest ones from each set.
   */
  sample(e = 1) {
    return this.node instanceof SVGPathElement ? mb(this.node, e) : [];
  }
  toPath() {
    return U.create(Eb(this.node));
  }
  toPathData() {
    return Ef(this.node);
  }
}
(function(s) {
  s.toStringTag = "X6.".concat(s.name);
  function e(o) {
    if (o == null)
      return !1;
    if (o instanceof s)
      return !0;
    const a = o[Symbol.toStringTag], l = o;
    return (a == null || a === s.toStringTag) && l.node instanceof SVGElement && typeof l.sample == "function" && typeof l.toPath == "function";
  }
  s.isVector = e;
  function t(o, a, l) {
    return new s(o, a, l);
  }
  s.create = t;
  function n(o) {
    if (o[0] === "<") {
      const a = lo(o), l = [];
      for (let c = 0, u = a.childNodes.length; c < u; c += 1) {
        const f = a.childNodes[c];
        l.push(t(document.importNode(f, !0)));
      }
      return l;
    }
    return [t(o)];
  }
  s.createVectors = n;
  function i(o) {
    return e(o) ? o.node : o;
  }
  s.toNode = i;
  function r(o) {
    return Array.isArray(o) ? o.map((a) => i(a)) : [i(o)];
  }
  s.toNodes = r;
})(U || (U = {}));
function fb(s, e) {
  const t = U.create(e), n = U.create("textPath"), i = s.d;
  if (i && s["xlink:href"] === void 0) {
    const r = U.create("path").attr("d", i).appendTo(t.defs());
    n.attr("xlink:href", "#".concat(r.id));
  }
  return typeof s == "object" && n.attr(s), n.node;
}
function gb(s, e, t) {
  const n = t.eol, i = t.baseSize, r = t.lineHeight;
  let o = 0, a;
  const l = {}, c = e.length - 1;
  for (let u = 0; u <= c; u += 1) {
    let f = e[u], d = null;
    if (typeof f == "object") {
      const g = f.attrs, p = U.create("tspan", g);
      a = p.node;
      let m = f.t;
      n && u === c && (m += n), a.textContent = m;
      const w = g.class;
      w && p.addClass(w), t.includeAnnotationIndices && p.attr("annotations", f.annotations.join(",")), d = parseFloat(g["font-size"]), d === void 0 && (d = i), d && d > o && (o = d);
    } else
      n && u === c && (f += n), a = document.createTextNode(f || " "), i && i > o && (o = i);
    s.appendChild(a);
  }
  return o && (l.maxFontSize = o), r ? l.lineHeight = r : o && (l.lineHeight = o * 1.2), l;
}
const yf = /em$/;
function Lr(s, e) {
  const t = parseFloat(s);
  return yf.test(s) ? t * e : t;
}
function pb(s, e, t, n) {
  if (!Array.isArray(e))
    return 0;
  const i = e.length;
  if (!i)
    return 0;
  let r = e[0];
  const o = Lr(r.maxFontSize, t) || t;
  let a = 0;
  const l = Lr(n, t);
  for (let f = 1; f < i; f += 1) {
    r = e[f];
    const d = Lr(r.lineHeight, t) || l;
    a += d;
  }
  const c = Lr(r.maxFontSize, t) || t;
  let u;
  switch (s) {
    case "middle":
      u = o / 2 - 0.15 * c - a / 2;
      break;
    case "bottom":
      u = -(0.25 * c) - a;
      break;
    case "top":
    default:
      u = 0.8 * o;
      break;
  }
  return u;
}
function bf(s, e, t = {}) {
  e = nb(e);
  const n = t.eol;
  let i = t.textPath;
  const r = t.textVerticalAnchor, o = r === "middle" || r === "bottom" || r === "top";
  let a = t.x;
  a === void 0 && (a = s.getAttribute("x") || 0);
  const l = t.includeAnnotationIndices;
  let c = t.annotations;
  c && !Array.isArray(c) && (c = [c]);
  const u = t.lineHeight, f = u === "auto", d = f ? "1.5em" : u || "1em";
  let g = !0;
  const p = s.childNodes;
  if (p.length === 1) {
    const k = p[0];
    k && k.tagName.toUpperCase() === "TITLE" && (g = !1);
  }
  g && pr(s), ue(s, {
    // Preserve spaces, do not consecutive spaces to get collapsed to one.
    "xml:space": "preserve",
    // An empty text gets rendered into the DOM in webkit-based browsers.
    // In order to unify this behaviour across all browsers
    // we rather hide the text element when it's empty.
    display: e || t.displayEmpty ? null : "none"
  });
  const m = ue(s, "font-size");
  let w = parseFloat(m);
  w || (w = 16, (o || c) && !m && ue(s, "font-size", "".concat(w)));
  let v;
  i ? (typeof i == "string" && (i = { d: i }), v = fb(i, s)) : v = document.createDocumentFragment();
  let y, b = 0, x;
  const C = e.split("\n"), A = [], P = C.length - 1;
  for (let k = 0; k <= P; k += 1) {
    y = d;
    let D = "v-line";
    const L = jt("tspan");
    let B, ee = C[k];
    if (ee)
      if (c) {
        const q = tb(ee, c, {
          offset: -b,
          includeAnnotationIndices: l
        });
        B = gb(L, q, {
          eol: k !== P && n,
          baseSize: w,
          lineHeight: f ? null : d,
          includeAnnotationIndices: l
        });
        const _ = B.lineHeight;
        _ && f && k !== 0 && (y = _), k === 0 && (x = B.maxFontSize * 0.8);
      } else
        n && k !== P && (ee += n), L.textContent = ee;
    else {
      L.textContent = "-", D += " v-empty-line";
      const q = L.style;
      q.fillOpacity = 0, q.strokeOpacity = 0, c && (B = {});
    }
    B && A.push(B), k > 0 && L.setAttribute("dy", y), (k > 0 || i) && L.setAttribute("x", a), L.className.baseVal = D, v.appendChild(L), b += ee.length + 1;
  }
  if (o)
    if (c)
      y = pb(r, A, w, d);
    else if (r === "top")
      y = "0.8em";
    else {
      let k;
      switch (P > 0 ? (k = parseFloat(d) || 1, k *= P, yf.test(d) || (k /= w)) : k = 0, r) {
        case "middle":
          y = "".concat(0.3 - k / 2, "em");
          break;
        case "bottom":
          y = "".concat(-k - 0.3, "em");
          break;
      }
    }
  else
    r === 0 ? y = "0em" : r ? y = r : (y = 0, s.getAttribute("y") == null && s.setAttribute("y", "".concat(x || "0.8em")));
  v.firstChild.setAttribute("dy", y), s.appendChild(v);
}
function Ti(s, e = {}) {
  const t = document.createElement("canvas").getContext("2d");
  if (!s)
    return { width: 0 };
  const n = [], i = e["font-size"] ? "".concat(parseFloat(e["font-size"]), "px") : "14px";
  return n.push(e["font-style"] || "normal"), n.push(e["font-variant"] || "normal"), n.push(e["font-weight"] || 400), n.push(i), n.push(e["font-family"] || "sans-serif"), t.font = n.join(" "), t.measureText(s);
}
function Eh(s, e, t, n = {}) {
  if (e >= t)
    return [s, ""];
  const i = s.length, r = {};
  let o = Math.round(e / t * i - 1);
  for (o < 0 && (o = 0); o >= 0 && o < i; ) {
    const a = s.slice(0, o), l = r[a] || Ti(a, n).width, c = s.slice(0, o + 1), u = r[c] || Ti(c, n).width;
    if (r[a] = l, r[c] = u, l > e)
      o -= 1;
    else if (u <= e)
      o += 1;
    else
      break;
  }
  return [s.slice(0, o), s.slice(o)];
}
function vf(s, e, t = {}, n = {}) {
  const i = e.width, r = e.height, o = n.eol || "\n", a = t.fontSize || 14, l = t.lineHeight ? parseFloat(t.lineHeight) : Math.ceil(a * 1.4), c = Math.floor(r / l);
  if (s.indexOf(o) > -1) {
    const w = ao(), v = [];
    return s.split(o).map((y) => {
      const b = vf(y, Object.assign(Object.assign({}, e), { height: Number.MAX_SAFE_INTEGER }), t, Object.assign(Object.assign({}, n), { eol: w }));
      b && v.push(...b.split(w));
    }), v.slice(0, c).join(o);
  }
  const { width: u } = Ti(s, t);
  if (u < i)
    return s;
  const f = [];
  let d = s, g = u, p = n.ellipsis, m = 0;
  p && (typeof p != "string" && (p = "…"), m = Ti(p, t).width);
  for (let w = 0; w < c; w += 1)
    if (g > i)
      if (w === c - 1) {
        const [y] = Eh(d, i - m, g, t);
        f.push(p ? "".concat(y).concat(p) : y);
      } else {
        const [y, b] = Eh(d, i, g, t);
        f.push(y), d = b, g = Ti(d, t).width;
      }
    else {
      f.push(d);
      break;
    }
  return f.join(o);
}
const Ka = 0.551784;
function qe(s, e, t = NaN) {
  const n = s.getAttribute(e);
  if (n == null)
    return t;
  const i = parseFloat(n);
  return Number.isNaN(i) ? t : i;
}
function mb(s, e = 1) {
  const t = s.getTotalLength(), n = [];
  let i = 0, r;
  for (; i < t; )
    r = s.getPointAtLength(i), n.push({ distance: i, x: r.x, y: r.y }), i += e;
  return n;
}
function wb(s) {
  return [
    "M",
    qe(s, "x1"),
    qe(s, "y1"),
    "L",
    qe(s, "x2"),
    qe(s, "y2")
  ].join(" ");
}
function yb(s) {
  const e = ho(s);
  return e.length === 0 ? null : "".concat(xf(e), " Z");
}
function bb(s) {
  const e = ho(s);
  return e.length === 0 ? null : xf(e);
}
function xf(s) {
  const e = s.map((t) => "".concat(t.x, " ").concat(t.y));
  return "M ".concat(e.join(" L"));
}
function ho(s) {
  const e = [], t = s.points;
  if (t)
    for (let n = 0, i = t.numberOfItems; n < i; n += 1)
      e.push(t.getItem(n));
  return e;
}
function vb(s) {
  const e = qe(s, "cx", 0), t = qe(s, "cy", 0), n = qe(s, "r"), i = n * Ka;
  return [
    "M",
    e,
    t - n,
    "C",
    e + i,
    t - n,
    e + n,
    t - i,
    e + n,
    t,
    "C",
    e + n,
    t + i,
    e + i,
    t + n,
    e,
    t + n,
    "C",
    e - i,
    t + n,
    e - n,
    t + i,
    e - n,
    t,
    "C",
    e - n,
    t - i,
    e - i,
    t - n,
    e,
    t - n,
    "Z"
  ].join(" ");
}
function xb(s) {
  const e = qe(s, "cx", 0), t = qe(s, "cy", 0), n = qe(s, "rx"), i = qe(s, "ry") || n, r = n * Ka, o = i * Ka;
  return [
    "M",
    e,
    t - i,
    "C",
    e + r,
    t - i,
    e + n,
    t - o,
    e + n,
    t,
    "C",
    e + n,
    t + o,
    e + r,
    t + i,
    e,
    t + i,
    "C",
    e - r,
    t + i,
    e - n,
    t + o,
    e - n,
    t,
    "C",
    e - n,
    t - o,
    e - r,
    t - i,
    e,
    t - i,
    "Z"
  ].join(" ");
}
function Cb(s) {
  return Cf({
    x: qe(s, "x", 0),
    y: qe(s, "y", 0),
    width: qe(s, "width", 0),
    height: qe(s, "height", 0),
    rx: qe(s, "rx", 0),
    ry: qe(s, "ry", 0)
  });
}
function Cf(s) {
  let e;
  const t = s.x, n = s.y, i = s.width, r = s.height, o = Math.min(s.rx || s["top-rx"] || 0, i / 2), a = Math.min(s.rx || s["bottom-rx"] || 0, i / 2), l = Math.min(s.ry || s["top-ry"] || 0, r / 2), c = Math.min(s.ry || s["bottom-ry"] || 0, r / 2);
  return o || a || l || c ? e = [
    "M",
    t,
    n + l,
    "v",
    r - l - c,
    "a",
    a,
    c,
    0,
    0,
    0,
    a,
    c,
    "h",
    i - 2 * a,
    "a",
    a,
    c,
    0,
    0,
    0,
    a,
    -c,
    "v",
    -(r - c - l),
    "a",
    o,
    l,
    0,
    0,
    0,
    -o,
    -l,
    "h",
    -(i - 2 * o),
    "a",
    o,
    l,
    0,
    0,
    0,
    -o,
    l,
    "Z"
  ] : e = ["M", t, n, "H", t + i, "V", n + r, "H", t, "V", n, "Z"], e.join(" ");
}
function Eb(s) {
  const e = jt("path");
  ue(e, ue(s));
  const t = Ef(s);
  return t && e.setAttribute("d", t), e;
}
function Ef(s) {
  const e = s.tagName.toLowerCase();
  switch (e) {
    case "path":
      return s.getAttribute("d");
    case "line":
      return wb(s);
    case "polygon":
      return yb(s);
    case "polyline":
      return bb(s);
    case "ellipse":
      return xb(s);
    case "circle":
      return vb(s);
    case "rect":
      return Cb(s);
  }
  throw new Error('"'.concat(e, '" cannot be converted to svg path element.'));
}
const Sb = /(\w+)\(([^,)]+),?([^)]+)?\)/gi, Sf = /[ ,]+/, Ab = /^(\w+)\((.*)\)/;
function Mb(s, e) {
  const n = jt("svg").createSVGPoint();
  return n.x = s, n.y = e, n;
}
function Ve(s) {
  const t = jt("svg").createSVGMatrix();
  if (s != null) {
    const n = s, i = t;
    for (const r in n)
      i[r] = n[r];
  }
  return t;
}
function Ei(s) {
  const e = jt("svg");
  return s != null ? (s instanceof DOMMatrix || (s = Ve(s)), e.createSVGTransformFromMatrix(s)) : e.createSVGTransform();
}
function Zi(s) {
  let e = Ve();
  const t = s != null && s.match(Sb);
  if (!t)
    return e;
  for (let n = 0, i = t.length; n < i; n += 1) {
    const o = t[n].match(Ab);
    if (o) {
      let a, l, c, u, f, d = Ve();
      const g = o[2].split(Sf);
      switch (o[1].toLowerCase()) {
        case "scale":
          a = parseFloat(g[0]), l = g[1] === void 0 ? a : parseFloat(g[1]), d = d.scaleNonUniform(a, l);
          break;
        case "translate":
          c = parseFloat(g[0]), u = parseFloat(g[1]), d = d.translate(c, u);
          break;
        case "rotate":
          f = parseFloat(g[0]), c = parseFloat(g[1]) || 0, u = parseFloat(g[2]) || 0, c !== 0 || u !== 0 ? d = d.translate(c, u).rotate(f).translate(-c, -u) : d = d.rotate(f);
          break;
        case "skewx":
          f = parseFloat(g[0]), d = d.skewX(f);
          break;
        case "skewy":
          f = parseFloat(g[0]), d = d.skewY(f);
          break;
        case "matrix":
          d.a = parseFloat(g[0]), d.b = parseFloat(g[1]), d.c = parseFloat(g[2]), d.d = parseFloat(g[3]), d.e = parseFloat(g[4]), d.f = parseFloat(g[5]);
          break;
        default:
          continue;
      }
      e = e.multiply(d);
    }
  }
  return e;
}
function pi(s) {
  const e = s || {}, t = e.a != null ? e.a : 1, n = e.b != null ? e.b : 0, i = e.c != null ? e.c : 0, r = e.d != null ? e.d : 1, o = e.e != null ? e.e : 0, a = e.f != null ? e.f : 0;
  return "matrix(".concat(t, ",").concat(n, ",").concat(i, ",").concat(r, ",").concat(o, ",").concat(a, ")");
}
function $o(s) {
  let e, t, n;
  if (s) {
    const r = Sf;
    if (s.trim().indexOf("matrix") >= 0) {
      const o = Zi(s), a = kb(o);
      e = [a.translateX, a.translateY], t = [a.rotation], n = [a.scaleX, a.scaleY];
      const l = [];
      (e[0] !== 0 || e[1] !== 0) && l.push("translate(".concat(e.join(","), ")")), (n[0] !== 1 || n[1] !== 1) && l.push("scale(".concat(n.join(","), ")")), t[0] !== 0 && l.push("rotate(".concat(t[0], ")")), s = l.join(" ");
    } else {
      const o = s.match(/translate\((.*?)\)/);
      o && (e = o[1].split(r));
      const a = s.match(/rotate\((.*?)\)/);
      a && (t = a[1].split(r));
      const l = s.match(/scale\((.*?)\)/);
      l && (n = l[1].split(r));
    }
  }
  const i = n && n[0] ? parseFloat(n[0]) : 1;
  return {
    raw: s || "",
    translation: {
      tx: e && e[0] ? parseInt(e[0], 10) : 0,
      ty: e && e[1] ? parseInt(e[1], 10) : 0
    },
    rotation: {
      angle: t && t[0] ? parseInt(t[0], 10) : 0,
      cx: t && t[1] ? parseInt(t[1], 10) : void 0,
      cy: t && t[2] ? parseInt(t[2], 10) : void 0
    },
    scale: {
      sx: i,
      sy: n && n[1] ? parseFloat(n[1]) : i
    }
  };
}
function Qa(s, e) {
  const t = e.x * s.a + e.y * s.c + 0, n = e.x * s.b + e.y * s.d + 0;
  return { x: t, y: n };
}
function kb(s) {
  const e = Qa(s, { x: 0, y: 1 }), t = Qa(s, { x: 1, y: 0 }), n = 180 / Math.PI * Math.atan2(e.y, e.x) - 90, i = 180 / Math.PI * Math.atan2(t.y, t.x);
  return {
    skewX: n,
    skewY: i,
    translateX: s.e,
    translateY: s.f,
    scaleX: Math.sqrt(s.a * s.a + s.b * s.b),
    scaleY: Math.sqrt(s.c * s.c + s.d * s.d),
    rotation: n
  };
}
function Pb(s) {
  let e, t, n, i;
  return s ? (e = s.a == null ? 1 : s.a, i = s.d == null ? 1 : s.d, t = s.b, n = s.c) : e = i = 1, {
    sx: t ? Math.sqrt(e * e + t * t) : e,
    sy: n ? Math.sqrt(n * n + i * i) : i
  };
}
function _b(s) {
  let e = { x: 0, y: 1 };
  s && (e = Qa(s, e));
  const t = 180 * Math.atan2(e.y, e.x) / Math.PI % 360 - 90;
  return {
    angle: t % 360 + (t < 0 ? 360 : 0)
  };
}
function Ob(s) {
  return {
    tx: s && s.e || 0,
    ty: s && s.f || 0
  };
}
function qs(s, e, t = {}) {
  if (e == null)
    return Zi(ue(s, "transform"));
  if (t.absolute) {
    s.setAttribute("transform", pi(e));
    return;
  }
  const n = s.transform, i = Ei(e);
  n.baseVal.appendItem(i);
}
function Sh(s, e, t = 0, n = {}) {
  let i = ue(s, "transform");
  const r = $o(i);
  if (e == null)
    return r.translation;
  i = r.raw, i = i.replace(/translate\([^)]*\)/g, "").trim();
  const o = n.absolute ? e : r.translation.tx + e, a = n.absolute ? t : r.translation.ty + t, l = "translate(".concat(o, ",").concat(a, ")");
  s.setAttribute("transform", "".concat(l, " ").concat(i).trim());
}
function el(s, e, t, n, i = {}) {
  let r = ue(s, "transform");
  const o = $o(r);
  if (e == null)
    return o.rotation;
  r = o.raw, r = r.replace(/rotate\([^)]*\)/g, "").trim(), e %= 360;
  const a = i.absolute ? e : o.rotation.angle + e, l = t != null && n != null ? ",".concat(t, ",").concat(n) : "", c = "rotate(".concat(a).concat(l, ")");
  s.setAttribute("transform", "".concat(r, " ").concat(c).trim());
}
function tl(s, e, t) {
  let n = ue(s, "transform");
  const i = $o(n);
  if (e == null)
    return i.scale;
  t = t == null ? e : t, n = i.raw, n = n.replace(/scale\([^)]*\)/g, "").trim();
  const r = "scale(".concat(e, ",").concat(t, ")");
  s.setAttribute("transform", "".concat(n, " ").concat(r).trim());
}
function Li(s, e) {
  if (Tn(e) && Tn(s)) {
    const t = e.getScreenCTM(), n = s.getScreenCTM();
    if (t && n)
      return t.inverse().multiply(n);
  }
  return Ve();
}
function Tb(s, e) {
  let t = Ve();
  if (Tn(e) && Tn(s)) {
    let n = s;
    const i = [];
    for (; n && n !== e; ) {
      const r = n.getAttribute("transform") || null, o = Zi(r);
      i.push(o), n = n.parentNode;
    }
    i.reverse().forEach((r) => {
      t = t.multiply(r);
    });
  }
  return t;
}
function Lb(s, e, t) {
  const n = s instanceof SVGSVGElement ? s : s.ownerSVGElement, i = n.createSVGPoint();
  i.x = e, i.y = t;
  try {
    const r = n.getScreenCTM(), o = i.matrixTransform(r.inverse()), a = Li(s, n).inverse();
    return o.matrixTransform(a);
  } catch (r) {
    return i;
  }
}
var bt;
(function(s) {
  const e = {};
  function t(r) {
    return e[r] || {};
  }
  s.get = t;
  function n(r, o) {
    e[r] = o;
  }
  s.register = n;
  function i(r) {
    delete e[r];
  }
  s.unregister = i;
})(bt || (bt = {}));
var Zn;
(function(s) {
  const e = /* @__PURE__ */ new WeakMap();
  function t(r) {
    return e.has(r) || e.set(r, { events: /* @__PURE__ */ Object.create(null) }), e.get(r);
  }
  s.ensure = t;
  function n(r) {
    return e.get(r);
  }
  s.get = n;
  function i(r) {
    return e.delete(r);
  }
  s.remove = i;
})(Zn || (Zn = {}));
var Y;
(function(s) {
  s.returnTrue = () => !0, s.returnFalse = () => !1;
  function e(i) {
    i.stopPropagation();
  }
  s.stopPropagationCallback = e;
  function t(i, r, o) {
    i.addEventListener != null && i.addEventListener(r, o);
  }
  s.addEventListener = t;
  function n(i, r, o) {
    i.removeEventListener != null && i.removeEventListener(r, o);
  }
  s.removeEventListener = n;
})(Y || (Y = {}));
(function(s) {
  const e = /[^\x20\t\r\n\f]+/g, t = /^([^.]*)(?:\.(.+)|)/;
  function n(a) {
    return (a || "").match(e) || [""];
  }
  s.splitType = n;
  function i(a) {
    const l = t.exec(a) || [];
    return {
      originType: l[1] ? l[1].trim() : l[1],
      namespaces: l[2] ? l[2].split(".").map((c) => c.trim()).sort() : []
    };
  }
  s.normalizeType = i;
  function r(a) {
    return a.nodeType === 1 || a.nodeType === 9 || !+a.nodeType;
  }
  s.isValidTarget = r;
  function o(a, l) {
    if (l) {
      const c = a;
      return c.querySelector != null && c.querySelector(l) != null;
    }
    return !0;
  }
  s.isValidSelector = o;
})(Y || (Y = {}));
(function(s) {
  let e = 0;
  const t = /* @__PURE__ */ new WeakMap();
  function n(a) {
    return t.has(a) || (t.set(a, e), e += 1), t.get(a);
  }
  s.ensureHandlerId = n;
  function i(a) {
    return t.get(a);
  }
  s.getHandlerId = i;
  function r(a) {
    return t.delete(a);
  }
  s.removeHandlerId = r;
  function o(a, l) {
    return t.set(a, l);
  }
  s.setHandlerId = o;
})(Y || (Y = {}));
(function(s) {
  function e(t, n) {
    const i = [], r = Zn.get(t), o = r && r.events && r.events[n.type], a = o && o.handlers || [], l = o ? o.delegateCount : 0;
    if (l > 0 && // Support: Firefox <=42 - 66+
    // Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
    // https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
    // Support: IE 11+
    // ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
    !(n.type === "click" && typeof n.button == "number" && n.button >= 1)) {
      for (let c = n.target; c !== t; c = c.parentNode || t)
        if (c.nodeType === 1 && !(n.type === "click" && c.disabled === !0)) {
          const u = [], f = {};
          for (let d = 0; d < l; d += 1) {
            const g = a[d], p = g.selector;
            if (p != null && f[p] == null) {
              const m = t, w = [];
              m.querySelectorAll(p).forEach((v) => {
                w.push(v);
              }), f[p] = w.includes(c);
            }
            f[p] && u.push(g);
          }
          u.length && i.push({ elem: c, handlers: u });
        }
    }
    return l < a.length && i.push({ elem: t, handlers: a.slice(l) }), i;
  }
  s.getHandlerQueue = e;
})(Y || (Y = {}));
(function(s) {
  function e(t) {
    return t != null && t === t.window;
  }
  s.isWindow = e;
})(Y || (Y = {}));
(function(s) {
  function e(t, n) {
    const i = t.nodeType === 9 ? t.documentElement : t, r = n && n.parentNode;
    return t === r || !!(r && r.nodeType === 1 && // Support: IE 9 - 11+
    // IE doesn't have `contains` on SVG.
    (i.contains ? i.contains(r) : t.compareDocumentPosition && t.compareDocumentPosition(r) & 16));
  }
  s.contains = e;
})(Y || (Y = {}));
class zt {
  constructor(e, t) {
    this.isDefaultPrevented = Y.returnFalse, this.isPropagationStopped = Y.returnFalse, this.isImmediatePropagationStopped = Y.returnFalse, this.isSimulated = !1, this.preventDefault = () => {
      const n = this.originalEvent;
      this.isDefaultPrevented = Y.returnTrue, n && !this.isSimulated && n.preventDefault();
    }, this.stopPropagation = () => {
      const n = this.originalEvent;
      this.isPropagationStopped = Y.returnTrue, n && !this.isSimulated && n.stopPropagation();
    }, this.stopImmediatePropagation = () => {
      const n = this.originalEvent;
      this.isImmediatePropagationStopped = Y.returnTrue, n && !this.isSimulated && n.stopImmediatePropagation(), this.stopPropagation();
    }, typeof e == "string" ? this.type = e : e.type && (this.originalEvent = e, this.type = e.type, this.isDefaultPrevented = e.defaultPrevented ? Y.returnTrue : Y.returnFalse, this.target = e.target, this.currentTarget = e.currentTarget, this.relatedTarget = e.relatedTarget, this.timeStamp = e.timeStamp), t && Object.assign(this, t), this.timeStamp || (this.timeStamp = Date.now());
  }
}
(function(s) {
  function e(t) {
    return t instanceof s ? t : new s(t);
  }
  s.create = e;
})(zt || (zt = {}));
(function(s) {
  function e(t, n) {
    Object.defineProperty(s.prototype, t, {
      enumerable: !0,
      configurable: !0,
      get: typeof n == "function" ? (
        // eslint-disable-next-line
        function() {
          if (this.originalEvent)
            return n(this.originalEvent);
        }
      ) : (
        // eslint-disable-next-line
        function() {
          if (this.originalEvent)
            return this.originalEvent[t];
        }
      ),
      set(i) {
        Object.defineProperty(this, t, {
          enumerable: !0,
          configurable: !0,
          writable: !0,
          value: i
        });
      }
    });
  }
  s.addProperty = e;
})(zt || (zt = {}));
(function(s) {
  const e = {
    bubbles: !0,
    cancelable: !0,
    eventPhase: !0,
    detail: !0,
    view: !0,
    button: !0,
    buttons: !0,
    clientX: !0,
    clientY: !0,
    offsetX: !0,
    offsetY: !0,
    pageX: !0,
    pageY: !0,
    screenX: !0,
    screenY: !0,
    toElement: !0,
    pointerId: !0,
    pointerType: !0,
    char: !0,
    code: !0,
    charCode: !0,
    key: !0,
    keyCode: !0,
    touches: !0,
    changedTouches: !0,
    targetTouches: !0,
    which: !0,
    altKey: !0,
    ctrlKey: !0,
    metaKey: !0,
    shiftKey: !0
  };
  Object.keys(e).forEach((t) => s.addProperty(t, e[t]));
})(zt || (zt = {}));
(function(s) {
  bt.register("load", {
    noBubble: !0
  });
})();
(function(s) {
  bt.register("beforeunload", {
    postDispatch(e, t) {
      t.result !== void 0 && t.originalEvent && (t.originalEvent.returnValue = t.result);
    }
  });
})();
(function(s) {
  bt.register("mouseenter", {
    delegateType: "mouseover",
    bindType: "mouseover",
    handle(e, t) {
      let n;
      const i = t.relatedTarget, r = t.handleObj;
      return (!i || i !== e && !Y.contains(e, i)) && (t.type = r.originType, n = r.handler.call(e, t), t.type = "mouseover"), n;
    }
  }), bt.register("mouseleave", {
    delegateType: "mouseout",
    bindType: "mouseout",
    handle(e, t) {
      let n;
      const i = t.relatedTarget, r = t.handleObj;
      return (!i || i !== e && !Y.contains(e, i)) && (t.type = r.originType, n = r.handler.call(e, t), t.type = "mouseout"), n;
    }
  });
})();
var Db = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
}, Ki;
(function(s) {
  let e;
  function t(o, a, l, c, u) {
    if (!Y.isValidTarget(o))
      return;
    let f;
    if (typeof l != "function") {
      const { handler: m, selector: w } = l, v = Db(l, ["handler", "selector"]);
      l = m, u = w, f = v;
    }
    const d = Zn.ensure(o);
    let g = d.handler;
    g == null && (g = d.handler = function(m, ...w) {
      return e !== m.type ? i(o, m, ...w) : void 0;
    });
    const p = Y.ensureHandlerId(l);
    Y.splitType(a).forEach((m) => {
      const { originType: w, namespaces: v } = Y.normalizeType(m);
      if (!w)
        return;
      let y = w, b = bt.get(y);
      y = (u ? b.delegateType : b.bindType) || y, b = bt.get(y);
      const x = Object.assign({
        type: y,
        originType: w,
        data: c,
        selector: u,
        guid: p,
        handler: l,
        namespace: v.join(".")
      }, f), C = d.events;
      let A = C[y];
      A || (A = C[y] = { handlers: [], delegateCount: 0 }, (!b.setup || b.setup(o, c, v, g) === !1) && Y.addEventListener(o, y, g)), b.add && (Y.removeHandlerId(x.handler), b.add(o, x), Y.setHandlerId(x.handler, p)), u ? (A.handlers.splice(A.delegateCount, 0, x), A.delegateCount += 1) : A.handlers.push(x);
    });
  }
  s.on = t;
  function n(o, a, l, c, u) {
    const f = Zn.get(o);
    if (!f)
      return;
    const d = f.events;
    d && (Y.splitType(a).forEach((g) => {
      const { originType: p, namespaces: m } = Y.normalizeType(g);
      if (!p) {
        Object.keys(d).forEach((C) => {
          n(o, C + g, l, c, !0);
        });
        return;
      }
      let w = p;
      const v = bt.get(w);
      w = (c ? v.delegateType : v.bindType) || w;
      const y = d[w];
      if (!y)
        return;
      const b = m.length > 0 ? new RegExp("(^|\\.)".concat(m.join("\\.(?:.*\\.|)"), "(\\.|$)")) : null, x = y.handlers.length;
      for (let C = y.handlers.length - 1; C >= 0; C -= 1) {
        const A = y.handlers[C];
        (u || p === A.originType) && (!l || Y.getHandlerId(l) === A.guid) && (b == null || A.namespace && b.test(A.namespace)) && (c == null || c === A.selector || c === "**" && A.selector) && (y.handlers.splice(C, 1), A.selector && (y.delegateCount -= 1), v.remove && v.remove(o, A));
      }
      x && y.handlers.length === 0 && ((!v.teardown || v.teardown(o, m, f.handler) === !1) && Y.removeEventListener(o, w, f.handler), delete d[w]);
    }), Object.keys(d).length === 0 && Zn.remove(o));
  }
  s.off = n;
  function i(o, a, ...l) {
    const c = zt.create(a);
    c.delegateTarget = o;
    const u = bt.get(c.type);
    if (u.preDispatch && u.preDispatch(o, c) === !1)
      return;
    const f = Y.getHandlerQueue(o, c);
    for (let d = 0, g = f.length; d < g && !c.isPropagationStopped(); d += 1) {
      const p = f[d];
      c.currentTarget = p.elem;
      for (let m = 0, w = p.handlers.length; m < w && !c.isImmediatePropagationStopped(); m += 1) {
        const v = p.handlers[m];
        if (c.rnamespace == null || v.namespace && c.rnamespace.test(v.namespace)) {
          c.handleObj = v, c.data = v.data;
          const y = bt.get(v.originType).handle, b = y ? y(p.elem, c, ...l) : v.handler.call(p.elem, c, ...l);
          b !== void 0 && (c.result = b, b === !1 && (c.preventDefault(), c.stopPropagation()));
        }
      }
    }
    return u.postDispatch && u.postDispatch(o, c), c.result;
  }
  s.dispatch = i;
  function r(o, a, l, c) {
    let u = o, f = typeof o == "string" ? o : o.type, d = typeof o == "string" || u.namespace == null ? [] : u.namespace.split(".");
    const g = l;
    if (g.nodeType === 3 || g.nodeType === 8)
      return;
    f.indexOf(".") > -1 && (d = f.split("."), f = d.shift(), d.sort());
    const p = f.indexOf(":") < 0 && "on".concat(f);
    u = o instanceof zt ? o : new zt(f, typeof o == "object" ? o : null), u.namespace = d.join("."), u.rnamespace = u.namespace ? new RegExp("(^|\\.)".concat(d.join("\\.(?:.*\\.|)"), "(\\.|$)")) : null, u.result = void 0, u.target || (u.target = g);
    const m = [u];
    Array.isArray(a) ? m.push(...a) : m.push(a);
    const w = bt.get(f);
    if (!c && w.trigger && w.trigger(g, u, a) === !1)
      return;
    let v;
    const y = [g];
    if (!c && !w.noBubble && !Y.isWindow(g)) {
      v = w.delegateType || f;
      let x = g, C = g.parentNode;
      for (; C != null; )
        y.push(C), x = C, C = C.parentNode;
      const A = g.ownerDocument || document;
      if (x === A) {
        const P = x.defaultView || x.parentWindow || window;
        y.push(P);
      }
    }
    let b = g;
    for (let x = 0, C = y.length; x < C && !u.isPropagationStopped(); x += 1) {
      const A = y[x];
      b = A, u.type = x > 1 ? v : w.bindType || f;
      const P = Zn.get(A);
      P && P.events[u.type] && P.handler && P.handler.call(A, ...m);
      const O = p && A[p] || null;
      O && Y.isValidTarget(A) && (u.result = O.call(A, ...m), u.result === !1 && u.preventDefault());
    }
    if (u.type = f, !c && !u.isDefaultPrevented()) {
      const x = w.preventDefault;
      if ((x == null || x(y.pop(), u, a) === !1) && Y.isValidTarget(g) && p && typeof g[f] == "function" && !Y.isWindow(g)) {
        const C = g[p];
        C && (g[p] = null), e = f, u.isPropagationStopped() && b.addEventListener(f, Y.stopPropagationCallback), g[f](), u.isPropagationStopped() && b.removeEventListener(f, Y.stopPropagationCallback), e = void 0, C && (g[p] = C);
      }
    }
    return u.result;
  }
  s.trigger = r;
})(Ki || (Ki = {}));
var Ue;
(function(s) {
  function e(r, o, a, l, c) {
    return Di.on(r, o, a, l, c), r;
  }
  s.on = e;
  function t(r, o, a, l, c) {
    return Di.on(r, o, a, l, c, !0), r;
  }
  s.once = t;
  function n(r, o, a, l) {
    return Di.off(r, o, a, l), r;
  }
  s.off = n;
  function i(r, o, a, l) {
    return Ki.trigger(o, a, r, l), r;
  }
  s.trigger = i;
})(Ue || (Ue = {}));
var Di;
(function(s) {
  function e(n, i, r, o, a, l) {
    if (typeof i == "object") {
      typeof r != "string" && (o = o || r, r = void 0), Object.keys(i).forEach((c) => e(n, c, r, o, i[c], l));
      return;
    }
    if (o == null && a == null ? (a = r, o = r = void 0) : a == null && (typeof r == "string" ? (a = o, o = void 0) : (a = o, o = r, r = void 0)), a === !1)
      a = Y.returnFalse;
    else if (!a)
      return;
    if (l) {
      const c = a;
      a = function(u, ...f) {
        return s.off(n, u), c.call(this, u, ...f);
      }, Y.setHandlerId(a, Y.ensureHandlerId(c));
    }
    Ki.on(n, i, a, o, r);
  }
  s.on = e;
  function t(n, i, r, o) {
    const a = i;
    if (a && a.preventDefault != null && a.handleObj != null) {
      const l = a.handleObj;
      t(a.delegateTarget, l.namespace ? "".concat(l.originType, ".").concat(l.namespace) : l.originType, l.selector, l.handler);
      return;
    }
    if (typeof i == "object") {
      const l = i;
      Object.keys(l).forEach((c) => t(n, c, r, l[c]));
      return;
    }
    (r === !1 || typeof r == "function") && (o = r, r = void 0), o === !1 && (o = Y.returnFalse), Ki.off(n, i, o, r);
  }
  s.off = t;
})(Di || (Di = {}));
class Af {
  constructor(e, t, n) {
    this.animationFrameId = 0, this.deltaX = 0, this.deltaY = 0, this.eventName = On.isEventSupported("wheel") ? "wheel" : "mousewheel", this.target = e, this.onWheelCallback = t, this.onWheelGuard = n, this.onWheel = this.onWheel.bind(this), this.didWheel = this.didWheel.bind(this);
  }
  enable() {
    this.target.addEventListener(this.eventName, this.onWheel, {
      passive: !1
    });
  }
  disable() {
    this.target.removeEventListener(this.eventName, this.onWheel);
  }
  onWheel(e) {
    if (this.onWheelGuard != null && !this.onWheelGuard(e))
      return;
    this.deltaX += e.deltaX, this.deltaY += e.deltaY, e.preventDefault();
    let t;
    (this.deltaX !== 0 || this.deltaY !== 0) && (e.stopPropagation(), t = !0), t === !0 && this.animationFrameId === 0 && (this.animationFrameId = requestAnimationFrame(() => {
      this.didWheel(e);
    }));
  }
  didWheel(e) {
    this.animationFrameId = 0, this.onWheelCallback(e, this.deltaX, this.deltaY), this.deltaX = 0, this.deltaY = 0;
  }
}
function Mf(s, e = 60) {
  let t = null;
  return (...n) => {
    t && clearTimeout(t), t = window.setTimeout(() => {
      s.apply(this, n);
    }, e);
  };
}
function Nb(s) {
  let e = null, t = [];
  const n = () => {
    if (getComputedStyle(s).position === "static") {
      const c = s.style;
      c.position = "relative";
    }
    const l = document.createElement("object");
    return l.onload = () => {
      l.contentDocument.defaultView.addEventListener("resize", i), i();
    }, l.style.display = "block", l.style.position = "absolute", l.style.top = "0", l.style.left = "0", l.style.height = "100%", l.style.width = "100%", l.style.overflow = "hidden", l.style.pointerEvents = "none", l.style.zIndex = "-1", l.style.opacity = "0", l.setAttribute("tabindex", "-1"), l.type = "text/html", s.appendChild(l), l.data = "about:blank", l;
  }, i = Mf(() => {
    t.forEach((l) => l(s));
  }), r = (l) => {
    e || (e = n()), t.indexOf(l) === -1 && t.push(l);
  }, o = () => {
    e && e.parentNode && (e.contentDocument && e.contentDocument.defaultView.removeEventListener("resize", i), e.parentNode.removeChild(e), e = null, t = []);
  };
  return {
    element: s,
    bind: r,
    destroy: o,
    unbind: (l) => {
      const c = t.indexOf(l);
      c !== -1 && t.splice(c, 1), t.length === 0 && e && o();
    }
  };
}
function Ib(s) {
  let e = null, t = [];
  const n = Mf(() => {
    t.forEach((l) => {
      l(s);
    });
  }), i = () => {
    const l = new ResizeObserver(n);
    return l.observe(s), n(), l;
  }, r = (l) => {
    e || (e = i()), t.indexOf(l) === -1 && t.push(l);
  }, o = () => {
    e && (e.disconnect(), t = [], e = null);
  };
  return {
    element: s,
    bind: r,
    destroy: o,
    unbind: (l) => {
      const c = t.indexOf(l);
      c !== -1 && t.splice(c, 1), t.length === 0 && e && o();
    }
  };
}
const jb = typeof ResizeObserver < "u" ? Ib : Nb;
var uo;
(function(s) {
  const e = /* @__PURE__ */ new WeakMap();
  function t(i) {
    let r = e.get(i);
    return r || (r = jb(i), e.set(i, r), r);
  }
  function n(i) {
    i.destroy(), e.delete(i.element);
  }
  s.bind = (i, r) => {
    const o = t(i);
    return o.bind(r), () => o.unbind(r);
  }, s.clear = (i) => {
    const r = t(i);
    n(r);
  };
})(uo || (uo = {}));
class Qi {
  constructor(e = {}) {
    this.comparator = e.comparator || Qi.defaultComparator, this.index = {}, this.data = e.data || [], this.heapify();
  }
  /**
   * Returns `true` if the priority queue is empty, `false` otherwise.
   */
  isEmpty() {
    return this.data.length === 0;
  }
  /**
   * Inserts a value with priority to the queue. Optionally pass a unique
   * id of this item. Passing unique IDs for each item you insert allows
   * you to use the `updatePriority()` operation.
   * @param priority
   * @param value
   * @param id
   */
  insert(e, t, n) {
    const i = { priority: e, value: t }, r = this.data.length;
    return n && (i.id = n, this.index[n] = r), this.data.push(i), this.bubbleUp(r), this;
  }
  /**
   * Returns the value of an item with the highest priority.
   */
  peek() {
    return this.data[0] ? this.data[0].value : null;
  }
  /**
   * Returns the highest priority in the queue.
   */
  peekPriority() {
    return this.data[0] ? this.data[0].priority : null;
  }
  updatePriority(e, t) {
    const n = this.index[e];
    if (typeof n > "u")
      throw new Error("Node with id '".concat(e, "' was not found in the heap."));
    const i = this.data, r = i[n].priority, o = this.comparator(t, r);
    o < 0 ? (i[n].priority = t, this.bubbleUp(n)) : o > 0 && (i[n].priority = t, this.bubbleDown(n));
  }
  /**
   * Removes the item with the highest priority from the queue
   *
   * @returns The value of the removed item.
   */
  remove() {
    const e = this.data, t = e[0], n = e.pop();
    return t.id && delete this.index[t.id], e.length > 0 && (e[0] = n, n.id && (this.index[n.id] = 0), this.bubbleDown(0)), t ? t.value : null;
  }
  heapify() {
    for (let e = 0; e < this.data.length; e += 1)
      this.bubbleUp(e);
  }
  bubbleUp(e) {
    const t = this.data;
    let n, i, r = e;
    for (; r > 0 && (i = r - 1 >>> 1, this.comparator(t[r].priority, t[i].priority) < 0); ) {
      n = t[i], t[i] = t[r];
      let o = t[r].id;
      o != null && (this.index[o] = i), t[r] = n, o = t[r].id, o != null && (this.index[o] = r), r = i;
    }
  }
  bubbleDown(e) {
    const t = this.data, n = t.length - 1;
    let i = e;
    for (; ; ) {
      const r = (i << 1) + 1, o = r + 1;
      let a = i;
      if (r <= n && this.comparator(t[r].priority, t[a].priority) < 0 && (a = r), o <= n && this.comparator(t[o].priority, t[a].priority) < 0 && (a = o), a !== i) {
        const l = t[a];
        t[a] = t[i];
        let c = t[i].id;
        c != null && (this.index[c] = a), t[i] = l, c = t[i].id, c != null && (this.index[c] = i), i = a;
      } else
        break;
    }
  }
}
(function(s) {
  s.defaultComparator = (e, t) => e - t;
})(Qi || (Qi = {}));
var nl;
(function(s) {
  function e(t, n, i = (r, o) => 1) {
    const r = {}, o = {}, a = {}, l = new Qi();
    for (r[n] = 0, Object.keys(t).forEach((c) => {
      c !== n && (r[c] = 1 / 0), l.insert(r[c], c, c);
    }); !l.isEmpty(); ) {
      const c = l.remove();
      a[c] = !0;
      const u = t[c] || [];
      for (let f = 0; f < u.length; f += 1) {
        const d = u[f];
        if (!a[d]) {
          const g = r[c] + i(c, d);
          g < r[d] && (r[d] = g, o[d] = c, l.updatePriority(d, g));
        }
      }
    }
    return o;
  }
  s.run = e;
})(nl || (nl = {}));
class tn {
  constructor(e, t, n, i) {
    if (e == null)
      return this.set(255, 255, 255, 1);
    if (typeof e == "number")
      return this.set(e, t, n, i);
    if (typeof e == "string")
      return tn.fromString(e) || this;
    if (Array.isArray(e))
      return this.set(e);
    this.set(e.r, e.g, e.b, e.a == null ? 1 : e.a);
  }
  blend(e, t, n) {
    this.set(e.r + (t.r - e.r) * n, e.g + (t.g - e.g) * n, e.b + (t.b - e.b) * n, e.a + (t.a - e.a) * n);
  }
  lighten(e) {
    const t = tn.lighten(this.toArray(), e);
    this.r = t[0], this.g = t[1], this.b = t[2], this.a = t[3];
  }
  darken(e) {
    this.lighten(-e);
  }
  set(e, t, n, i) {
    const r = Array.isArray(e) ? e[0] : e, o = Array.isArray(e) ? e[1] : t, a = Array.isArray(e) ? e[2] : n, l = Array.isArray(e) ? e[3] : i;
    return this.r = Math.round(Ct(r, 0, 255)), this.g = Math.round(Ct(o, 0, 255)), this.b = Math.round(Ct(a, 0, 255)), this.a = l == null ? 1 : Ct(l, 0, 1), this;
  }
  toHex() {
    const e = ["r", "g", "b"].map((t) => {
      const n = this[t].toString(16);
      return n.length < 2 ? "0".concat(n) : n;
    });
    return "#".concat(e.join(""));
  }
  toRGBA() {
    return this.toArray();
  }
  toHSLA() {
    return tn.rgba2hsla(this.r, this.g, this.b, this.a);
  }
  toCSS(e) {
    const t = "".concat(this.r, ",").concat(this.g, ",").concat(this.b, ",");
    return e ? "rgb(".concat(t, ")") : "rgba(".concat(t, ",").concat(this.a, ")");
  }
  toGrey() {
    return tn.makeGrey(Math.round((this.r + this.g + this.b) / 3), this.a);
  }
  toArray() {
    return [this.r, this.g, this.b, this.a];
  }
  toString() {
    return this.toCSS();
  }
}
(function(s) {
  function e(b) {
    return new s(b);
  }
  s.fromArray = e;
  function t(b) {
    return new s([...p(b), 1]);
  }
  s.fromHex = t;
  function n(b) {
    const x = b.toLowerCase().match(/^rgba?\(([\s.,0-9]+)\)/);
    if (x) {
      const C = x[1].split(/\s*,\s*/).map((A) => parseInt(A, 10));
      return new s(C);
    }
    return null;
  }
  s.fromRGBA = n;
  function i(b, x, C) {
    C < 0 && ++C, C > 1 && --C;
    const A = 6 * C;
    return A < 1 ? b + (x - b) * A : 2 * C < 1 ? x : 3 * C < 2 ? b + (x - b) * (2 / 3 - C) * 6 : b;
  }
  function r(b) {
    const x = b.toLowerCase().match(/^hsla?\(([\s.,0-9]+)\)/);
    if (x) {
      const C = x[2].split(/\s*,\s*/), A = (parseFloat(C[0]) % 360 + 360) % 360 / 360, P = parseFloat(C[1]) / 100, O = parseFloat(C[2]) / 100, k = C[3] == null ? 1 : parseInt(C[3], 10);
      return new s(c(A, P, O, k));
    }
    return null;
  }
  s.fromHSLA = r;
  function o(b) {
    if (b.startsWith("#"))
      return t(b);
    if (b.startsWith("rgb"))
      return n(b);
    const x = s.named[b];
    return x ? t(x) : r(b);
  }
  s.fromString = o;
  function a(b, x) {
    return s.fromArray([b, b, b, x]);
  }
  s.makeGrey = a;
  function l(b, x, C, A) {
    const P = Array.isArray(b) ? b[0] : b, O = Array.isArray(b) ? b[1] : x, k = Array.isArray(b) ? b[2] : C, D = Array.isArray(b) ? b[3] : A, L = Math.max(P, O, k), B = Math.min(P, O, k), ee = (L + B) / 2;
    let q = 0, _ = 0;
    if (B !== L) {
      const I = L - B;
      switch (_ = ee > 0.5 ? I / (2 - L - B) : I / (L + B), L) {
        case P:
          q = (O - k) / I + (O < k ? 6 : 0);
          break;
        case O:
          q = (k - P) / I + 2;
          break;
        case k:
          q = (P - O) / I + 4;
          break;
      }
      q /= 6;
    }
    return [q, _, ee, D == null ? 1 : D];
  }
  s.rgba2hsla = l;
  function c(b, x, C, A) {
    const P = Array.isArray(b) ? b[0] : b, O = Array.isArray(b) ? b[1] : x, k = Array.isArray(b) ? b[2] : C, D = Array.isArray(b) ? b[3] : A, L = k <= 0.5 ? k * (O + 1) : k + O - k * O, B = 2 * k - L;
    return [
      i(B, L, P + 1 / 3) * 256,
      i(B, L, P) * 256,
      i(B, L, P - 1 / 3) * 256,
      D == null ? 1 : D
    ];
  }
  s.hsla2rgba = c;
  function u(b) {
    return new s(Math.round(Math.random() * 256), Math.round(Math.random() * 256), Math.round(Math.random() * 256), b ? void 0 : parseFloat(Math.random().toFixed(2)));
  }
  s.random = u;
  function f() {
    const b = "0123456789ABCDEF";
    let x = "#";
    for (let C = 0; C < 6; C += 1)
      x += b[Math.floor(Math.random() * 16)];
    return x;
  }
  s.randomHex = f;
  function d(b) {
    return u(b).toString();
  }
  s.randomRGBA = d;
  function g(b, x) {
    if (typeof b == "string") {
      const k = b[0] === "#", [D, L, B] = p(b);
      return x ? D * 0.299 + L * 0.587 + B * 0.114 > 186 ? "#000000" : "#ffffff" : "".concat(k ? "#" : "").concat(m(255 - D, 255 - L, 255 - B));
    }
    const C = b[0], A = b[1], P = b[2], O = b[3];
    return x ? C * 0.299 + A * 0.587 + P * 0.114 > 186 ? [0, 0, 0, O] : [255, 255, 255, O] : [255 - C, 255 - A, 255 - P, O];
  }
  s.invert = g;
  function p(b) {
    const x = b.indexOf("#") === 0 ? b : "#".concat(b);
    let C = Number("0x".concat(x.substr(1)));
    if (!(x.length === 4 || x.length === 7) || Number.isNaN(C))
      throw new Error("Invalid hex color.");
    const A = x.length === 4 ? 4 : 8, P = (1 << A) - 1, O = ["b", "g", "r"].map(() => {
      const k = C & P;
      return C >>= A, A === 4 ? 17 * k : k;
    });
    return [O[2], O[1], O[0]];
  }
  function m(b, x, C) {
    const A = (P) => P.length < 2 ? "0".concat(P) : P;
    return "".concat(A(b.toString(16))).concat(A(x.toString(16))).concat(A(C.toString(16)));
  }
  function w(b, x) {
    return y(b, x);
  }
  s.lighten = w;
  function v(b, x) {
    return y(b, -x);
  }
  s.darken = v;
  function y(b, x) {
    if (typeof b == "string") {
      const P = b[0] === "#", O = parseInt(P ? b.substr(1) : b, 16), k = Ct((O >> 16) + x, 0, 255), D = Ct((O >> 8 & 255) + x, 0, 255), L = Ct((O & 255) + x, 0, 255);
      return "".concat(P ? "#" : "").concat((L | D << 8 | k << 16).toString(16));
    }
    const C = m(b[0], b[1], b[2]), A = p(y(C, x));
    return [A[0], A[1], A[2], b[3]];
  }
})(tn || (tn = {}));
(function(s) {
  s.named = {
    aliceblue: "#f0f8ff",
    antiquewhite: "#faebd7",
    aqua: "#00ffff",
    aquamarine: "#7fffd4",
    azure: "#f0ffff",
    beige: "#f5f5dc",
    bisque: "#ffe4c4",
    black: "#000000",
    blanchedalmond: "#ffebcd",
    blue: "#0000ff",
    blueviolet: "#8a2be2",
    brown: "#a52a2a",
    burlywood: "#deb887",
    burntsienna: "#ea7e5d",
    cadetblue: "#5f9ea0",
    chartreuse: "#7fff00",
    chocolate: "#d2691e",
    coral: "#ff7f50",
    cornflowerblue: "#6495ed",
    cornsilk: "#fff8dc",
    crimson: "#dc143c",
    cyan: "#00ffff",
    darkblue: "#00008b",
    darkcyan: "#008b8b",
    darkgoldenrod: "#b8860b",
    darkgray: "#a9a9a9",
    darkgreen: "#006400",
    darkgrey: "#a9a9a9",
    darkkhaki: "#bdb76b",
    darkmagenta: "#8b008b",
    darkolivegreen: "#556b2f",
    darkorange: "#ff8c00",
    darkorchid: "#9932cc",
    darkred: "#8b0000",
    darksalmon: "#e9967a",
    darkseagreen: "#8fbc8f",
    darkslateblue: "#483d8b",
    darkslategray: "#2f4f4f",
    darkslategrey: "#2f4f4f",
    darkturquoise: "#00ced1",
    darkviolet: "#9400d3",
    deeppink: "#ff1493",
    deepskyblue: "#00bfff",
    dimgray: "#696969",
    dimgrey: "#696969",
    dodgerblue: "#1e90ff",
    firebrick: "#b22222",
    floralwhite: "#fffaf0",
    forestgreen: "#228b22",
    fuchsia: "#ff00ff",
    gainsboro: "#dcdcdc",
    ghostwhite: "#f8f8ff",
    gold: "#ffd700",
    goldenrod: "#daa520",
    gray: "#808080",
    green: "#008000",
    greenyellow: "#adff2f",
    grey: "#808080",
    honeydew: "#f0fff0",
    hotpink: "#ff69b4",
    indianred: "#cd5c5c",
    indigo: "#4b0082",
    ivory: "#fffff0",
    khaki: "#f0e68c",
    lavender: "#e6e6fa",
    lavenderblush: "#fff0f5",
    lawngreen: "#7cfc00",
    lemonchiffon: "#fffacd",
    lightblue: "#add8e6",
    lightcoral: "#f08080",
    lightcyan: "#e0ffff",
    lightgoldenrodyellow: "#fafad2",
    lightgray: "#d3d3d3",
    lightgreen: "#90ee90",
    lightgrey: "#d3d3d3",
    lightpink: "#ffb6c1",
    lightsalmon: "#ffa07a",
    lightseagreen: "#20b2aa",
    lightskyblue: "#87cefa",
    lightslategray: "#778899",
    lightslategrey: "#778899",
    lightsteelblue: "#b0c4de",
    lightyellow: "#ffffe0",
    lime: "#00ff00",
    limegreen: "#32cd32",
    linen: "#faf0e6",
    magenta: "#ff00ff",
    maroon: "#800000",
    mediumaquamarine: "#66cdaa",
    mediumblue: "#0000cd",
    mediumorchid: "#ba55d3",
    mediumpurple: "#9370db",
    mediumseagreen: "#3cb371",
    mediumslateblue: "#7b68ee",
    mediumspringgreen: "#00fa9a",
    mediumturquoise: "#48d1cc",
    mediumvioletred: "#c71585",
    midnightblue: "#191970",
    mintcream: "#f5fffa",
    mistyrose: "#ffe4e1",
    moccasin: "#ffe4b5",
    navajowhite: "#ffdead",
    navy: "#000080",
    oldlace: "#fdf5e6",
    olive: "#808000",
    olivedrab: "#6b8e23",
    orange: "#ffa500",
    orangered: "#ff4500",
    orchid: "#da70d6",
    palegoldenrod: "#eee8aa",
    palegreen: "#98fb98",
    paleturquoise: "#afeeee",
    palevioletred: "#db7093",
    papayawhip: "#ffefd5",
    peachpuff: "#ffdab9",
    peru: "#cd853f",
    pink: "#ffc0cb",
    plum: "#dda0dd",
    powderblue: "#b0e0e6",
    purple: "#800080",
    rebeccapurple: "#663399",
    red: "#ff0000",
    rosybrown: "#bc8f8f",
    royalblue: "#4169e1",
    saddlebrown: "#8b4513",
    salmon: "#fa8072",
    sandybrown: "#f4a460",
    seagreen: "#2e8b57",
    seashell: "#fff5ee",
    sienna: "#a0522d",
    silver: "#c0c0c0",
    skyblue: "#87ceeb",
    slateblue: "#6a5acd",
    slategray: "#708090",
    slategrey: "#708090",
    snow: "#fffafa",
    springgreen: "#00ff7f",
    steelblue: "#4682b4",
    tan: "#d2b48c",
    teal: "#008080",
    thistle: "#d8bfd8",
    tomato: "#ff6347",
    turquoise: "#40e0d0",
    violet: "#ee82ee",
    wheat: "#f5deb3",
    white: "#ffffff",
    whitesmoke: "#f5f5f5",
    yellow: "#ffff00",
    yellowgreen: "#9acd32"
  };
})(tn || (tn = {}));
class sl {
  constructor() {
    this.clear();
  }
  clear() {
    this.map = /* @__PURE__ */ new WeakMap(), this.arr = [];
  }
  has(e) {
    return this.map.has(e);
  }
  get(e) {
    return this.map.get(e);
  }
  set(e, t) {
    this.map.set(e, t), this.arr.push(e);
  }
  delete(e) {
    const t = this.arr.indexOf(e);
    t >= 0 && this.arr.splice(t, 1);
    const n = this.map.get(e);
    return this.map.delete(e), n;
  }
  each(e) {
    this.arr.forEach((t) => {
      const n = this.map.get(t);
      e(n, t);
    });
  }
  dispose() {
    this.clear();
  }
}
var Gs;
(function(s) {
  function e(i) {
    const r = [], o = [];
    return Array.isArray(i) ? r.push(...i) : i.split("|").forEach((a) => {
      a.indexOf("&") === -1 ? r.push(a) : o.push(...a.split("&"));
    }), { or: r, and: o };
  }
  s.parse = e;
  function t(i, r) {
    if (i != null && r != null) {
      const o = e(i), a = e(r), l = o.or.sort(), c = a.or.sort(), u = o.and.sort(), f = a.and.sort(), d = (g, p) => g.length === p.length && (g.length === 0 || g.every((m, w) => m === p[w]));
      return d(l, c) && d(u, f);
    }
    return i == null && r == null;
  }
  s.equals = t;
  function n(i, r, o) {
    if (r == null || Array.isArray(r) && r.length === 0)
      return o ? i.altKey !== !0 && i.ctrlKey !== !0 && i.metaKey !== !0 && i.shiftKey !== !0 : !0;
    const { or: a, and: l } = e(r), c = (u) => {
      const f = "".concat(u.toLowerCase(), "Key");
      return i[f] === !0;
    };
    return a.some((u) => c(u)) && l.every((u) => c(u));
  }
  s.isMatch = n;
})(Gs || (Gs = {}));
var fs;
(function(s) {
  s.linear = (e) => e, s.quad = (e) => e * e, s.cubic = (e) => e * e * e, s.inout = (e) => {
    if (e <= 0)
      return 0;
    if (e >= 1)
      return 1;
    const t = e * e, n = t * e;
    return 4 * (e < 0.5 ? n : 3 * (e - t) + n - 0.75);
  }, s.exponential = (e) => Math.pow(2, 10 * (e - 1)), s.bounce = (e) => {
    for (let t = 0, n = 1; ; t += n, n /= 2)
      if (e >= (7 - 4 * t) / 11) {
        const i = (11 - 6 * t - 11 * e) / 4;
        return -i * i + n * n;
      }
  };
})(fs || (fs = {}));
(function(s) {
  s.decorators = {
    reverse(e) {
      return (t) => 1 - e(1 - t);
    },
    reflect(e) {
      return (t) => 0.5 * (t < 0.5 ? e(2 * t) : 2 - e(2 - 2 * t));
    },
    clamp(e, t = 0, n = 1) {
      return (i) => {
        const r = e(i);
        return r < t ? t : r > n ? n : r;
      };
    },
    back(e = 1.70158) {
      return (t) => t * t * ((e + 1) * t - e);
    },
    elastic(e = 1.5) {
      return (t) => Math.pow(2, 10 * (t - 1)) * Math.cos(20 * Math.PI * e / 3 * t);
    }
  };
})(fs || (fs = {}));
(function(s) {
  function e(_) {
    return -1 * Math.cos(_ * (Math.PI / 2)) + 1;
  }
  s.easeInSine = e;
  function t(_) {
    return Math.sin(_ * (Math.PI / 2));
  }
  s.easeOutSine = t;
  function n(_) {
    return -0.5 * (Math.cos(Math.PI * _) - 1);
  }
  s.easeInOutSine = n;
  function i(_) {
    return _ * _;
  }
  s.easeInQuad = i;
  function r(_) {
    return _ * (2 - _);
  }
  s.easeOutQuad = r;
  function o(_) {
    return _ < 0.5 ? 2 * _ * _ : -1 + (4 - 2 * _) * _;
  }
  s.easeInOutQuad = o;
  function a(_) {
    return _ * _ * _;
  }
  s.easeInCubic = a;
  function l(_) {
    const I = _ - 1;
    return I * I * I + 1;
  }
  s.easeOutCubic = l;
  function c(_) {
    return _ < 0.5 ? 4 * _ * _ * _ : (_ - 1) * (2 * _ - 2) * (2 * _ - 2) + 1;
  }
  s.easeInOutCubic = c;
  function u(_) {
    return _ * _ * _ * _;
  }
  s.easeInQuart = u;
  function f(_) {
    const I = _ - 1;
    return 1 - I * I * I * I;
  }
  s.easeOutQuart = f;
  function d(_) {
    const I = _ - 1;
    return _ < 0.5 ? 8 * _ * _ * _ * _ : 1 - 8 * I * I * I * I;
  }
  s.easeInOutQuart = d;
  function g(_) {
    return _ * _ * _ * _ * _;
  }
  s.easeInQuint = g;
  function p(_) {
    const I = _ - 1;
    return 1 + I * I * I * I * I;
  }
  s.easeOutQuint = p;
  function m(_) {
    const I = _ - 1;
    return _ < 0.5 ? 16 * _ * _ * _ * _ * _ : 1 + 16 * I * I * I * I * I;
  }
  s.easeInOutQuint = m;
  function w(_) {
    return _ === 0 ? 0 : Math.pow(2, 10 * (_ - 1));
  }
  s.easeInExpo = w;
  function v(_) {
    return _ === 1 ? 1 : -Math.pow(2, -10 * _) + 1;
  }
  s.easeOutExpo = v;
  function y(_) {
    if (_ === 0 || _ === 1)
      return _;
    const I = _ * 2, H = I - 1;
    return I < 1 ? 0.5 * Math.pow(2, 10 * H) : 0.5 * (-Math.pow(2, -10 * H) + 2);
  }
  s.easeInOutExpo = y;
  function b(_) {
    const I = _ / 1;
    return -1 * (Math.sqrt(1 - I * _) - 1);
  }
  s.easeInCirc = b;
  function x(_) {
    const I = _ - 1;
    return Math.sqrt(1 - I * I);
  }
  s.easeOutCirc = x;
  function C(_) {
    const I = _ * 2, H = I - 2;
    return I < 1 ? -0.5 * (Math.sqrt(1 - I * I) - 1) : 0.5 * (Math.sqrt(1 - H * H) + 1);
  }
  s.easeInOutCirc = C;
  function A(_, I = 1.70158) {
    return _ * _ * ((I + 1) * _ - I);
  }
  s.easeInBack = A;
  function P(_, I = 1.70158) {
    const H = _ / 1 - 1;
    return H * H * ((I + 1) * H + I) + 1;
  }
  s.easeOutBack = P;
  function O(_, I = 1.70158) {
    const H = _ * 2, oe = H - 2, ne = I * 1.525;
    return H < 1 ? 0.5 * H * H * ((ne + 1) * H - ne) : 0.5 * (oe * oe * ((ne + 1) * oe + ne) + 2);
  }
  s.easeInOutBack = O;
  function k(_, I = 0.7) {
    if (_ === 0 || _ === 1)
      return _;
    const oe = _ / 1 - 1, ne = 1 - I, ye = ne / (2 * Math.PI) * Math.asin(1);
    return -(Math.pow(2, 10 * oe) * // eslint-disable-line
    Math.sin((oe - ye) * (2 * Math.PI) / ne));
  }
  s.easeInElastic = k;
  function D(_, I = 0.7) {
    const H = 1 - I, oe = _ * 2;
    if (_ === 0 || _ === 1)
      return _;
    const ne = H / (2 * Math.PI) * Math.asin(1);
    return Math.pow(2, -10 * oe) * // eslint-disable-line
    Math.sin((oe - ne) * (2 * Math.PI) / H) + 1;
  }
  s.easeOutElastic = D;
  function L(_, I = 0.65) {
    const H = 1 - I;
    if (_ === 0 || _ === 1)
      return _;
    const oe = _ * 2, ne = oe - 1, ye = H / (2 * Math.PI) * Math.asin(1);
    return oe < 1 ? -0.5 * (Math.pow(2, 10 * ne) * // eslint-disable-line
    Math.sin((ne - ye) * (2 * Math.PI) / H)) : Math.pow(2, -10 * ne) * // eslint-disable-line
    Math.sin((ne - ye) * (2 * Math.PI) / H) * 0.5 + 1;
  }
  s.easeInOutElastic = L;
  function B(_) {
    const I = _ / 1;
    if (I < 1 / 2.75)
      return 7.5625 * I * I;
    if (I < 2 / 2.75) {
      const H = I - 0.5454545454545454;
      return 7.5625 * H * H + 0.75;
    }
    if (I < 2.5 / 2.75) {
      const H = I - 0.8181818181818182;
      return 7.5625 * H * H + 0.9375;
    }
    {
      const H = I - 0.9545454545454546;
      return 7.5625 * H * H + 0.984375;
    }
  }
  s.easeOutBounce = B;
  function ee(_) {
    return 1 - B(1 - _);
  }
  s.easeInBounce = ee;
  function q(_) {
    return _ < 0.5 ? ee(_ * 2) * 0.5 : B(_ * 2 - 1) * 0.5 + 0.5;
  }
  s.easeInOutBounce = q;
})(fs || (fs = {}));
var Kn;
(function(s) {
  s.number = (e, t) => {
    const n = t - e;
    return (i) => e + n * i;
  }, s.object = (e, t) => {
    const n = Object.keys(e);
    return (i) => {
      const r = {};
      for (let o = n.length - 1; o !== -1; o -= 1) {
        const a = n[o];
        r[a] = e[a] + (t[a] - e[a]) * i;
      }
      return r;
    };
  }, s.unit = (e, t) => {
    const n = /(-?[0-9]*.[0-9]*)(px|em|cm|mm|in|pt|pc|%)/, i = n.exec(e), r = n.exec(t), o = r ? r[1] : "", a = i ? +i[1] : 0, l = r ? +r[1] : 0, c = o.indexOf("."), u = c > 0 ? o[1].length - c - 1 : 0, f = l - a, d = i ? i[2] : "";
    return (g) => (a + f * g).toFixed(u) + d;
  }, s.color = (e, t) => {
    const n = parseInt(e.slice(1), 16), i = parseInt(t.slice(1), 16), r = n & 255, o = (i & 255) - r, a = n & 65280, l = (i & 65280) - a, c = n & 16711680, u = (i & 16711680) - c;
    return (f) => {
      const d = r + o * f & 255, g = a + l * f & 65280, p = c + u * f & 16711680;
      return "#".concat((1 << 24 | d | g | p).toString(16).slice(1));
    };
  };
})(Kn || (Kn = {}));
const Ni = [];
function Rb(s, e) {
  const t = Ni.find((n) => n.name === s);
  if (!(t && (t.loadTimes += 1, t.loadTimes > 1)) && !On.isApplyingHMR()) {
    const n = document.createElement("style");
    n.setAttribute("type", "text/css"), n.textContent = e;
    const i = document.querySelector("head");
    i && i.insertBefore(n, i.firstChild), Ni.push({
      name: s,
      loadTimes: 1,
      styleElement: n
    });
  }
}
function Bb(s) {
  const e = Ni.findIndex((t) => t.name === s);
  if (e > -1) {
    const t = Ni[e];
    if (t.loadTimes -= 1, t.loadTimes > 0)
      return;
    let n = t.styleElement;
    n && n.parentNode && n.parentNode.removeChild(n), n = null, Ni.splice(e, 1);
  }
}
var ce;
(function(s) {
  function e(n) {
    return 180 * n / Math.PI % 360;
  }
  s.toDeg = e, s.toRad = function(n, i = !1) {
    return (i ? n : n % 360) * Math.PI / 180;
  };
  function t(n) {
    return n % 360 + (n < 0 ? 360 : 0);
  }
  s.normalize = t;
})(ce || (ce = {}));
var le;
(function(s) {
  function e(a, l = 0) {
    return Number.isInteger(a) ? a : +a.toFixed(l);
  }
  s.round = e;
  function t(a, l) {
    let c, u;
    if (l == null ? (u = a == null ? 1 : a, c = 0) : (u = l, c = a == null ? 0 : a), u < c) {
      const f = c;
      c = u, u = f;
    }
    return Math.floor(Math.random() * (u - c + 1) + c);
  }
  s.random = t;
  function n(a, l, c) {
    return Number.isNaN(a) ? NaN : Number.isNaN(l) || Number.isNaN(c) ? 0 : l < c ? a < l ? l : a > c ? c : a : a < c ? c : a > l ? l : a;
  }
  s.clamp = n;
  function i(a, l) {
    return l * Math.round(a / l);
  }
  s.snapToGrid = i;
  function r(a, l) {
    return l != null && a != null && l.x >= a.x && l.x <= a.x + a.width && l.y >= a.y && l.y <= a.y + a.height;
  }
  s.containsPoint = r;
  function o(a, l) {
    const c = a.x - l.x, u = a.y - l.y;
    return c * c + u * u;
  }
  s.squaredLength = o;
})(le || (le = {}));
class $n {
  valueOf() {
    return this.toJSON();
  }
  toString() {
    return JSON.stringify(this.toJSON());
  }
}
class S extends $n {
  constructor(e, t) {
    super(), this.x = e == null ? 0 : e, this.y = t == null ? 0 : t;
  }
  /**
   * Rounds the point to the given precision.
   */
  round(e = 0) {
    return this.x = le.round(this.x, e), this.y = le.round(this.y, e), this;
  }
  add(e, t) {
    const n = S.create(e, t);
    return this.x += n.x, this.y += n.y, this;
  }
  update(e, t) {
    const n = S.create(e, t);
    return this.x = n.x, this.y = n.y, this;
  }
  translate(e, t) {
    const n = S.create(e, t);
    return this.x += n.x, this.y += n.y, this;
  }
  /**
   * Rotate the point by `degree` around `center`.
   */
  rotate(e, t) {
    const n = S.rotate(this, e, t);
    return this.x = n.x, this.y = n.y, this;
  }
  /**
   * Scale point by `sx` and `sy` around the given `origin`. If origin is
   * not specified, the point is scaled around `0, 0`.
   */
  scale(e, t, n = new S()) {
    const i = S.create(n);
    return this.x = i.x + e * (this.x - i.x), this.y = i.y + t * (this.y - i.y), this;
  }
  /**
   * Chooses the point closest to this point from among `points`. If `points`
   * is an empty array, `null` is returned.
   */
  closest(e) {
    if (e.length === 1)
      return S.create(e[0]);
    let t = null, n = 1 / 0;
    return e.forEach((i) => {
      const r = this.squaredDistance(i);
      r < n && (t = i, n = r);
    }), t ? S.create(t) : null;
  }
  /**
   * Returns the distance between the point and another point `p`.
   */
  distance(e) {
    return Math.sqrt(this.squaredDistance(e));
  }
  /**
   * Returns the squared distance between the point and another point `p`.
   *
   * Useful for distance comparisons in which real distance is not necessary
   * (saves one `Math.sqrt()` operation).
   */
  squaredDistance(e) {
    const t = S.create(e), n = this.x - t.x, i = this.y - t.y;
    return n * n + i * i;
  }
  manhattanDistance(e) {
    const t = S.create(e);
    return Math.abs(t.x - this.x) + Math.abs(t.y - this.y);
  }
  /**
   * Returns the magnitude of the point vector.
   *
   * @see http://en.wikipedia.org/wiki/Magnitude_(mathematics)
   */
  magnitude() {
    return Math.sqrt(this.x * this.x + this.y * this.y) || 0.01;
  }
  /**
   * Returns the angle(in degrees) between vector from this point to `p` and
   * the x-axis.
   */
  theta(e = new S()) {
    const t = S.create(e), n = -(t.y - this.y), i = t.x - this.x;
    let r = Math.atan2(n, i);
    return r < 0 && (r = 2 * Math.PI + r), 180 * r / Math.PI;
  }
  /**
   * Returns the angle(in degrees) between vector from this point to `p1` and
   * the vector from this point to `p2`.
   *
   * The ordering of points `p1` and `p2` is important.
   *
   * The function returns a value between `0` and `180` when the angle (in the
   * direction from `p1` to `p2`) is clockwise, and a value between `180` and
   * `360` when the angle is counterclockwise.
   *
   * Returns `NaN` if either of the points `p1` and `p2` is equal with this point.
   */
  angleBetween(e, t) {
    if (this.equals(e) || this.equals(t))
      return NaN;
    let n = this.theta(t) - this.theta(e);
    return n < 0 && (n += 360), n;
  }
  /**
   * Returns the angle(in degrees) between the line from `(0,0)` and this point
   * and the line from `(0,0)` to `p`.
   *
   * The function returns a value between `0` and `180` when the angle (in the
   * direction from this point to `p`) is clockwise, and a value between `180`
   * and `360` when the angle is counterclockwise. Returns `NaN` if called from
   * point `(0,0)` or if `p` is `(0,0)`.
   */
  vectorAngle(e) {
    return new S(0, 0).angleBetween(this, e);
  }
  /**
   * Converts rectangular to polar coordinates.
   */
  toPolar(e) {
    return this.update(S.toPolar(this, e)), this;
  }
  /**
   * Returns the change in angle(in degrees) that is the result of moving the
   * point from its previous position to its current position.
   *
   * More specifically, this function computes the angle between the line from
   * the ref point to the previous position of this point(i.e. current position
   * `-dx`, `-dy`) and the line from the `ref` point to the current position of
   * this point.
   *
   * The function returns a positive value between `0` and `180` when the angle
   * (in the direction from previous position of this point to its current
   * position) is clockwise, and a negative value between `0` and `-180` when
   * the angle is counterclockwise.
   *
   * The function returns `0` if the previous and current positions of this
   * point are the same (i.e. both `dx` and `dy` are `0`).
   */
  changeInAngle(e, t, n = new S()) {
    return this.clone().translate(-e, -t).theta(n) - this.theta(n);
  }
  /**
   * If the point lies outside the rectangle `rect`, adjust the point so that
   * it becomes the nearest point on the boundary of `rect`.
   */
  adhereToRect(e) {
    return le.containsPoint(e, this) || (this.x = Math.min(Math.max(this.x, e.x), e.x + e.width), this.y = Math.min(Math.max(this.y, e.y), e.y + e.height)), this;
  }
  /**
   * Returns the bearing(cardinal direction) between me and the given point.
   *
   * @see https://en.wikipedia.org/wiki/Cardinal_direction
   */
  bearing(e) {
    const t = S.create(e), n = ce.toRad(this.y), i = ce.toRad(t.y), r = this.x, o = t.x, a = ce.toRad(o - r), l = Math.sin(a) * Math.cos(i), c = Math.cos(n) * Math.sin(i) - Math.sin(n) * Math.cos(i) * Math.cos(a), u = ce.toDeg(Math.atan2(l, c)), f = ["NE", "E", "SE", "S", "SW", "W", "NW", "N"];
    let d = u - 22.5;
    return d < 0 && (d += 360), d = parseInt(d / 45, 10), f[d];
  }
  /**
   * Returns the cross product of the vector from me to `p1` and the vector
   * from me to `p2`.
   *
   * The left-hand rule is used because the coordinate system is left-handed.
   */
  cross(e, t) {
    if (e != null && t != null) {
      const n = S.create(e), i = S.create(t);
      return (i.x - this.x) * (n.y - this.y) - (i.y - this.y) * (n.x - this.x);
    }
    return NaN;
  }
  /**
   * Returns the dot product of this point with given other point.
   */
  dot(e) {
    const t = S.create(e);
    return this.x * t.x + this.y * t.y;
  }
  diff(e, t) {
    if (typeof e == "number")
      return new S(this.x - e, this.y - t);
    const n = S.create(e);
    return new S(this.x - n.x, this.y - n.y);
  }
  /**
   * Returns an interpolation between me and point `p` for a parametert in
   * the closed interval `[0, 1]`.
   */
  lerp(e, t) {
    const n = S.create(e);
    return new S((1 - t) * this.x + t * n.x, (1 - t) * this.y + t * n.y);
  }
  /**
   * Normalize the point vector, scale the line segment between `(0, 0)`
   * and the point in order for it to have the given length. If length is
   * not specified, it is considered to be `1`; in that case, a unit vector
   * is computed.
   */
  normalize(e = 1) {
    const t = e / this.magnitude();
    return this.scale(t, t);
  }
  /**
   * Moves this point along the line starting from `ref` to this point by a
   * certain `distance`.
   */
  move(e, t) {
    const n = S.create(e), i = ce.toRad(n.theta(this));
    return this.translate(Math.cos(i) * t, -Math.sin(i) * t);
  }
  /**
   * Returns a point that is the reflection of me with the center of inversion
   * in `ref` point.
   */
  reflection(e) {
    return S.create(e).move(this, this.distance(e));
  }
  snapToGrid(e, t) {
    return this.x = le.snapToGrid(this.x, e), this.y = le.snapToGrid(this.y, t == null ? e : t), this;
  }
  equals(e) {
    const t = S.create(e);
    return t != null && t.x === this.x && t.y === this.y;
  }
  clone() {
    return S.clone(this);
  }
  /**
   * Returns the point as a simple JSON object. For example: `{ x: 0, y: 0 }`.
   */
  toJSON() {
    return S.toJSON(this);
  }
  serialize() {
    return "".concat(this.x, " ").concat(this.y);
  }
}
(function(s) {
  function e(t) {
    return t != null && t instanceof s;
  }
  s.isPoint = e;
})(S || (S = {}));
(function(s) {
  function e(n) {
    return n != null && typeof n == "object" && typeof n.x == "number" && typeof n.y == "number";
  }
  s.isPointLike = e;
  function t(n) {
    return n != null && Array.isArray(n) && n.length === 2 && typeof n[0] == "number" && typeof n[1] == "number";
  }
  s.isPointData = t;
})(S || (S = {}));
(function(s) {
  function e(f, d) {
    return f == null || typeof f == "number" ? new s(f, d) : t(f);
  }
  s.create = e;
  function t(f) {
    return s.isPoint(f) ? new s(f.x, f.y) : Array.isArray(f) ? new s(f[0], f[1]) : new s(f.x, f.y);
  }
  s.clone = t;
  function n(f) {
    return s.isPoint(f) ? { x: f.x, y: f.y } : Array.isArray(f) ? { x: f[0], y: f[1] } : { x: f.x, y: f.y };
  }
  s.toJSON = n;
  function i(f, d, g = new s()) {
    let p = Math.abs(f * Math.cos(d)), m = Math.abs(f * Math.sin(d));
    const w = t(g), v = ce.normalize(ce.toDeg(d));
    return v < 90 ? m = -m : v < 180 ? (p = -p, m = -m) : v < 270 && (p = -p), new s(w.x + p, w.y + m);
  }
  s.fromPolar = i;
  function r(f, d = new s()) {
    const g = t(f), p = t(d), m = g.x - p.x, w = g.y - p.y;
    return new s(
      Math.sqrt(m * m + w * w),
      // r
      ce.toRad(p.theta(g))
    );
  }
  s.toPolar = r;
  function o(f, d) {
    return f === d ? !0 : f != null && d != null ? f.x === d.x && f.y === d.y : !1;
  }
  s.equals = o;
  function a(f, d) {
    if (f == null && d != null || f != null && d == null || f != null && d != null && f.length !== d.length)
      return !1;
    if (f != null && d != null) {
      for (let g = 0, p = f.length; g < p; g += 1)
        if (!o(f[g], d[g]))
          return !1;
    }
    return !0;
  }
  s.equalPoints = a;
  function l(f, d, g, p) {
    return new s(le.random(f, d), le.random(g, p));
  }
  s.random = l;
  function c(f, d, g) {
    const p = ce.toRad(ce.normalize(-d)), m = Math.sin(p), w = Math.cos(p);
    return u(f, w, m, g);
  }
  s.rotate = c;
  function u(f, d, g, p = new s()) {
    const m = t(f), w = t(p), v = m.x - w.x, y = m.y - w.y, b = v * d - y * g, x = y * d + v * g;
    return new s(b + w.x, x + w.y);
  }
  s.rotateEx = u;
})(S || (S = {}));
class R extends $n {
  get left() {
    return this.x;
  }
  get top() {
    return this.y;
  }
  get right() {
    return this.x + this.width;
  }
  get bottom() {
    return this.y + this.height;
  }
  get origin() {
    return new S(this.x, this.y);
  }
  get topLeft() {
    return new S(this.x, this.y);
  }
  get topCenter() {
    return new S(this.x + this.width / 2, this.y);
  }
  get topRight() {
    return new S(this.x + this.width, this.y);
  }
  get center() {
    return new S(this.x + this.width / 2, this.y + this.height / 2);
  }
  get bottomLeft() {
    return new S(this.x, this.y + this.height);
  }
  get bottomCenter() {
    return new S(this.x + this.width / 2, this.y + this.height);
  }
  get bottomRight() {
    return new S(this.x + this.width, this.y + this.height);
  }
  get corner() {
    return new S(this.x + this.width, this.y + this.height);
  }
  get rightMiddle() {
    return new S(this.x + this.width, this.y + this.height / 2);
  }
  get leftMiddle() {
    return new S(this.x, this.y + this.height / 2);
  }
  get topLine() {
    return new $(this.topLeft, this.topRight);
  }
  get rightLine() {
    return new $(this.topRight, this.bottomRight);
  }
  get bottomLine() {
    return new $(this.bottomLeft, this.bottomRight);
  }
  get leftLine() {
    return new $(this.topLeft, this.bottomLeft);
  }
  constructor(e, t, n, i) {
    super(), this.x = e == null ? 0 : e, this.y = t == null ? 0 : t, this.width = n == null ? 0 : n, this.height = i == null ? 0 : i;
  }
  getOrigin() {
    return this.origin;
  }
  getTopLeft() {
    return this.topLeft;
  }
  getTopCenter() {
    return this.topCenter;
  }
  getTopRight() {
    return this.topRight;
  }
  getCenter() {
    return this.center;
  }
  getCenterX() {
    return this.x + this.width / 2;
  }
  getCenterY() {
    return this.y + this.height / 2;
  }
  getBottomLeft() {
    return this.bottomLeft;
  }
  getBottomCenter() {
    return this.bottomCenter;
  }
  getBottomRight() {
    return this.bottomRight;
  }
  getCorner() {
    return this.corner;
  }
  getRightMiddle() {
    return this.rightMiddle;
  }
  getLeftMiddle() {
    return this.leftMiddle;
  }
  getTopLine() {
    return this.topLine;
  }
  getRightLine() {
    return this.rightLine;
  }
  getBottomLine() {
    return this.bottomLine;
  }
  getLeftLine() {
    return this.leftLine;
  }
  /**
   * Returns a rectangle that is the bounding box of the rectangle.
   *
   * If `angle` is specified, the bounding box calculation will take into
   * account the rotation of the rectangle by angle degrees around its center.
   */
  bbox(e) {
    if (!e)
      return this.clone();
    const t = ce.toRad(e), n = Math.abs(Math.sin(t)), i = Math.abs(Math.cos(t)), r = this.width * i + this.height * n, o = this.width * n + this.height * i;
    return new R(this.x + (this.width - r) / 2, this.y + (this.height - o) / 2, r, o);
  }
  round(e = 0) {
    return this.x = le.round(this.x, e), this.y = le.round(this.y, e), this.width = le.round(this.width, e), this.height = le.round(this.height, e), this;
  }
  add(e, t, n, i) {
    const r = R.create(e, t, n, i), o = Math.min(this.x, r.x), a = Math.min(this.y, r.y), l = Math.max(this.x + this.width, r.x + r.width), c = Math.max(this.y + this.height, r.y + r.height);
    return this.x = o, this.y = a, this.width = l - o, this.height = c - a, this;
  }
  update(e, t, n, i) {
    const r = R.create(e, t, n, i);
    return this.x = r.x, this.y = r.y, this.width = r.width, this.height = r.height, this;
  }
  inflate(e, t) {
    const n = e, i = t != null ? t : e;
    return this.x -= n, this.y -= i, this.width += 2 * n, this.height += 2 * i, this;
  }
  snapToGrid(e, t) {
    const n = this.origin.snapToGrid(e, t), i = this.corner.snapToGrid(e, t);
    return this.x = n.x, this.y = n.y, this.width = i.x - n.x, this.height = i.y - n.y, this;
  }
  translate(e, t) {
    const n = S.create(e, t);
    return this.x += n.x, this.y += n.y, this;
  }
  scale(e, t, n = new S()) {
    const i = this.origin.scale(e, t, n);
    return this.x = i.x, this.y = i.y, this.width *= e, this.height *= t, this;
  }
  rotate(e, t = this.getCenter()) {
    if (e !== 0) {
      const n = ce.toRad(e), i = Math.cos(n), r = Math.sin(n);
      let o = this.getOrigin(), a = this.getTopRight(), l = this.getBottomRight(), c = this.getBottomLeft();
      o = S.rotateEx(o, i, r, t), a = S.rotateEx(a, i, r, t), l = S.rotateEx(l, i, r, t), c = S.rotateEx(c, i, r, t);
      const u = new R(o.x, o.y, 0, 0);
      u.add(a.x, a.y, 0, 0), u.add(l.x, l.y, 0, 0), u.add(c.x, c.y, 0, 0), this.update(u);
    }
    return this;
  }
  rotate90() {
    const e = (this.width - this.height) / 2;
    this.x += e, this.y -= e;
    const t = this.width;
    return this.width = this.height, this.height = t, this;
  }
  /**
   * Translates the rectangle by `rect.x` and `rect.y` and expand it by
   * `rect.width` and `rect.height`.
   */
  moveAndExpand(e) {
    const t = R.clone(e);
    return this.x += t.x || 0, this.y += t.y || 0, this.width += t.width || 0, this.height += t.height || 0, this;
  }
  /**
   * Returns an object where `sx` and `sy` give the maximum scaling that can be
   * applied to the rectangle so that it would still fit into `limit`. If
   * `origin` is specified, the rectangle is scaled around it; otherwise, it is
   * scaled around its center.
   */
  getMaxScaleToFit(e, t = this.center) {
    const n = R.clone(e), i = t.x, r = t.y;
    let o = 1 / 0, a = 1 / 0, l = 1 / 0, c = 1 / 0, u = 1 / 0, f = 1 / 0, d = 1 / 0, g = 1 / 0;
    const p = n.topLeft;
    p.x < i && (o = (this.x - i) / (p.x - i)), p.y < r && (u = (this.y - r) / (p.y - r));
    const m = n.bottomRight;
    m.x > i && (a = (this.x + this.width - i) / (m.x - i)), m.y > r && (f = (this.y + this.height - r) / (m.y - r));
    const w = n.topRight;
    w.x > i && (l = (this.x + this.width - i) / (w.x - i)), w.y < r && (d = (this.y - r) / (w.y - r));
    const v = n.bottomLeft;
    return v.x < i && (c = (this.x - i) / (v.x - i)), v.y > r && (g = (this.y + this.height - r) / (v.y - r)), {
      sx: Math.min(o, a, l, c),
      sy: Math.min(u, f, d, g)
    };
  }
  /**
   * Returns a number that specifies the maximum scaling that can be applied to
   * the rectangle along both axes so that it would still fit into `limit`. If
   * `origin` is specified, the rectangle is scaled around it; otherwise, it is
   * scaled around its center.
   */
  getMaxUniformScaleToFit(e, t = this.center) {
    const n = this.getMaxScaleToFit(e, t);
    return Math.min(n.sx, n.sy);
  }
  containsPoint(e, t) {
    return le.containsPoint(this, S.create(e, t));
  }
  containsRect(e, t, n, i) {
    const r = R.create(e, t, n, i), o = this.x, a = this.y, l = this.width, c = this.height, u = r.x, f = r.y, d = r.width, g = r.height;
    return l === 0 || c === 0 || d === 0 || g === 0 ? !1 : u >= o && f >= a && u + d <= o + l && f + g <= a + c;
  }
  /**
   * Returns an array of the intersection points of the rectangle and the line.
   * Return `null` if no intersection exists.
   */
  intersectsWithLine(e) {
    const t = [
      this.topLine,
      this.rightLine,
      this.bottomLine,
      this.leftLine
    ], n = [], i = [];
    return t.forEach((r) => {
      const o = e.intersectsWithLine(r);
      o !== null && i.indexOf(o.toString()) < 0 && (n.push(o), i.push(o.toString()));
    }), n.length > 0 ? n : null;
  }
  /**
   * Returns the point on the boundary of the rectangle that is the intersection
   * of the rectangle with a line starting in the center the rectangle ending in
   * the point `p`.
   *
   * If `angle` is specified, the intersection will take into account the
   * rotation of the rectangle by `angle` degrees around its center.
   */
  intersectsWithLineFromCenterToPoint(e, t) {
    const n = S.clone(e), i = this.center;
    let r = null;
    t != null && t !== 0 && n.rotate(t, i);
    const o = [this.topLine, this.rightLine, this.bottomLine, this.leftLine], a = new $(i, n);
    for (let l = o.length - 1; l >= 0; l -= 1) {
      const c = o[l].intersectsWithLine(a);
      if (c !== null) {
        r = c;
        break;
      }
    }
    return r && t != null && t !== 0 && r.rotate(-t, i), r;
  }
  intersectsWithRect(e, t, n, i) {
    const r = R.create(e, t, n, i);
    if (!this.isIntersectWithRect(r))
      return null;
    const o = this.origin, a = this.corner, l = r.origin, c = r.corner, u = Math.max(o.x, l.x), f = Math.max(o.y, l.y);
    return new R(u, f, Math.min(a.x, c.x) - u, Math.min(a.y, c.y) - f);
  }
  isIntersectWithRect(e, t, n, i) {
    const r = R.create(e, t, n, i), o = this.origin, a = this.corner, l = r.origin, c = r.corner;
    return !(c.x <= o.x || c.y <= o.y || l.x >= a.x || l.y >= a.y);
  }
  /**
   * Normalize the rectangle, i.e. make it so that it has non-negative
   * width and height. If width is less than `0`, the function swaps left and
   * right corners and if height is less than `0`, the top and bottom corners
   * are swapped.
   */
  normalize() {
    let e = this.x, t = this.y, n = this.width, i = this.height;
    return this.width < 0 && (e = this.x + this.width, n = -this.width), this.height < 0 && (t = this.y + this.height, i = -this.height), this.x = e, this.y = t, this.width = n, this.height = i, this;
  }
  /**
   * Returns a rectangle that is a union of this rectangle and rectangle `rect`.
   */
  union(e) {
    const t = R.clone(e), n = this.origin, i = this.corner, r = t.origin, o = t.corner, a = Math.min(n.x, r.x), l = Math.min(n.y, r.y), c = Math.max(i.x, o.x), u = Math.max(i.y, o.y);
    return new R(a, l, c - a, u - l);
  }
  /**
   * Returns a string ("top", "left", "right" or "bottom") denoting the side of
   * the rectangle which is nearest to the point `p`.
   */
  getNearestSideToPoint(e) {
    const t = S.clone(e), n = t.x - this.x, i = this.x + this.width - t.x, r = t.y - this.y, o = this.y + this.height - t.y;
    let a = n, l = "left";
    return i < a && (a = i, l = "right"), r < a && (a = r, l = "top"), o < a && (l = "bottom"), l;
  }
  /**
   * Returns a point on the boundary of the rectangle nearest to the point `p`.
   */
  getNearestPointToPoint(e) {
    const t = S.clone(e);
    if (this.containsPoint(t)) {
      const n = this.getNearestSideToPoint(t);
      if (n === "left")
        return new S(this.x, t.y);
      if (n === "top")
        return new S(t.x, this.y);
      if (n === "right")
        return new S(this.x + this.width, t.y);
      if (n === "bottom")
        return new S(t.x, this.y + this.height);
    }
    return t.adhereToRect(this);
  }
  equals(e) {
    return e != null && e.x === this.x && e.y === this.y && e.width === this.width && e.height === this.height;
  }
  clone() {
    return new R(this.x, this.y, this.width, this.height);
  }
  toJSON() {
    return { x: this.x, y: this.y, width: this.width, height: this.height };
  }
  serialize() {
    return "".concat(this.x, " ").concat(this.y, " ").concat(this.width, " ").concat(this.height);
  }
}
(function(s) {
  function e(t) {
    return t != null && t instanceof s;
  }
  s.isRectangle = e;
})(R || (R = {}));
(function(s) {
  function e(t) {
    return t != null && typeof t == "object" && typeof t.x == "number" && typeof t.y == "number" && typeof t.width == "number" && typeof t.height == "number";
  }
  s.isRectangleLike = e;
})(R || (R = {}));
(function(s) {
  function e(o, a, l, c) {
    return o == null || typeof o == "number" ? new s(o, a, l, c) : t(o);
  }
  s.create = e;
  function t(o) {
    return s.isRectangle(o) ? o.clone() : Array.isArray(o) ? new s(o[0], o[1], o[2], o[3]) : new s(o.x, o.y, o.width, o.height);
  }
  s.clone = t;
  function n(o) {
    return new s(o.x - o.a, o.y - o.b, 2 * o.a, 2 * o.b);
  }
  s.fromEllipse = n;
  function i(o) {
    return new s(0, 0, o.width, o.height);
  }
  s.fromSize = i;
  function r(o, a) {
    return new s(o.x, o.y, a.width, a.height);
  }
  s.fromPositionAndSize = r;
})(R || (R = {}));
class $ extends $n {
  get center() {
    return new S((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);
  }
  constructor(e, t, n, i) {
    super(), typeof e == "number" && typeof t == "number" ? (this.start = new S(e, t), this.end = new S(n, i)) : (this.start = S.create(e), this.end = S.create(t));
  }
  getCenter() {
    return this.center;
  }
  /**
   * Rounds the line to the given `precision`.
   */
  round(e = 0) {
    return this.start.round(e), this.end.round(e), this;
  }
  translate(e, t) {
    return typeof e == "number" ? (this.start.translate(e, t), this.end.translate(e, t)) : (this.start.translate(e), this.end.translate(e)), this;
  }
  /**
   * Rotate the line by `angle` around `origin`.
   */
  rotate(e, t) {
    return this.start.rotate(e, t), this.end.rotate(e, t), this;
  }
  /**
   * Scale the line by `sx` and `sy` about the given `origin`. If origin is not
   * specified, the line is scaled around `0,0`.
   */
  scale(e, t, n) {
    return this.start.scale(e, t, n), this.end.scale(e, t, n), this;
  }
  /**
   * Returns the length of the line.
   */
  length() {
    return Math.sqrt(this.squaredLength());
  }
  /**
   * Useful for distance comparisons in which real length is not necessary
   * (saves one `Math.sqrt()` operation).
   */
  squaredLength() {
    const e = this.start.x - this.end.x, t = this.start.y - this.end.y;
    return e * e + t * t;
  }
  /**
   * Scale the line so that it has the requested length. The start point of
   * the line is preserved.
   */
  setLength(e) {
    const t = this.length();
    if (!t)
      return this;
    const n = e / t;
    return this.scale(n, n, this.start);
  }
  parallel(e) {
    const t = this.clone();
    if (!t.isDifferentiable())
      return t;
    const { start: n, end: i } = t, r = n.clone().rotate(270, i), o = i.clone().rotate(90, n);
    return n.move(o, e), i.move(r, e), t;
  }
  /**
   * Returns the vector of the line with length equal to length of the line.
   */
  vector() {
    return new S(this.end.x - this.start.x, this.end.y - this.start.y);
  }
  /**
   * Returns the angle of incline of the line.
   *
   * The function returns `NaN` if the start and end endpoints of the line
   * both lie at the same coordinates(it is impossible to determine the angle
   * of incline of a line that appears to be a point). The
   * `line.isDifferentiable()` function may be used in advance to determine
   * whether the angle of incline can be computed for a given line.
   */
  angle() {
    const e = new S(this.start.x + 1, this.start.y);
    return this.start.angleBetween(this.end, e);
  }
  /**
   * Returns a rectangle that is the bounding box of the line.
   */
  bbox() {
    const e = Math.min(this.start.x, this.end.x), t = Math.min(this.start.y, this.end.y), n = Math.max(this.start.x, this.end.x), i = Math.max(this.start.y, this.end.y);
    return new R(e, t, n - e, i - t);
  }
  /**
   * Returns the bearing (cardinal direction) of the line.
   *
   * The return value is one of the following strings:
   * 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW' and 'N'.
   *
   * The function returns 'N' if the two endpoints of the line are coincident.
   */
  bearing() {
    return this.start.bearing(this.end);
  }
  /**
   * Returns the point on the line that lies closest to point `p`.
   */
  closestPoint(e) {
    return this.pointAt(this.closestPointNormalizedLength(e));
  }
  /**
   * Returns the length of the line up to the point that lies closest to point `p`.
   */
  closestPointLength(e) {
    return this.closestPointNormalizedLength(e) * this.length();
  }
  /**
   * Returns a line that is tangent to the line at the point that lies closest
   * to point `p`.
   */
  closestPointTangent(e) {
    return this.tangentAt(this.closestPointNormalizedLength(e));
  }
  /**
   * Returns the normalized length (distance from the start of the line / total
   * line length) of the line up to the point that lies closest to point.
   */
  closestPointNormalizedLength(e) {
    const t = this.vector().dot(new $(this.start, e).vector()), n = Math.min(1, Math.max(0, t / this.squaredLength()));
    return Number.isNaN(n) ? 0 : n;
  }
  /**
   * Returns a point on the line that lies `rate` (normalized length) away from
   * the beginning of the line.
   */
  pointAt(e) {
    const t = this.start, n = this.end;
    return e <= 0 ? t.clone() : e >= 1 ? n.clone() : t.lerp(n, e);
  }
  /**
   * Returns a point on the line that lies length away from the beginning of
   * the line.
   */
  pointAtLength(e) {
    const t = this.start, n = this.end;
    let i = !0;
    e < 0 && (i = !1, e = -e);
    const r = this.length();
    if (e >= r)
      return i ? n.clone() : t.clone();
    const o = (i ? e : r - e) / r;
    return this.pointAt(o);
  }
  /**
   * Divides the line into two lines at the point that lies `rate` (normalized
   * length) away from the beginning of the line.
   */
  divideAt(e) {
    const t = this.pointAt(e);
    return [
      new $(this.start, t),
      new $(t, this.end)
    ];
  }
  /**
   * Divides the line into two lines at the point that lies length away from
   * the beginning of the line.
   */
  divideAtLength(e) {
    const t = this.pointAtLength(e);
    return [
      new $(this.start, t),
      new $(t, this.end)
    ];
  }
  /**
   * Returns `true` if the point `p` lies on the line. Return `false` otherwise.
   */
  containsPoint(e) {
    const t = this.start, n = this.end;
    if (t.cross(e, n) !== 0)
      return !1;
    const i = this.length();
    return !(new $(t, e).length() > i || new $(e, n).length() > i);
  }
  intersect(e, t) {
    const n = e.intersectsWithLine(this, t);
    return n ? Array.isArray(n) ? n : [n] : null;
  }
  /**
   * Returns the intersection point of the line with another line. Returns
   * `null` if no intersection exists.
   */
  intersectsWithLine(e) {
    const t = new S(this.end.x - this.start.x, this.end.y - this.start.y), n = new S(e.end.x - e.start.x, e.end.y - e.start.y), i = t.x * n.y - t.y * n.x, r = new S(e.start.x - this.start.x, e.start.y - this.start.y), o = r.x * n.y - r.y * n.x, a = r.x * t.y - r.y * t.x;
    if (i === 0 || o * i < 0 || a * i < 0)
      return null;
    if (i > 0) {
      if (o > i || a > i)
        return null;
    } else if (o < i || a < i)
      return null;
    return new S(this.start.x + o * t.x / i, this.start.y + o * t.y / i);
  }
  /**
   * Returns `true` if a tangent line can be found for the line.
   *
   * Tangents cannot be found if both of the line endpoints are coincident
   * (the line appears to be a point).
   */
  isDifferentiable() {
    return !this.start.equals(this.end);
  }
  /**
   * Returns the perpendicular distance between the line and point. The
   * distance is positive if the point lies to the right of the line, negative
   * if the point lies to the left of the line, and `0` if the point lies on
   * the line.
   */
  pointOffset(e) {
    const t = S.clone(e), n = this.start, i = this.end;
    return ((i.x - n.x) * (t.y - n.y) - (i.y - n.y) * (t.x - n.x)) / this.length();
  }
  pointSquaredDistance(e, t) {
    const n = S.create(e, t);
    return this.closestPoint(n).squaredDistance(n);
  }
  pointDistance(e, t) {
    const n = S.create(e, t);
    return this.closestPoint(n).distance(n);
  }
  /**
   * Returns a line tangent to the line at point that lies `rate` (normalized
   * length) away from the beginning of the line.
   */
  tangentAt(e) {
    if (!this.isDifferentiable())
      return null;
    const t = this.start, n = this.end, i = this.pointAt(e), r = new $(t, n);
    return r.translate(i.x - t.x, i.y - t.y), r;
  }
  /**
   * Returns a line tangent to the line at point that lies `length` away from
   * the beginning of the line.
   */
  tangentAtLength(e) {
    if (!this.isDifferentiable())
      return null;
    const t = this.start, n = this.end, i = this.pointAtLength(e), r = new $(t, n);
    return r.translate(i.x - t.x, i.y - t.y), r;
  }
  relativeCcw(e, t) {
    const n = S.create(e, t);
    let i = n.x - this.start.x, r = n.y - this.start.y;
    const o = this.end.x - this.start.x, a = this.end.y - this.start.y;
    let l = i * a - r * o;
    return l === 0 && (l = i * o + r * a, l > 0 && (i -= o, r -= a, l = i * o + r * a, l < 0 && (l = 0))), l < 0 ? -1 : l > 0 ? 1 : 0;
  }
  /**
   * Return `true` if the line equals the other line.
   */
  equals(e) {
    return e != null && this.start.x === e.start.x && this.start.y === e.start.y && this.end.x === e.end.x && this.end.y === e.end.y;
  }
  /**
   * Returns another line which is a clone of the line.
   */
  clone() {
    return new $(this.start, this.end);
  }
  toJSON() {
    return { start: this.start.toJSON(), end: this.end.toJSON() };
  }
  serialize() {
    return [this.start.serialize(), this.end.serialize()].join(" ");
  }
}
(function(s) {
  function e(t) {
    return t != null && t instanceof s;
  }
  s.isLine = e;
})($ || ($ = {}));
class Dt extends $n {
  get center() {
    return new S(this.x, this.y);
  }
  constructor(e, t, n, i) {
    super(), this.x = e == null ? 0 : e, this.y = t == null ? 0 : t, this.a = n == null ? 0 : n, this.b = i == null ? 0 : i;
  }
  /**
   * Returns a rectangle that is the bounding box of the ellipse.
   */
  bbox() {
    return R.fromEllipse(this);
  }
  /**
   * Returns a point that is the center of the ellipse.
   */
  getCenter() {
    return this.center;
  }
  inflate(e, t) {
    const n = e, i = t != null ? t : e;
    return this.a += 2 * n, this.b += 2 * i, this;
  }
  normalizedDistance(e, t) {
    const n = S.create(e, t), i = n.x - this.x, r = n.y - this.y, o = this.a, a = this.b;
    return i * i / (o * o) + r * r / (a * a);
  }
  containsPoint(e, t) {
    return this.normalizedDistance(e, t) <= 1;
  }
  /**
   * Returns an array of the intersection points of the ellipse and the line.
   * Returns `null` if no intersection exists.
   */
  intersectsWithLine(e) {
    const t = [], n = this.a, i = this.b, r = e.start, o = e.end, a = e.vector(), l = r.diff(new S(this.x, this.y)), c = new S(a.x / (n * n), a.y / (i * i)), u = new S(l.x / (n * n), l.y / (i * i)), f = a.dot(c), d = a.dot(u), g = l.dot(u) - 1, p = d * d - f * g;
    if (p < 0)
      return null;
    if (p > 0) {
      const m = Math.sqrt(p), w = (-d - m) / f, v = (-d + m) / f;
      if ((w < 0 || w > 1) && (v < 0 || v > 1))
        return null;
      w >= 0 && w <= 1 && t.push(r.lerp(o, w)), v >= 0 && v <= 1 && t.push(r.lerp(o, v));
    } else {
      const m = -d / f;
      if (m >= 0 && m <= 1)
        t.push(r.lerp(o, m));
      else
        return null;
    }
    return t;
  }
  /**
   * Returns the point on the boundary of the ellipse that is the
   * intersection of the ellipse with a line starting in the center
   * of the ellipse ending in the point `p`.
   *
   * If angle is specified, the intersection will take into account
   * the rotation of the ellipse by angle degrees around its center.
   */
  intersectsWithLineFromCenterToPoint(e, t = 0) {
    const n = S.clone(e);
    t && n.rotate(t, this.getCenter());
    const i = n.x - this.x, r = n.y - this.y;
    let o;
    if (i === 0)
      return o = this.bbox().getNearestPointToPoint(n), t ? o.rotate(-t, this.getCenter()) : o;
    const a = r / i, l = a * a, c = this.a * this.a, u = this.b * this.b;
    let f = Math.sqrt(1 / (1 / c + l / u));
    f = i < 0 ? -f : f;
    const d = a * f;
    return o = new S(this.x + f, this.y + d), t ? o.rotate(-t, this.getCenter()) : o;
  }
  /**
   * Returns the angle between the x-axis and the tangent from a point. It is
   * valid for points lying on the ellipse boundary only.
   */
  tangentTheta(e) {
    const t = S.clone(e), n = t.x, i = t.y, r = this.a, o = this.b, a = this.bbox().center, l = a.x, c = a.y, u = 30, f = n > a.x + r / 2, d = n < a.x - r / 2;
    let g, p;
    return f || d ? (p = n > a.x ? i - u : i + u, g = r * r / (n - l) - r * r * (i - c) * (p - c) / (o * o * (n - l)) + l) : (g = i > a.y ? n + u : n - u, p = o * o / (i - c) - o * o * (n - l) * (g - l) / (r * r * (i - c)) + c), new S(g, p).theta(t);
  }
  scale(e, t) {
    return this.a *= e, this.b *= t, this;
  }
  rotate(e, t) {
    const n = R.fromEllipse(this);
    n.rotate(e, t);
    const i = Dt.fromRect(n);
    return this.a = i.a, this.b = i.b, this.x = i.x, this.y = i.y, this;
  }
  translate(e, t) {
    const n = S.create(e, t);
    return this.x += n.x, this.y += n.y, this;
  }
  equals(e) {
    return e != null && e.x === this.x && e.y === this.y && e.a === this.a && e.b === this.b;
  }
  clone() {
    return new Dt(this.x, this.y, this.a, this.b);
  }
  toJSON() {
    return { x: this.x, y: this.y, a: this.a, b: this.b };
  }
  serialize() {
    return "".concat(this.x, " ").concat(this.y, " ").concat(this.a, " ").concat(this.b);
  }
}
(function(s) {
  function e(t) {
    return t != null && t instanceof s;
  }
  s.isEllipse = e;
})(Dt || (Dt = {}));
(function(s) {
  function e(i, r, o, a) {
    return i == null || typeof i == "number" ? new s(i, r, o, a) : t(i);
  }
  s.create = e;
  function t(i) {
    return s.isEllipse(i) ? i.clone() : Array.isArray(i) ? new s(i[0], i[1], i[2], i[3]) : new s(i.x, i.y, i.a, i.b);
  }
  s.parse = t;
  function n(i) {
    const r = i.center;
    return new s(r.x, r.y, i.width / 2, i.height / 2);
  }
  s.fromRect = n;
})(Dt || (Dt = {}));
const $b = new RegExp("^[\\s\\dLMCZz,.]*$");
function Fb(s) {
  return typeof s != "string" ? !1 : $b.test(s);
}
function va(s, e) {
  return (s % e + e) % e;
}
function zb(s, e, t, n, i) {
  const r = [], o = s[s.length - 1], a = e != null && e > 0, l = e || 0;
  if (n && a) {
    s = s.slice();
    const f = s[0], d = new S(o.x + (f.x - o.x) / 2, o.y + (f.y - o.y) / 2);
    s.splice(0, 0, d);
  }
  let c = s[0], u = 1;
  for (t ? r.push("M", c.x, c.y) : r.push("L", c.x, c.y); u < (n ? s.length : s.length - 1); ) {
    let f = s[va(u, s.length)], d = c.x - f.x, g = c.y - f.y;
    if (a && (d !== 0 || g !== 0) && (i == null || i.indexOf(u - 1) < 0)) {
      let p = Math.sqrt(d * d + g * g);
      const m = d * Math.min(l, p / 2) / p, w = g * Math.min(l, p / 2) / p, v = f.x + m, y = f.y + w;
      r.push("L", v, y);
      let b = s[va(u + 1, s.length)];
      for (; u < s.length - 2 && Math.round(b.x - f.x) === 0 && Math.round(b.y - f.y) === 0; )
        b = s[va(u + 2, s.length)], u += 1;
      d = b.x - f.x, g = b.y - f.y, p = Math.max(1, Math.sqrt(d * d + g * g));
      const x = d * Math.min(l, p / 2) / p, C = g * Math.min(l, p / 2) / p, A = f.x + x, P = f.y + C;
      r.push("Q", f.x, f.y, A, P), f = new S(A, P);
    } else
      r.push("L", f.x, f.y);
    c = f, u += 1;
  }
  return n ? r.push("Z") : r.push("L", o.x, o.y), r.map((f) => typeof f == "string" ? f : +f.toFixed(3)).join(" ");
}
function kf(s, e = {}) {
  const t = [];
  return s && s.length && s.forEach((n) => {
    Array.isArray(n) ? t.push({ x: n[0], y: n[1] }) : t.push({ x: n.x, y: n.y });
  }), zb(t, e.round, e.initialMove == null || e.initialMove, e.close, e.exclude);
}
function fo(s, e, t, n, i = 0, r = 0, o = 0, a, l) {
  if (t === 0 || n === 0)
    return [];
  a -= s, l -= e, t = Math.abs(t), n = Math.abs(n);
  const c = -a / 2, u = -l / 2, f = Math.cos(i * Math.PI / 180), d = Math.sin(i * Math.PI / 180), g = f * c + d * u, p = -1 * d * c + f * u, m = g * g, w = p * p, v = t * t, y = n * n, b = m / v + w / y;
  let x;
  if (b > 1)
    t = Math.sqrt(b) * t, n = Math.sqrt(b) * n, x = 0;
  else {
    let Qe = 1;
    r === o && (Qe = -1), x = Qe * Math.sqrt((v * y - v * w - y * m) / (v * w + y * m));
  }
  const C = x * t * p / n, A = -1 * x * n * g / t, P = f * C - d * A + a / 2, O = d * C + f * A + l / 2;
  let k = Math.atan2((p - A) / n, (g - C) / t) - Math.atan2(0, 1), D = k >= 0 ? k : 2 * Math.PI + k;
  k = Math.atan2((-p - A) / n, (-g - C) / t) - Math.atan2((p - A) / n, (g - C) / t);
  let L = k >= 0 ? k : 2 * Math.PI + k;
  o === 0 && L > 0 ? L -= 2 * Math.PI : o !== 0 && L < 0 && (L += 2 * Math.PI);
  const B = L * 2 / Math.PI, ee = Math.ceil(B < 0 ? -1 * B : B), q = L / ee, _ = 8 / 3 * Math.sin(q / 4) * Math.sin(q / 4) / Math.sin(q / 2), I = f * t, H = f * n, oe = d * t, ne = d * n;
  let ye = Math.cos(D), Se = Math.sin(D), Rt = -_ * (I * Se + ne * ye), Wt = -_ * (oe * Se - H * ye), ot = 0, Mt = 0;
  const Ke = [];
  for (let Qe = 0; Qe < ee; Qe += 1) {
    D += q, ye = Math.cos(D), Se = Math.sin(D), ot = I * ye - ne * Se + P, Mt = oe * ye + H * Se + O;
    const mn = -_ * (I * Se + ne * ye), Hn = -_ * (oe * Se - H * ye), gt = Qe * 6;
    Ke[gt] = Number(Rt + s), Ke[gt + 1] = Number(Wt + e), Ke[gt + 2] = Number(ot - mn + s), Ke[gt + 3] = Number(Mt - Hn + e), Ke[gt + 4] = Number(ot + s), Ke[gt + 5] = Number(Mt + e), Rt = ot + mn, Wt = Mt + Hn;
  }
  return Ke.map((Qe) => +Qe.toFixed(2));
}
function Vb(s, e, t, n, i = 0, r = 0, o = 0, a, l) {
  const c = [], u = fo(s, e, t, n, i, r, o, a, l);
  if (u != null)
    for (let f = 0, d = u.length; f < d; f += 6)
      c.push("C", u[f], u[f + 1], u[f + 2], u[f + 3], u[f + 4], u[f + 5]);
  return c.join(" ");
}
class ke extends $n {
  get start() {
    return this.points[0] || null;
  }
  get end() {
    return this.points[this.points.length - 1] || null;
  }
  constructor(e) {
    if (super(), e != null) {
      if (typeof e == "string")
        return ke.parse(e);
      this.points = e.map((t) => S.create(t));
    } else
      this.points = [];
  }
  scale(e, t, n = new S()) {
    return this.points.forEach((i) => i.scale(e, t, n)), this;
  }
  rotate(e, t) {
    return this.points.forEach((n) => n.rotate(e, t)), this;
  }
  translate(e, t) {
    const n = S.create(e, t);
    return this.points.forEach((i) => i.translate(n.x, n.y)), this;
  }
  round(e = 0) {
    return this.points.forEach((t) => t.round(e)), this;
  }
  bbox() {
    if (this.points.length === 0)
      return new R();
    let e = 1 / 0, t = -1 / 0, n = 1 / 0, i = -1 / 0;
    const r = this.points;
    for (let o = 0, a = r.length; o < a; o += 1) {
      const l = r[o], c = l.x, u = l.y;
      c < e && (e = c), c > t && (t = c), u < n && (n = u), u > i && (i = u);
    }
    return new R(e, n, t - e, i - n);
  }
  closestPoint(e) {
    const t = this.closestPointLength(e);
    return this.pointAtLength(t);
  }
  closestPointLength(e) {
    const t = this.points, n = t.length;
    if (n === 0 || n === 1)
      return 0;
    let i = 0, r = 0, o = 1 / 0;
    for (let a = 0, l = n - 1; a < l; a += 1) {
      const c = new $(t[a], t[a + 1]), u = c.length(), f = c.closestPointNormalizedLength(e), g = c.pointAt(f).squaredDistance(e);
      g < o && (o = g, r = i + f * u), i += u;
    }
    return r;
  }
  closestPointNormalizedLength(e) {
    const t = this.length();
    return t === 0 ? 0 : this.closestPointLength(e) / t;
  }
  closestPointTangent(e) {
    const t = this.closestPointLength(e);
    return this.tangentAtLength(t);
  }
  containsPoint(e) {
    if (this.points.length === 0)
      return !1;
    const t = S.clone(e), n = t.x, i = t.y, r = this.points, o = r.length;
    let a = o - 1, l = 0;
    for (let c = 0; c < o; c += 1) {
      const u = r[a], f = r[c];
      if (t.equals(u))
        return !0;
      const d = new $(u, f);
      if (d.containsPoint(e))
        return !0;
      if (i <= u.y && i > f.y || i > u.y && i <= f.y) {
        const g = u.x - n > f.x - n ? u.x - n : f.x - n;
        if (g >= 0) {
          const p = new S(n + g, i), m = new $(e, p);
          d.intersectsWithLine(m) && (l += 1);
        }
      }
      a = c;
    }
    return l % 2 === 1;
  }
  intersectsWithLine(e) {
    const t = [];
    for (let n = 0, i = this.points.length - 1; n < i; n += 1) {
      const r = this.points[n], o = this.points[n + 1], a = e.intersectsWithLine(new $(r, o));
      a && t.push(a);
    }
    return t.length > 0 ? t : null;
  }
  isDifferentiable() {
    for (let e = 0, t = this.points.length - 1; e < t; e += 1) {
      const n = this.points[e], i = this.points[e + 1];
      if (new $(n, i).isDifferentiable())
        return !0;
    }
    return !1;
  }
  length() {
    let e = 0;
    for (let t = 0, n = this.points.length - 1; t < n; t += 1) {
      const i = this.points[t], r = this.points[t + 1];
      e += i.distance(r);
    }
    return e;
  }
  pointAt(e) {
    const t = this.points, n = t.length;
    if (n === 0)
      return null;
    if (n === 1 || e <= 0)
      return t[0].clone();
    if (e >= 1)
      return t[n - 1].clone();
    const r = this.length() * e;
    return this.pointAtLength(r);
  }
  pointAtLength(e) {
    const t = this.points, n = t.length;
    if (n === 0)
      return null;
    if (n === 1)
      return t[0].clone();
    let i = !0;
    e < 0 && (i = !1, e = -e);
    let r = 0;
    for (let a = 0, l = n - 1; a < l; a += 1) {
      const c = i ? a : l - 1 - a, u = t[c], f = t[c + 1], d = new $(u, f), g = u.distance(f);
      if (e <= r + g)
        return d.pointAtLength((i ? 1 : -1) * (e - r));
      r += g;
    }
    return (i ? t[n - 1] : t[0]).clone();
  }
  tangentAt(e) {
    const n = this.points.length;
    if (n === 0 || n === 1)
      return null;
    e < 0 && (e = 0), e > 1 && (e = 1);
    const r = this.length() * e;
    return this.tangentAtLength(r);
  }
  tangentAtLength(e) {
    const t = this.points, n = t.length;
    if (n === 0 || n === 1)
      return null;
    let i = !0;
    e < 0 && (i = !1, e = -e);
    let r, o = 0;
    for (let a = 0, l = n - 1; a < l; a += 1) {
      const c = i ? a : l - 1 - a, u = t[c], f = t[c + 1], d = new $(u, f), g = u.distance(f);
      if (d.isDifferentiable()) {
        if (e <= o + g)
          return d.tangentAtLength((i ? 1 : -1) * (e - o));
        r = d;
      }
      o += g;
    }
    if (r) {
      const a = i ? 1 : 0;
      return r.tangentAt(a);
    }
    return null;
  }
  simplify(e = {}) {
    const t = this.points;
    if (t.length < 3)
      return this;
    const n = e.threshold || 0;
    let i = 0;
    for (; t[i + 2]; ) {
      const r = i, o = i + 1, a = i + 2, l = t[r], c = t[o], u = t[a];
      new $(l, u).closestPoint(c).distance(c) <= n ? t.splice(o, 1) : i += 1;
    }
    return this;
  }
  toHull() {
    const e = this.points, t = e.length;
    if (t === 0)
      return new ke();
    let n = e[0];
    for (let d = 1; d < t; d += 1)
      (e[d].y < n.y || e[d].y === n.y && e[d].x > n.x) && (n = e[d]);
    const i = [];
    for (let d = 0; d < t; d += 1) {
      let g = n.theta(e[d]);
      g === 0 && (g = 360), i.push([e[d], d, g]);
    }
    if (i.sort((d, g) => {
      let p = d[2] - g[2];
      return p === 0 && (p = g[1] - d[1]), p;
    }), i.length > 2) {
      const d = i[i.length - 1];
      i.unshift(d);
    }
    const r = {}, o = [], a = (d) => "".concat(d[0].toString(), "@").concat(d[1]);
    for (; i.length !== 0; ) {
      const d = i.pop(), g = d[0];
      if (r[a(d)])
        continue;
      let p = !1;
      for (; !p; )
        if (o.length < 2)
          o.push(d), p = !0;
        else {
          const m = o.pop(), w = m[0], v = o.pop(), y = v[0], b = y.cross(w, g);
          if (b < 0)
            o.push(v), o.push(m), o.push(d), p = !0;
          else if (b === 0) {
            const C = w.angleBetween(y, g);
            Math.abs(C - 180) < 1e-10 || w.equals(g) || y.equals(w) ? (r[a(m)] = w, o.push(v)) : Math.abs((C + 1) % 360 - 1) < 1e-10 && (o.push(v), i.push(m));
          } else
            r[a(m)] = w, o.push(v);
        }
    }
    o.length > 2 && o.pop();
    let l, c = -1;
    for (let d = 0, g = o.length; d < g; d += 1) {
      const p = o[d][1];
      (l === void 0 || p < l) && (l = p, c = d);
    }
    let u = [];
    if (c > 0) {
      const d = o.slice(c), g = o.slice(0, c);
      u = d.concat(g);
    } else
      u = o;
    const f = [];
    for (let d = 0, g = u.length; d < g; d += 1)
      f.push(u[d][0]);
    return new ke(f);
  }
  equals(e) {
    return e == null || e.points.length !== this.points.length ? !1 : e.points.every((t, n) => t.equals(this.points[n]));
  }
  clone() {
    return new ke(this.points.map((e) => e.clone()));
  }
  toJSON() {
    return this.points.map((e) => e.toJSON());
  }
  serialize() {
    return this.points.map((e) => "".concat(e.serialize())).join(" ");
  }
}
(function(s) {
  function e(t) {
    return t != null && t instanceof s;
  }
  s.isPolyline = e;
})(ke || (ke = {}));
(function(s) {
  function e(t) {
    const n = t.trim();
    if (n === "")
      return new s();
    const i = [], r = n.split(/\s*,\s*|\s+/);
    for (let o = 0, a = r.length; o < a; o += 2)
      i.push({ x: +r[o], y: +r[o + 1] });
    return new s(i);
  }
  s.parse = e;
})(ke || (ke = {}));
class xe extends $n {
  constructor(e, t, n, i) {
    super(), this.PRECISION = 3, this.start = S.create(e), this.controlPoint1 = S.create(t), this.controlPoint2 = S.create(n), this.end = S.create(i);
  }
  bbox() {
    const e = this.start, t = this.controlPoint1, n = this.controlPoint2, i = this.end, r = e.x, o = e.y, a = t.x, l = t.y, c = n.x, u = n.y, f = i.x, d = i.y, g = [], p = [[], []];
    let m, w, v, y, b, x, C, A;
    for (let I = 0; I < 2; I += 1) {
      if (I === 0 ? (w = 6 * r - 12 * a + 6 * c, m = -3 * r + 9 * a - 9 * c + 3 * f, v = 3 * a - 3 * r) : (w = 6 * o - 12 * l + 6 * u, m = -3 * o + 9 * l - 9 * u + 3 * d, v = 3 * l - 3 * o), Math.abs(m) < 1e-12) {
        if (Math.abs(w) < 1e-12)
          continue;
        y = -v / w, y > 0 && y < 1 && g.push(y);
        continue;
      }
      C = w * w - 4 * v * m, A = Math.sqrt(C), !(C < 0) && (b = (-w + A) / (2 * m), b > 0 && b < 1 && g.push(b), x = (-w - A) / (2 * m), x > 0 && x < 1 && g.push(x));
    }
    let P, O, k, D = g.length;
    const L = D;
    for (; D; )
      D -= 1, y = g[D], k = 1 - y, P = k * k * k * r + 3 * k * k * y * a + 3 * k * y * y * c + y * y * y * f, p[0][D] = P, O = k * k * k * o + 3 * k * k * y * l + 3 * k * y * y * u + y * y * y * d, p[1][D] = O;
    g[L] = 0, g[L + 1] = 1, p[0][L] = r, p[1][L] = o, p[0][L + 1] = f, p[1][L + 1] = d, g.length = L + 2, p[0].length = L + 2, p[1].length = L + 2;
    const B = Math.min.apply(null, p[0]), ee = Math.min.apply(null, p[1]), q = Math.max.apply(null, p[0]), _ = Math.max.apply(null, p[1]);
    return new R(B, ee, q - B, _ - ee);
  }
  closestPoint(e, t = {}) {
    return this.pointAtT(this.closestPointT(e, t));
  }
  closestPointLength(e, t = {}) {
    const n = this.getOptions(t);
    return this.lengthAtT(this.closestPointT(e, n), n);
  }
  closestPointNormalizedLength(e, t = {}) {
    const n = this.getOptions(t), i = this.closestPointLength(e, n);
    if (!i)
      return 0;
    const r = this.length(n);
    return r === 0 ? 0 : i / r;
  }
  closestPointT(e, t = {}) {
    const n = this.getPrecision(t), i = this.getDivisions(t), r = Math.pow(10, -n);
    let o = null, a = 0, l = 0, c = 0, u = 0, f = 0, d = null;
    const g = i.length;
    let p = g > 0 ? 1 / g : 0;
    for (i.forEach((m, w) => {
      const v = m.start.distance(e), y = m.end.distance(e), b = v + y;
      (d == null || b < d) && (o = m, a = w * p, l = (w + 1) * p, c = v, u = y, d = b, f = m.endpointDistance());
    }); ; ) {
      const m = c ? Math.abs(c - u) / c : 0, w = u != null ? Math.abs(c - u) / u : 0, v = m < r || w < r, y = c ? c < f * r : !0, b = u ? u < f * r : !0;
      if (v || (y || b))
        return c <= u ? a : l;
      const C = o.divide(0.5);
      p /= 2;
      const A = C[0].start.distance(e), P = C[0].end.distance(e), O = A + P, k = C[1].start.distance(e), D = C[1].end.distance(e), L = k + D;
      O <= L ? (o = C[0], l -= p, c = A, u = P) : (o = C[1], a += p, c = k, u = D);
    }
  }
  closestPointTangent(e, t = {}) {
    return this.tangentAtT(this.closestPointT(e, t));
  }
  containsPoint(e, t = {}) {
    return this.toPolyline(t).containsPoint(e);
  }
  divideAt(e, t = {}) {
    if (e <= 0)
      return this.divideAtT(0);
    if (e >= 1)
      return this.divideAtT(1);
    const n = this.tAt(e, t);
    return this.divideAtT(n);
  }
  divideAtLength(e, t = {}) {
    const n = this.tAtLength(e, t);
    return this.divideAtT(n);
  }
  divide(e) {
    return this.divideAtT(e);
  }
  divideAtT(e) {
    const t = this.start, n = this.controlPoint1, i = this.controlPoint2, r = this.end;
    if (e <= 0)
      return [
        new xe(t, t, t, t),
        new xe(t, n, i, r)
      ];
    if (e >= 1)
      return [
        new xe(t, n, i, r),
        new xe(r, r, r, r)
      ];
    const o = this.getSkeletonPoints(e), a = o.startControlPoint1, l = o.startControlPoint2, c = o.divider, u = o.dividerControlPoint1, f = o.dividerControlPoint2;
    return [
      new xe(t, a, l, c),
      new xe(c, u, f, r)
    ];
  }
  endpointDistance() {
    return this.start.distance(this.end);
  }
  getSkeletonPoints(e) {
    const t = this.start, n = this.controlPoint1, i = this.controlPoint2, r = this.end;
    if (e <= 0)
      return {
        startControlPoint1: t.clone(),
        startControlPoint2: t.clone(),
        divider: t.clone(),
        dividerControlPoint1: n.clone(),
        dividerControlPoint2: i.clone()
      };
    if (e >= 1)
      return {
        startControlPoint1: n.clone(),
        startControlPoint2: i.clone(),
        divider: r.clone(),
        dividerControlPoint1: r.clone(),
        dividerControlPoint2: r.clone()
      };
    const o = new $(t, n).pointAt(e), a = new $(n, i).pointAt(e), l = new $(i, r).pointAt(e), c = new $(o, a).pointAt(e), u = new $(a, l).pointAt(e), f = new $(c, u).pointAt(e);
    return {
      startControlPoint1: o,
      startControlPoint2: c,
      divider: f,
      dividerControlPoint1: u,
      dividerControlPoint2: l
    };
  }
  getSubdivisions(e = {}) {
    const t = this.getPrecision(e);
    let n = [
      new xe(this.start, this.controlPoint1, this.controlPoint2, this.end)
    ];
    if (t === 0)
      return n;
    let i = this.endpointDistance();
    const r = Math.pow(10, -t);
    let o = 0;
    for (; ; ) {
      o += 1;
      const a = [];
      n.forEach((u) => {
        const f = u.divide(0.5);
        a.push(f[0], f[1]);
      });
      const l = a.reduce((u, f) => u + f.endpointDistance(), 0), c = l !== 0 ? (l - i) / l : 0;
      if (o > 1 && c < r)
        return a;
      n = a, i = l;
    }
  }
  length(e = {}) {
    return this.getDivisions(e).reduce((n, i) => n + i.endpointDistance(), 0);
  }
  lengthAtT(e, t = {}) {
    if (e <= 0)
      return 0;
    const n = t.precision === void 0 ? this.PRECISION : t.precision;
    return this.divide(e)[0].length({ precision: n });
  }
  pointAt(e, t = {}) {
    if (e <= 0)
      return this.start.clone();
    if (e >= 1)
      return this.end.clone();
    const n = this.tAt(e, t);
    return this.pointAtT(n);
  }
  pointAtLength(e, t = {}) {
    const n = this.tAtLength(e, t);
    return this.pointAtT(n);
  }
  pointAtT(e) {
    return e <= 0 ? this.start.clone() : e >= 1 ? this.end.clone() : this.getSkeletonPoints(e).divider;
  }
  isDifferentiable() {
    const e = this.start, t = this.controlPoint1, n = this.controlPoint2, i = this.end;
    return !(e.equals(t) && t.equals(n) && n.equals(i));
  }
  tangentAt(e, t = {}) {
    if (!this.isDifferentiable())
      return null;
    e < 0 ? e = 0 : e > 1 && (e = 1);
    const n = this.tAt(e, t);
    return this.tangentAtT(n);
  }
  tangentAtLength(e, t = {}) {
    if (!this.isDifferentiable())
      return null;
    const n = this.tAtLength(e, t);
    return this.tangentAtT(n);
  }
  tangentAtT(e) {
    if (!this.isDifferentiable())
      return null;
    e < 0 && (e = 0), e > 1 && (e = 1);
    const t = this.getSkeletonPoints(e), n = t.startControlPoint2, i = t.dividerControlPoint1, r = t.divider, o = new $(n, i);
    return o.translate(r.x - n.x, r.y - n.y), o;
  }
  getPrecision(e = {}) {
    return e.precision == null ? this.PRECISION : e.precision;
  }
  getDivisions(e = {}) {
    if (e.subdivisions != null)
      return e.subdivisions;
    const t = this.getPrecision(e);
    return this.getSubdivisions({ precision: t });
  }
  getOptions(e = {}) {
    const t = this.getPrecision(e), n = this.getDivisions(e);
    return { precision: t, subdivisions: n };
  }
  tAt(e, t = {}) {
    if (e <= 0)
      return 0;
    if (e >= 1)
      return 1;
    const n = this.getOptions(t), r = this.length(n) * e;
    return this.tAtLength(r, n);
  }
  tAtLength(e, t = {}) {
    let n = !0;
    e < 0 && (n = !1, e = -e);
    const i = this.getPrecision(t), r = this.getDivisions(t), o = { precision: i, subdivisions: r };
    let a = null, l, c, u = 0, f = 0, d = 0;
    const g = r.length;
    let p = g > 0 ? 1 / g : 0;
    for (let v = 0; v < g; v += 1) {
      const y = n ? v : g - 1 - v, b = r[v], x = b.endpointDistance();
      if (e <= d + x) {
        a = b, l = y * p, c = (y + 1) * p, u = n ? e - d : x + d - e, f = n ? x + d - e : e - d;
        break;
      }
      d += x;
    }
    if (a == null)
      return n ? 1 : 0;
    const m = this.length(o), w = Math.pow(10, -i);
    for (; ; ) {
      let v;
      if (v = m !== 0 ? u / m : 0, v < w)
        return l;
      if (v = m !== 0 ? f / m : 0, v < w)
        return c;
      let y, b;
      const x = a.divide(0.5);
      p /= 2;
      const C = x[0].endpointDistance(), A = x[1].endpointDistance();
      u <= C ? (a = x[0], c -= p, y = u, b = C - y) : (a = x[1], l += p, y = u - C, b = A - y), u = y, f = b;
    }
  }
  toPoints(e = {}) {
    const t = this.getDivisions(e), n = [t[0].start.clone()];
    return t.forEach((i) => n.push(i.end.clone())), n;
  }
  toPolyline(e = {}) {
    return new ke(this.toPoints(e));
  }
  scale(e, t, n) {
    return this.start.scale(e, t, n), this.controlPoint1.scale(e, t, n), this.controlPoint2.scale(e, t, n), this.end.scale(e, t, n), this;
  }
  rotate(e, t) {
    return this.start.rotate(e, t), this.controlPoint1.rotate(e, t), this.controlPoint2.rotate(e, t), this.end.rotate(e, t), this;
  }
  translate(e, t) {
    return typeof e == "number" ? (this.start.translate(e, t), this.controlPoint1.translate(e, t), this.controlPoint2.translate(e, t), this.end.translate(e, t)) : (this.start.translate(e), this.controlPoint1.translate(e), this.controlPoint2.translate(e), this.end.translate(e)), this;
  }
  equals(e) {
    return e != null && this.start.equals(e.start) && this.controlPoint1.equals(e.controlPoint1) && this.controlPoint2.equals(e.controlPoint2) && this.end.equals(e.end);
  }
  clone() {
    return new xe(this.start, this.controlPoint1, this.controlPoint2, this.end);
  }
  toJSON() {
    return {
      start: this.start.toJSON(),
      controlPoint1: this.controlPoint1.toJSON(),
      controlPoint2: this.controlPoint2.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    return [
      this.start.serialize(),
      this.controlPoint1.serialize(),
      this.controlPoint2.serialize(),
      this.end.serialize()
    ].join(" ");
  }
}
(function(s) {
  function e(t) {
    return t != null && t instanceof s;
  }
  s.isCurve = e;
})(xe || (xe = {}));
(function(s) {
  function e(i) {
    const r = i.length, o = [], a = [];
    let l = 2;
    o[0] = i[0] / l;
    for (let c = 1; c < r; c += 1)
      a[c] = 1 / l, l = (c < r - 1 ? 4 : 3.5) - a[c], o[c] = (i[c] - o[c - 1]) / l;
    for (let c = 1; c < r; c += 1)
      o[r - c - 1] -= a[r - c] * o[r - c];
    return o;
  }
  function t(i) {
    const r = i.map((d) => S.clone(d)), o = [], a = [], l = r.length - 1;
    if (l === 1)
      return o[0] = new S((2 * r[0].x + r[1].x) / 3, (2 * r[0].y + r[1].y) / 3), a[0] = new S(2 * o[0].x - r[0].x, 2 * o[0].y - r[0].y), [o, a];
    const c = [];
    for (let d = 1; d < l - 1; d += 1)
      c[d] = 4 * r[d].x + 2 * r[d + 1].x;
    c[0] = r[0].x + 2 * r[1].x, c[l - 1] = (8 * r[l - 1].x + r[l].x) / 2;
    const u = e(c);
    for (let d = 1; d < l - 1; d += 1)
      c[d] = 4 * r[d].y + 2 * r[d + 1].y;
    c[0] = r[0].y + 2 * r[1].y, c[l - 1] = (8 * r[l - 1].y + r[l].y) / 2;
    const f = e(c);
    for (let d = 0; d < l; d += 1)
      o.push(new S(u[d], f[d])), d < l - 1 ? a.push(new S(2 * r[d + 1].x - u[d + 1], 2 * r[d + 1].y - f[d + 1])) : a.push(new S((r[l].x + u[l - 1]) / 2, (r[l].y + f[l - 1]) / 2));
    return [o, a];
  }
  function n(i) {
    if (i == null || Array.isArray(i) && i.length < 2)
      throw new Error("At least 2 points are required");
    const r = t(i), o = [];
    for (let a = 0, l = r[0].length; a < l; a += 1) {
      const c = new S(r[0][a].x, r[0][a].y), u = new S(r[1][a].x, r[1][a].y);
      o.push(new s(i[a], c, u, i[a + 1]));
    }
    return o;
  }
  s.throughPoints = n;
})(xe || (xe = {}));
class Fo extends $n {
  constructor() {
    super(...arguments), this.isVisible = !0, this.isSegment = !0, this.isSubpathStart = !1;
  }
  get end() {
    return this.endPoint;
  }
  get start() {
    if (this.previousSegment == null)
      throw new Error("Missing previous segment. (This segment cannot be the first segment of a path, or segment has not yet been added to a path.)");
    return this.previousSegment.end;
  }
  closestPointT(e, t) {
    if (this.closestPointNormalizedLength)
      return this.closestPointNormalizedLength(e);
    throw new Error("Neither `closestPointT` nor `closestPointNormalizedLength` method is implemented.");
  }
  // eslint-disable-next-line
  lengthAtT(e, t) {
    if (e <= 0)
      return 0;
    const n = this.length();
    return e >= 1 ? n : n * e;
  }
  divideAtT(e) {
    if (this.divideAt)
      return this.divideAt(e);
    throw new Error("Neither `divideAtT` nor `divideAt` method is implemented.");
  }
  pointAtT(e) {
    if (this.pointAt)
      return this.pointAt(e);
    throw new Error("Neither `pointAtT` nor `pointAt` method is implemented.");
  }
  tangentAtT(e) {
    if (this.tangentAt)
      return this.tangentAt(e);
    throw new Error("Neither `tangentAtT` nor `tangentAt` method is implemented.");
  }
}
class Ze extends Fo {
  constructor(e, t) {
    super(), $.isLine(e) ? this.endPoint = e.end.clone().round(2) : this.endPoint = S.create(e, t).round(2);
  }
  get type() {
    return "L";
  }
  get line() {
    return new $(this.start, this.end);
  }
  bbox() {
    return this.line.bbox();
  }
  closestPoint(e) {
    return this.line.closestPoint(e);
  }
  closestPointLength(e) {
    return this.line.closestPointLength(e);
  }
  closestPointNormalizedLength(e) {
    return this.line.closestPointNormalizedLength(e);
  }
  closestPointTangent(e) {
    return this.line.closestPointTangent(e);
  }
  length() {
    return this.line.length();
  }
  divideAt(e) {
    const t = this.line.divideAt(e);
    return [new Ze(t[0]), new Ze(t[1])];
  }
  divideAtLength(e) {
    const t = this.line.divideAtLength(e);
    return [new Ze(t[0]), new Ze(t[1])];
  }
  getSubdivisions() {
    return [];
  }
  pointAt(e) {
    return this.line.pointAt(e);
  }
  pointAtLength(e) {
    return this.line.pointAtLength(e);
  }
  tangentAt(e) {
    return this.line.tangentAt(e);
  }
  tangentAtLength(e) {
    return this.line.tangentAtLength(e);
  }
  isDifferentiable() {
    return this.previousSegment == null ? !1 : !this.start.equals(this.end);
  }
  clone() {
    return new Ze(this.end);
  }
  scale(e, t, n) {
    return this.end.scale(e, t, n), this;
  }
  rotate(e, t) {
    return this.end.rotate(e, t), this;
  }
  translate(e, t) {
    return typeof e == "number" ? this.end.translate(e, t) : this.end.translate(e), this;
  }
  equals(e) {
    return this.type === e.type && this.start.equals(e.start) && this.end.equals(e.end);
  }
  toJSON() {
    return {
      type: this.type,
      start: this.start.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    const e = this.end;
    return "".concat(this.type, " ").concat(e.x, " ").concat(e.y);
  }
}
(function(s) {
  function e(...t) {
    const n = t.length, i = t[0];
    if ($.isLine(i))
      return new s(i);
    if (S.isPointLike(i))
      return n === 1 ? new s(i) : t.map((o) => new s(o));
    if (n === 2)
      return new s(+t[0], +t[1]);
    const r = [];
    for (let o = 0; o < n; o += 2) {
      const a = +t[o], l = +t[o + 1];
      r.push(new s(a, l));
    }
    return r;
  }
  s.create = e;
})(Ze || (Ze = {}));
class Ws extends Fo {
  get end() {
    if (!this.subpathStartSegment)
      throw new Error("Missing subpath start segment. (This segment needs a subpath start segment (e.g. MoveTo), or segment has not yet been added to a path.)");
    return this.subpathStartSegment.end;
  }
  get type() {
    return "Z";
  }
  get line() {
    return new $(this.start, this.end);
  }
  bbox() {
    return this.line.bbox();
  }
  closestPoint(e) {
    return this.line.closestPoint(e);
  }
  closestPointLength(e) {
    return this.line.closestPointLength(e);
  }
  closestPointNormalizedLength(e) {
    return this.line.closestPointNormalizedLength(e);
  }
  closestPointTangent(e) {
    return this.line.closestPointTangent(e);
  }
  length() {
    return this.line.length();
  }
  divideAt(e) {
    const t = this.line.divideAt(e);
    return [
      // do not actually cut into the segment, first divided part can stay as Z
      t[1].isDifferentiable() ? new Ze(t[0]) : this.clone(),
      new Ze(t[1])
    ];
  }
  divideAtLength(e) {
    const t = this.line.divideAtLength(e);
    return [
      t[1].isDifferentiable() ? new Ze(t[0]) : this.clone(),
      new Ze(t[1])
    ];
  }
  getSubdivisions() {
    return [];
  }
  pointAt(e) {
    return this.line.pointAt(e);
  }
  pointAtLength(e) {
    return this.line.pointAtLength(e);
  }
  tangentAt(e) {
    return this.line.tangentAt(e);
  }
  tangentAtLength(e) {
    return this.line.tangentAtLength(e);
  }
  isDifferentiable() {
    return !this.previousSegment || !this.subpathStartSegment ? !1 : !this.start.equals(this.end);
  }
  scale() {
    return this;
  }
  rotate() {
    return this;
  }
  translate() {
    return this;
  }
  equals(e) {
    return this.type === e.type && this.start.equals(e.start) && this.end.equals(e.end);
  }
  clone() {
    return new Ws();
  }
  toJSON() {
    return {
      type: this.type,
      start: this.start.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    return this.type;
  }
}
(function(s) {
  function e() {
    return new s();
  }
  s.create = e;
})(Ws || (Ws = {}));
class Js extends Fo {
  constructor(e, t) {
    super(), this.isVisible = !1, this.isSubpathStart = !0, $.isLine(e) || xe.isCurve(e) ? this.endPoint = e.end.clone().round(2) : this.endPoint = S.create(e, t).round(2);
  }
  get start() {
    throw new Error("Illegal access. Moveto segments should not need a start property.");
  }
  get type() {
    return "M";
  }
  bbox() {
    return null;
  }
  closestPoint() {
    return this.end.clone();
  }
  closestPointLength() {
    return 0;
  }
  closestPointNormalizedLength() {
    return 0;
  }
  closestPointT() {
    return 1;
  }
  closestPointTangent() {
    return null;
  }
  length() {
    return 0;
  }
  lengthAtT() {
    return 0;
  }
  divideAt() {
    return [this.clone(), this.clone()];
  }
  divideAtLength() {
    return [this.clone(), this.clone()];
  }
  getSubdivisions() {
    return [];
  }
  pointAt() {
    return this.end.clone();
  }
  pointAtLength() {
    return this.end.clone();
  }
  pointAtT() {
    return this.end.clone();
  }
  tangentAt() {
    return null;
  }
  tangentAtLength() {
    return null;
  }
  tangentAtT() {
    return null;
  }
  isDifferentiable() {
    return !1;
  }
  scale(e, t, n) {
    return this.end.scale(e, t, n), this;
  }
  rotate(e, t) {
    return this.end.rotate(e, t), this;
  }
  translate(e, t) {
    return typeof e == "number" ? this.end.translate(e, t) : this.end.translate(e), this;
  }
  clone() {
    return new Js(this.end);
  }
  equals(e) {
    return this.type === e.type && this.end.equals(e.end);
  }
  toJSON() {
    return {
      type: this.type,
      end: this.end.toJSON()
    };
  }
  serialize() {
    const e = this.end;
    return "".concat(this.type, " ").concat(e.x, " ").concat(e.y);
  }
}
(function(s) {
  function e(...t) {
    const n = t.length, i = t[0];
    if ($.isLine(i))
      return new s(i);
    if (xe.isCurve(i))
      return new s(i);
    if (S.isPointLike(i)) {
      if (n === 1)
        return new s(i);
      const o = [];
      for (let a = 0; a < n; a += 1)
        a === 0 ? o.push(new s(t[a])) : o.push(new Ze(t[a]));
      return o;
    }
    if (n === 2)
      return new s(+t[0], +t[1]);
    const r = [];
    for (let o = 0; o < n; o += 2) {
      const a = +t[o], l = +t[o + 1];
      o === 0 ? r.push(new s(a, l)) : r.push(new Ze(a, l));
    }
    return r;
  }
  s.create = e;
})(Js || (Js = {}));
class yt extends Fo {
  constructor(e, t, n, i, r, o) {
    super(), xe.isCurve(e) ? (this.controlPoint1 = e.controlPoint1.clone().round(2), this.controlPoint2 = e.controlPoint2.clone().round(2), this.endPoint = e.end.clone().round(2)) : typeof e == "number" ? (this.controlPoint1 = new S(e, t).round(2), this.controlPoint2 = new S(n, i).round(2), this.endPoint = new S(r, o).round(2)) : (this.controlPoint1 = S.create(e).round(2), this.controlPoint2 = S.create(t).round(2), this.endPoint = S.create(n).round(2));
  }
  get type() {
    return "C";
  }
  get curve() {
    return new xe(this.start, this.controlPoint1, this.controlPoint2, this.end);
  }
  bbox() {
    return this.curve.bbox();
  }
  closestPoint(e) {
    return this.curve.closestPoint(e);
  }
  closestPointLength(e) {
    return this.curve.closestPointLength(e);
  }
  closestPointNormalizedLength(e) {
    return this.curve.closestPointNormalizedLength(e);
  }
  closestPointTangent(e) {
    return this.curve.closestPointTangent(e);
  }
  length() {
    return this.curve.length();
  }
  divideAt(e, t = {}) {
    const n = this.curve.divideAt(e, t);
    return [new yt(n[0]), new yt(n[1])];
  }
  divideAtLength(e, t = {}) {
    const n = this.curve.divideAtLength(e, t);
    return [new yt(n[0]), new yt(n[1])];
  }
  divideAtT(e) {
    const t = this.curve.divideAtT(e);
    return [new yt(t[0]), new yt(t[1])];
  }
  getSubdivisions() {
    return [];
  }
  pointAt(e) {
    return this.curve.pointAt(e);
  }
  pointAtLength(e) {
    return this.curve.pointAtLength(e);
  }
  tangentAt(e) {
    return this.curve.tangentAt(e);
  }
  tangentAtLength(e) {
    return this.curve.tangentAtLength(e);
  }
  isDifferentiable() {
    if (!this.previousSegment)
      return !1;
    const e = this.start, t = this.controlPoint1, n = this.controlPoint2, i = this.end;
    return !(e.equals(t) && t.equals(n) && n.equals(i));
  }
  scale(e, t, n) {
    return this.controlPoint1.scale(e, t, n), this.controlPoint2.scale(e, t, n), this.end.scale(e, t, n), this;
  }
  rotate(e, t) {
    return this.controlPoint1.rotate(e, t), this.controlPoint2.rotate(e, t), this.end.rotate(e, t), this;
  }
  translate(e, t) {
    return typeof e == "number" ? (this.controlPoint1.translate(e, t), this.controlPoint2.translate(e, t), this.end.translate(e, t)) : (this.controlPoint1.translate(e), this.controlPoint2.translate(e), this.end.translate(e)), this;
  }
  equals(e) {
    return this.start.equals(e.start) && this.end.equals(e.end) && this.controlPoint1.equals(e.controlPoint1) && this.controlPoint2.equals(e.controlPoint2);
  }
  clone() {
    return new yt(this.controlPoint1, this.controlPoint2, this.end);
  }
  toJSON() {
    return {
      type: this.type,
      start: this.start.toJSON(),
      controlPoint1: this.controlPoint1.toJSON(),
      controlPoint2: this.controlPoint2.toJSON(),
      end: this.end.toJSON()
    };
  }
  serialize() {
    const e = this.controlPoint1, t = this.controlPoint2, n = this.end;
    return [this.type, e.x, e.y, t.x, t.y, n.x, n.y].join(" ");
  }
}
(function(s) {
  function e(...t) {
    const n = t.length, i = t[0];
    if (xe.isCurve(i))
      return new s(i);
    if (S.isPointLike(i)) {
      if (n === 3)
        return new s(t[0], t[1], t[2]);
      const o = [];
      for (let a = 0; a < n; a += 3)
        o.push(new s(t[a], t[a + 1], t[a + 2]));
      return o;
    }
    if (n === 6)
      return new s(t[0], t[1], t[2], t[3], t[4], t[5]);
    const r = [];
    for (let o = 0; o < n; o += 6)
      r.push(new s(t[o], t[o + 1], t[o + 2], t[o + 3], t[o + 4], t[o + 5]));
    return r;
  }
  s.create = e;
})(yt || (yt = {}));
function Dr(s, e, t) {
  return {
    x: s * Math.cos(t) - e * Math.sin(t),
    y: s * Math.sin(t) + e * Math.cos(t)
  };
}
function Ah(s, e, t, n, i, r) {
  const o = 0.3333333333333333, a = 2 / 3;
  return [
    o * s + a * t,
    o * e + a * n,
    o * i + a * t,
    o * r + a * n,
    i,
    r
  ];
}
function Pf(s, e, t, n, i, r, o, a, l, c) {
  const u = Math.PI * 120 / 180, f = Math.PI / 180 * (+i || 0);
  let d = [], g, p, m, w, v;
  if (c)
    p = c[0], m = c[1], w = c[2], v = c[3];
  else {
    g = Dr(s, e, -f), s = g.x, e = g.y, g = Dr(a, l, -f), a = g.x, l = g.y;
    const q = (s - a) / 2, _ = (e - l) / 2;
    let I = q * q / (t * t) + _ * _ / (n * n);
    I > 1 && (I = Math.sqrt(I), t = I * t, n = I * n);
    const H = t * t, oe = n * n, ne = (r === o ? -1 : 1) * Math.sqrt(Math.abs((H * oe - H * _ * _ - oe * q * q) / (H * _ * _ + oe * q * q)));
    w = ne * t * _ / n + (s + a) / 2, v = ne * -n * q / t + (e + l) / 2, p = Math.asin((e - v) / n), m = Math.asin((l - v) / n), p = s < w ? Math.PI - p : p, m = a < w ? Math.PI - m : m, p < 0 && (p = Math.PI * 2 + p), m < 0 && (m = Math.PI * 2 + m), o && p > m && (p -= Math.PI * 2), !o && m > p && (m -= Math.PI * 2);
  }
  let y = m - p;
  if (Math.abs(y) > u) {
    const q = m, _ = a, I = l;
    m = p + u * (o && m > p ? 1 : -1), a = w + t * Math.cos(m), l = v + n * Math.sin(m), d = Pf(a, l, t, n, i, 0, o, _, I, [
      m,
      q,
      w,
      v
    ]);
  }
  y = m - p;
  const b = Math.cos(p), x = Math.sin(p), C = Math.cos(m), A = Math.sin(m), P = Math.tan(y / 4), O = 4 / 3 * (t * P), k = 4 / 3 * (n * P), D = [s, e], L = [s + O * x, e - k * b], B = [a + O * A, l - k * C], ee = [a, l];
  if (L[0] = 2 * D[0] - L[0], L[1] = 2 * D[1] - L[1], c)
    return [L, B, ee].concat(d);
  {
    d = [L, B, ee].concat(d).join().split(",");
    const q = [], _ = d.length;
    for (let I = 0; I < _; I += 1)
      q[I] = I % 2 ? Dr(+d[I - 1], +d[I], f).y : Dr(+d[I], +d[I + 1], f).x;
    return q;
  }
}
function Hb(s) {
  if (!s)
    return null;
  const e = "	\n\v\f\r   ᠎             　\u2028\u2029", t = new RegExp(
    "([a-z])[".concat(e, ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[").concat(e, "]*,?[").concat(e, "]*)+)"),
    // eslint-disable-line
    "ig"
  ), n = new RegExp(
    // eslint-disable-next-line
    "(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[".concat(e, "]*,?[").concat(e, "]*"),
    "ig"
  ), i = {
    a: 7,
    c: 6,
    h: 1,
    l: 2,
    m: 2,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    z: 0
  }, r = [];
  return s.replace(t, (o, a, l) => {
    const c = [];
    let u = a.toLowerCase();
    l.replace(n, (d, g) => (g && c.push(+g), d)), u === "m" && c.length > 2 && (r.push([a, ...c.splice(0, 2)]), u = "l", a = a === "m" ? "l" : "L");
    const f = i[u];
    for (; c.length >= f && (r.push([a, ...c.splice(0, f)]), !!f); )
      ;
    return o;
  }), r;
}
function Ub(s) {
  const e = Hb(s);
  if (!e || !e.length)
    return [["M", 0, 0]];
  let t = 0, n = 0, i = 0, r = 0;
  const o = [];
  for (let a = 0, l = e.length; a < l; a += 1) {
    const c = [];
    o.push(c);
    const u = e[a], f = u[0];
    if (f !== f.toUpperCase())
      switch (c[0] = f.toUpperCase(), c[0]) {
        case "A":
          c[1] = u[1], c[2] = u[2], c[3] = u[3], c[4] = u[4], c[5] = u[5], c[6] = +u[6] + t, c[7] = +u[7] + n;
          break;
        case "V":
          c[1] = +u[1] + n;
          break;
        case "H":
          c[1] = +u[1] + t;
          break;
        case "M":
          i = +u[1] + t, r = +u[2] + n;
          for (let d = 1, g = u.length; d < g; d += 1)
            c[d] = +u[d] + (d % 2 ? t : n);
          break;
        default:
          for (let d = 1, g = u.length; d < g; d += 1)
            c[d] = +u[d] + (d % 2 ? t : n);
          break;
      }
    else
      for (let d = 0, g = u.length; d < g; d += 1)
        c[d] = u[d];
    switch (c[0]) {
      case "Z":
        t = +i, n = +r;
        break;
      case "H":
        t = c[1];
        break;
      case "V":
        n = c[1];
        break;
      case "M":
        i = c[c.length - 2], r = c[c.length - 1], t = c[c.length - 2], n = c[c.length - 1];
        break;
      default:
        t = c[c.length - 2], n = c[c.length - 1];
        break;
    }
  }
  return o;
}
function qb(s) {
  const e = Ub(s), t = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null };
  function n(l, c, u) {
    let f, d;
    if (!l)
      return ["C", c.x, c.y, c.x, c.y, c.x, c.y];
    switch (l[0] in { T: 1, Q: 1 } || (c.qx = null, c.qy = null), l[0]) {
      case "M":
        c.X = l[1], c.Y = l[2];
        break;
      case "A":
        return parseFloat(l[1]) === 0 || parseFloat(l[2]) === 0 ? ["L", l[6], l[7]] : ["C"].concat(Pf.apply(0, [c.x, c.y].concat(l.slice(1))));
      case "S":
        return u === "C" || u === "S" ? (f = c.x * 2 - c.bx, d = c.y * 2 - c.by) : (f = c.x, d = c.y), ["C", f, d].concat(l.slice(1));
      case "T":
        return u === "Q" || u === "T" ? (c.qx = c.x * 2 - c.qx, c.qy = c.y * 2 - c.qy) : (c.qx = c.x, c.qy = c.y), ["C"].concat(Ah(c.x, c.y, c.qx, c.qy, l[1], l[2]));
      case "Q":
        return c.qx = l[1], c.qy = l[2], ["C"].concat(Ah(c.x, c.y, l[1], l[2], l[3], l[4]));
      case "H":
        return ["L"].concat(l[1], c.y);
      case "V":
        return ["L"].concat(c.x, l[1]);
    }
    return l;
  }
  function i(l, c) {
    if (l[c].length > 7) {
      l[c].shift();
      const u = l[c];
      for (; u.length; )
        r[c] = "A", c += 1, l.splice(c, 0, ["C"].concat(u.splice(0, 6)));
      l.splice(c, 1), a = e.length;
    }
  }
  const r = [];
  let o = "", a = e.length;
  for (let l = 0; l < a; l += 1) {
    let c = "";
    e[l] && (c = e[l][0]), c !== "C" && (r[l] = c, l > 0 && (o = r[l - 1])), e[l] = n(e[l], t, o), r[l] !== "A" && c === "C" && (r[l] = "C"), i(e, l);
    const u = e[l], f = u.length;
    t.x = u[f - 2], t.y = u[f - 1], t.bx = parseFloat(u[f - 4]) || t.x, t.by = parseFloat(u[f - 3]) || t.y;
  }
  return (!e[0][0] || e[0][0] !== "M") && e.unshift(["M", 0, 0]), e;
}
function Gb(s) {
  return qb(s).map((e) => e.map((t) => typeof t == "string" ? t : le.round(t, 2))).join(",").split(",").join(" ");
}
class F extends $n {
  constructor(e) {
    if (super(), this.PRECISION = 3, this.segments = [], Array.isArray(e))
      if ($.isLine(e[0]) || xe.isCurve(e[0])) {
        let t = null;
        e.forEach((i, r) => {
          r === 0 && this.appendSegment(F.createSegment("M", i.start)), t != null && !t.end.equals(i.start) && this.appendSegment(F.createSegment("M", i.start)), $.isLine(i) ? this.appendSegment(F.createSegment("L", i.end)) : xe.isCurve(i) && this.appendSegment(F.createSegment("C", i.controlPoint1, i.controlPoint2, i.end)), t = i;
        });
      } else
        e.forEach((n) => {
          n.isSegment && this.appendSegment(n);
        });
    else
      e != null && ($.isLine(e) ? (this.appendSegment(F.createSegment("M", e.start)), this.appendSegment(F.createSegment("L", e.end))) : xe.isCurve(e) ? (this.appendSegment(F.createSegment("M", e.start)), this.appendSegment(F.createSegment("C", e.controlPoint1, e.controlPoint2, e.end))) : ke.isPolyline(e) ? e.points && e.points.length && e.points.forEach((t, n) => {
        const i = n === 0 ? F.createSegment("M", t) : F.createSegment("L", t);
        this.appendSegment(i);
      }) : e.isSegment && this.appendSegment(e));
  }
  get start() {
    const e = this.segments, t = e.length;
    if (t === 0)
      return null;
    for (let n = 0; n < t; n += 1) {
      const i = e[n];
      if (i.isVisible)
        return i.start;
    }
    return e[t - 1].end;
  }
  get end() {
    const e = this.segments, t = e.length;
    if (t === 0)
      return null;
    for (let n = t - 1; n >= 0; n -= 1) {
      const i = e[n];
      if (i.isVisible)
        return i.end;
    }
    return e[t - 1].end;
  }
  moveTo(...e) {
    return this.appendSegment(Js.create.call(null, ...e));
  }
  lineTo(...e) {
    return this.appendSegment(Ze.create.call(null, ...e));
  }
  curveTo(...e) {
    return this.appendSegment(yt.create.call(null, ...e));
  }
  arcTo(e, t, n, i, r, o, a) {
    const l = this.end || new S(), c = typeof o == "number" ? fo(l.x, l.y, e, t, n, i, r, o, a) : fo(l.x, l.y, e, t, n, i, r, o.x, o.y);
    if (c != null)
      for (let u = 0, f = c.length; u < f; u += 6)
        this.curveTo(c[u], c[u + 1], c[u + 2], c[u + 3], c[u + 4], c[u + 5]);
    return this;
  }
  quadTo(e, t, n, i) {
    const r = this.end || new S(), o = ["M", r.x, r.y];
    if (typeof e == "number")
      o.push("Q", e, t, n, i);
    else {
      const l = t;
      o.push("Q", e.x, e.y, l.x, l.y);
    }
    const a = F.parse(o.join(" "));
    return this.appendSegment(a.segments.slice(1)), this;
  }
  close() {
    return this.appendSegment(Ws.create());
  }
  drawPoints(e, t = {}) {
    const n = kf(e, t), i = F.parse(n);
    i && i.segments && this.appendSegment(i.segments);
  }
  bbox() {
    const e = this.segments, t = e.length;
    if (t === 0)
      return null;
    let n;
    for (let r = 0; r < t; r += 1) {
      const o = e[r];
      if (o.isVisible) {
        const a = o.bbox();
        a != null && (n = n ? n.union(a) : a);
      }
    }
    if (n != null)
      return n;
    const i = e[t - 1];
    return new R(i.end.x, i.end.y, 0, 0);
  }
  appendSegment(e) {
    const t = this.segments.length;
    let n = t !== 0 ? this.segments[t - 1] : null, i;
    const r = null;
    if (Array.isArray(e))
      for (let o = 0, a = e.length; o < a; o += 1) {
        const l = e[o];
        i = this.prepareSegment(l, n, r), this.segments.push(i), n = i;
      }
    else
      e != null && e.isSegment && (i = this.prepareSegment(e, n, r), this.segments.push(i));
    return this;
  }
  insertSegment(e, t) {
    const n = this.segments.length;
    if (e < 0 && (e = n + e + 1), e > n || e < 0)
      throw new Error("Index out of range.");
    let i, r = null, o = null;
    if (n !== 0 && (e >= 1 ? (r = this.segments[e - 1], o = r.nextSegment) : (r = null, o = this.segments[0])), !Array.isArray(t))
      i = this.prepareSegment(t, r, o), this.segments.splice(e, 0, i);
    else
      for (let a = 0, l = t.length; a < l; a += 1) {
        const c = t[a];
        i = this.prepareSegment(c, r, o), this.segments.splice(e + a, 0, i), r = i;
      }
    return this;
  }
  removeSegment(e) {
    const t = this.fixIndex(e), n = this.segments.splice(t, 1)[0], i = n.previousSegment, r = n.nextSegment;
    return i && (i.nextSegment = r), r && (r.previousSegment = i), n.isSubpathStart && r && this.updateSubpathStartSegment(r), n;
  }
  replaceSegment(e, t) {
    const n = this.fixIndex(e);
    let i;
    const r = this.segments[n];
    let o = r.previousSegment;
    const a = r.nextSegment;
    let l = r.isSubpathStart;
    if (!Array.isArray(t))
      i = this.prepareSegment(t, o, a), this.segments.splice(n, 1, i), l && i.isSubpathStart && (l = !1);
    else {
      this.segments.splice(e, 1);
      for (let c = 0, u = t.length; c < u; c += 1) {
        const f = t[c];
        i = this.prepareSegment(f, o, a), this.segments.splice(e + c, 0, i), o = i, l && i.isSubpathStart && (l = !1);
      }
    }
    l && a && this.updateSubpathStartSegment(a);
  }
  getSegment(e) {
    const t = this.fixIndex(e);
    return this.segments[t];
  }
  fixIndex(e) {
    const t = this.segments.length;
    if (t === 0)
      throw new Error("Path has no segments.");
    let n = e;
    for (; n < 0; )
      n = t + n;
    if (n >= t || n < 0)
      throw new Error("Index out of range.");
    return n;
  }
  segmentAt(e, t = {}) {
    const n = this.segmentIndexAt(e, t);
    return n ? this.getSegment(n) : null;
  }
  segmentAtLength(e, t = {}) {
    const n = this.segmentIndexAtLength(e, t);
    return n ? this.getSegment(n) : null;
  }
  segmentIndexAt(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    const n = le.clamp(e, 0, 1), i = this.getOptions(t), o = this.length(i) * n;
    return this.segmentIndexAtLength(o, i);
  }
  segmentIndexAtLength(e, t = {}) {
    const n = this.segments.length;
    if (n === 0)
      return null;
    let i = !0;
    e < 0 && (i = !1, e = -e);
    const r = this.getPrecision(t), o = this.getSubdivisions(t);
    let a = 0, l = null;
    for (let c = 0; c < n; c += 1) {
      const u = i ? c : n - 1 - c, f = this.segments[u], d = o[u], g = f.length({ precision: r, subdivisions: d });
      if (f.isVisible) {
        if (e <= a + g)
          return u;
        l = u;
      }
      a += g;
    }
    return l;
  }
  getSegmentSubdivisions(e = {}) {
    const t = this.getPrecision(e), n = [];
    for (let i = 0, r = this.segments.length; i < r; i += 1) {
      const a = this.segments[i].getSubdivisions({ precision: t });
      n.push(a);
    }
    return n;
  }
  updateSubpathStartSegment(e) {
    let t = e.previousSegment, n = e;
    for (; n && !n.isSubpathStart; )
      t != null ? n.subpathStartSegment = t.subpathStartSegment : n.subpathStartSegment = null, t = n, n = n.nextSegment;
  }
  prepareSegment(e, t, n) {
    e.previousSegment = t, e.nextSegment = n, t != null && (t.nextSegment = e), n != null && (n.previousSegment = e);
    let i = e;
    return e.isSubpathStart && (e.subpathStartSegment = e, i = n), i != null && this.updateSubpathStartSegment(i), e;
  }
  closestPoint(e, t = {}) {
    const n = this.closestPointT(e, t);
    return n ? this.pointAtT(n) : null;
  }
  closestPointLength(e, t = {}) {
    const n = this.getOptions(t), i = this.closestPointT(e, n);
    return i ? this.lengthAtT(i, n) : 0;
  }
  closestPointNormalizedLength(e, t = {}) {
    const n = this.getOptions(t), i = this.closestPointLength(e, n);
    if (i === 0)
      return 0;
    const r = this.length(n);
    return r === 0 ? 0 : i / r;
  }
  closestPointT(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    const n = this.getPrecision(t), i = this.getSubdivisions(t);
    let r, o = 1 / 0;
    for (let a = 0, l = this.segments.length; a < l; a += 1) {
      const c = this.segments[a], u = i[a];
      if (c.isVisible) {
        const f = c.closestPointT(e, {
          precision: n,
          subdivisions: u
        }), d = c.pointAtT(f), g = le.squaredLength(d, e);
        g < o && (r = { segmentIndex: a, value: f }, o = g);
      }
    }
    return r || { segmentIndex: this.segments.length - 1, value: 1 };
  }
  closestPointTangent(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    const n = this.getPrecision(t), i = this.getSubdivisions(t);
    let r, o = 1 / 0;
    for (let a = 0, l = this.segments.length; a < l; a += 1) {
      const c = this.segments[a], u = i[a];
      if (c.isDifferentiable()) {
        const f = c.closestPointT(e, {
          precision: n,
          subdivisions: u
        }), d = c.pointAtT(f), g = le.squaredLength(d, e);
        g < o && (r = c.tangentAtT(f), o = g);
      }
    }
    return r || null;
  }
  containsPoint(e, t = {}) {
    const n = this.toPolylines(t);
    if (!n)
      return !1;
    let i = 0;
    for (let r = 0, o = n.length; r < o; r += 1)
      n[r].containsPoint(e) && (i += 1);
    return i % 2 === 1;
  }
  pointAt(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    if (e <= 0)
      return this.start.clone();
    if (e >= 1)
      return this.end.clone();
    const n = this.getOptions(t), r = this.length(n) * e;
    return this.pointAtLength(r, n);
  }
  pointAtLength(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    if (e === 0)
      return this.start.clone();
    let n = !0;
    e < 0 && (n = !1, e = -e);
    const i = this.getPrecision(t), r = this.getSubdivisions(t);
    let o, a = 0;
    for (let c = 0, u = this.segments.length; c < u; c += 1) {
      const f = n ? c : u - 1 - c, d = this.segments[f], g = r[f], p = d.length({
        precision: i,
        subdivisions: g
      });
      if (d.isVisible) {
        if (e <= a + p)
          return d.pointAtLength((n ? 1 : -1) * (e - a), {
            precision: i,
            subdivisions: g
          });
        o = d;
      }
      a += p;
    }
    return o ? n ? o.end : o.start : this.segments[this.segments.length - 1].end.clone();
  }
  pointAtT(e) {
    const t = this.segments, n = t.length;
    if (n === 0)
      return null;
    const i = e.segmentIndex;
    if (i < 0)
      return t[0].pointAtT(0);
    if (i >= n)
      return t[n - 1].pointAtT(1);
    const r = le.clamp(e.value, 0, 1);
    return t[i].pointAtT(r);
  }
  divideAt(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    const n = le.clamp(e, 0, 1), i = this.getOptions(t), o = this.length(i) * n;
    return this.divideAtLength(o, i);
  }
  divideAtLength(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    let n = !0;
    e < 0 && (n = !1, e = -e);
    const i = this.getPrecision(t), r = this.getSubdivisions(t);
    let o = 0, a, l, c, u, f;
    for (let C = 0, A = this.segments.length; C < A; C += 1) {
      const P = n ? C : A - 1 - C, O = this.getSegment(P), k = r[P], D = { precision: i, subdivisions: k }, L = O.length(D);
      if (O.isDifferentiable() && (c = O, u = P, e <= o + L)) {
        l = P, a = O.divideAtLength((n ? 1 : -1) * (e - o), D);
        break;
      }
      o += L;
    }
    if (!c)
      return null;
    a || (l = u, f = n ? 1 : 0, a = c.divideAtT(f));
    const d = this.clone(), g = l;
    d.replaceSegment(g, a);
    const p = g;
    let m = g + 1, w = g + 2;
    a[0].isDifferentiable() || (d.removeSegment(p), m -= 1, w -= 1);
    const v = d.getSegment(m).start;
    d.insertSegment(m, F.createSegment("M", v)), w += 1, a[1].isDifferentiable() || (d.removeSegment(w - 1), w -= 1);
    const y = w - p - 1;
    for (let C = w, A = d.segments.length; C < A; C += 1) {
      const P = this.getSegment(C - y), O = d.getSegment(C);
      if (O.type === "Z" && !P.subpathStartSegment.end.equals(O.subpathStartSegment.end)) {
        const k = F.createSegment("L", P.end);
        d.replaceSegment(C, k);
      }
    }
    const b = new F(d.segments.slice(0, m)), x = new F(d.segments.slice(m));
    return [b, x];
  }
  intersectsWithLine(e, t = {}) {
    const n = this.toPolylines(t);
    if (n == null)
      return null;
    let i = null;
    for (let r = 0, o = n.length; r < o; r += 1) {
      const a = n[r], l = e.intersect(a);
      l && (i == null && (i = []), Array.isArray(l) ? i.push(...l) : i.push(l));
    }
    return i;
  }
  isDifferentiable() {
    for (let e = 0, t = this.segments.length; e < t; e += 1)
      if (this.segments[e].isDifferentiable())
        return !0;
    return !1;
  }
  isValid() {
    const e = this.segments;
    return e.length === 0 || e[0].type === "M";
  }
  length(e = {}) {
    if (this.segments.length === 0)
      return 0;
    const t = this.getSubdivisions(e);
    let n = 0;
    for (let i = 0, r = this.segments.length; i < r; i += 1) {
      const o = this.segments[i], a = t[i];
      n += o.length({ subdivisions: a });
    }
    return n;
  }
  lengthAtT(e, t = {}) {
    const n = this.segments.length;
    if (n === 0)
      return 0;
    let i = e.segmentIndex;
    if (i < 0)
      return 0;
    let r = le.clamp(e.value, 0, 1);
    i >= n && (i = n - 1, r = 1);
    const o = this.getPrecision(t), a = this.getSubdivisions(t);
    let l = 0;
    for (let f = 0; f < i; f += 1) {
      const d = this.segments[f], g = a[f];
      l += d.length({ precision: o, subdivisions: g });
    }
    const c = this.segments[i], u = a[i];
    return l += c.lengthAtT(r, { precision: o, subdivisions: u }), l;
  }
  tangentAt(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    const n = le.clamp(e, 0, 1), i = this.getOptions(t), o = this.length(i) * n;
    return this.tangentAtLength(o, i);
  }
  tangentAtLength(e, t = {}) {
    if (this.segments.length === 0)
      return null;
    let n = !0;
    e < 0 && (n = !1, e = -e);
    const i = this.getPrecision(t), r = this.getSubdivisions(t);
    let o, a = 0;
    for (let l = 0, c = this.segments.length; l < c; l += 1) {
      const u = n ? l : c - 1 - l, f = this.segments[u], d = r[u], g = f.length({ precision: i, subdivisions: d });
      if (f.isDifferentiable()) {
        if (e <= a + g)
          return f.tangentAtLength((n ? 1 : -1) * (e - a), {
            precision: i,
            subdivisions: d
          });
        o = f;
      }
      a += g;
    }
    if (o) {
      const l = n ? 1 : 0;
      return o.tangentAtT(l);
    }
    return null;
  }
  tangentAtT(e) {
    const t = this.segments.length;
    if (t === 0)
      return null;
    const n = e.segmentIndex;
    if (n < 0)
      return this.segments[0].tangentAtT(0);
    if (n >= t)
      return this.segments[t - 1].tangentAtT(1);
    const i = le.clamp(e.value, 0, 1);
    return this.segments[n].tangentAtT(i);
  }
  getPrecision(e = {}) {
    return e.precision == null ? this.PRECISION : e.precision;
  }
  getSubdivisions(e = {}) {
    if (e.segmentSubdivisions == null) {
      const t = this.getPrecision(e);
      return this.getSegmentSubdivisions({ precision: t });
    }
    return e.segmentSubdivisions;
  }
  getOptions(e = {}) {
    const t = this.getPrecision(e), n = this.getSubdivisions(e);
    return { precision: t, segmentSubdivisions: n };
  }
  toPoints(e = {}) {
    const t = this.segments, n = t.length;
    if (n === 0)
      return null;
    const i = this.getSubdivisions(e), r = [];
    let o = [];
    for (let a = 0; a < n; a += 1) {
      const l = t[a];
      if (l.isVisible) {
        const c = i[a];
        c.length > 0 ? c.forEach((u) => o.push(u.start)) : o.push(l.start);
      } else
        o.length > 0 && (o.push(t[a - 1].end), r.push(o), o = []);
    }
    return o.length > 0 && (o.push(this.end), r.push(o)), r;
  }
  toPolylines(e = {}) {
    const t = this.toPoints(e);
    return t ? t.map((n) => new ke(n)) : null;
  }
  scale(e, t, n) {
    return this.segments.forEach((i) => i.scale(e, t, n)), this;
  }
  rotate(e, t) {
    return this.segments.forEach((n) => n.rotate(e, t)), this;
  }
  translate(e, t) {
    return typeof e == "number" ? this.segments.forEach((n) => n.translate(e, t)) : this.segments.forEach((n) => n.translate(e)), this;
  }
  clone() {
    const e = new F();
    return this.segments.forEach((t) => e.appendSegment(t.clone())), e;
  }
  equals(e) {
    if (e == null)
      return !1;
    const t = this.segments, n = e.segments, i = t.length;
    if (n.length !== i)
      return !1;
    for (let r = 0; r < i; r += 1) {
      const o = t[r], a = n[r];
      if (o.type !== a.type || !o.equals(a))
        return !1;
    }
    return !0;
  }
  toJSON() {
    return this.segments.map((e) => e.toJSON());
  }
  serialize() {
    if (!this.isValid())
      throw new Error("Invalid path segments.");
    return this.segments.map((e) => e.serialize()).join(" ");
  }
  toString() {
    return this.serialize();
  }
}
(function(s) {
  function e(t) {
    return t != null && t instanceof s;
  }
  s.isPath = e;
})(F || (F = {}));
(function(s) {
  function e(n) {
    if (!n)
      return new s();
    const i = new s(), r = /(?:[a-zA-Z] *)(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)? *,? *)|(?:-?\.\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\d|-|\.)/g, o = s.normalize(n).match(r);
    if (o != null)
      for (let a = 0, l = o.length; a < l; a += 1) {
        const c = o[a], u = /(?:[a-zA-Z])|(?:(?:-?\d+(?:\.\d+)?(?:e[-+]?\d+)?))|(?:(?:-?\.\d+))/g, f = c.match(u);
        if (f != null) {
          const d = f[0], g = f.slice(1).map((m) => +m), p = t.call(null, d, ...g);
          i.appendSegment(p);
        }
      }
    return i;
  }
  s.parse = e;
  function t(n, ...i) {
    if (n === "M")
      return Js.create.call(null, ...i);
    if (n === "L")
      return Ze.create.call(null, ...i);
    if (n === "C")
      return yt.create.call(null, ...i);
    if (n === "z" || n === "Z")
      return Ws.create();
    throw new Error('Invalid path segment type "'.concat(n, '"'));
  }
  s.createSegment = t;
})(F || (F = {}));
(function(s) {
  s.normalize = Gb, s.isValid = Fb, s.drawArc = Vb, s.drawPoints = kf, s.arcToCurves = fo;
})(F || (F = {}));
class _e {
  constructor(e) {
    this.options = Object.assign({}, e), this.data = this.options.data || {}, this.register = this.register.bind(this), this.unregister = this.unregister.bind(this);
  }
  get names() {
    return Object.keys(this.data);
  }
  register(e, t, n = !1) {
    if (typeof e == "object") {
      Object.entries(e).forEach(([o, a]) => {
        this.register(o, a, t);
      });
      return;
    }
    this.exist(e) && !n && !On.isApplyingHMR() && this.onDuplicated(e);
    const i = this.options.process, r = i ? G(i, this, e, t) : t;
    return this.data[e] = r, r;
  }
  unregister(e) {
    const t = e ? this.data[e] : null;
    return delete this.data[e], t;
  }
  get(e) {
    return e ? this.data[e] : null;
  }
  exist(e) {
    return e ? this.data[e] != null : !1;
  }
  onDuplicated(e) {
    try {
      throw this.options.onConflict && G(this.options.onConflict, this, e), new Error("".concat(gc(this.options.type), " with name '").concat(e, "' already registered."));
    } catch (t) {
      throw t;
    }
  }
  onNotFound(e, t) {
    throw new Error(this.getSpellingSuggestion(e, t));
  }
  getSpellingSuggestion(e, t) {
    const n = this.getSpellingSuggestionForName(e), i = t ? "".concat(t, " ").concat(op(this.options.type)) : this.options.type;
    return (
      // eslint-disable-next-line
      "".concat(gc(i), " with name '").concat(e, "' does not exist.").concat(n ? " Did you mean '".concat(n, "'?") : "")
    );
  }
  getSpellingSuggestionForName(e) {
    return qy(e, Object.keys(this.data), (t) => t);
  }
}
(function(s) {
  function e(t) {
    return new s(t);
  }
  s.create = e;
})(_e || (_e = {}));
const Wb = {
  color: "#aaaaaa",
  thickness: 1,
  markup: "rect",
  update(s, e) {
    const t = e.thickness * e.sx, n = e.thickness * e.sy;
    ue(s, {
      width: t,
      height: n,
      rx: t,
      ry: n,
      fill: e.color
    });
  }
}, Jb = {
  color: "#aaaaaa",
  thickness: 1,
  markup: "rect",
  update(s, e) {
    const t = e.sx <= 1 ? e.thickness * e.sx : e.thickness;
    ue(s, {
      width: t,
      height: t,
      rx: t,
      ry: t,
      fill: e.color
    });
  }
}, Yb = {
  color: "rgba(224,224,224,1)",
  thickness: 1,
  markup: "path",
  update(s, e) {
    let t;
    const n = e.width, i = e.height, r = e.thickness;
    n - r >= 0 && i - r >= 0 ? t = ["M", n, 0, "H0 M0 0 V0", i].join(" ") : t = "M 0 0 0 0", ue(s, {
      d: t,
      stroke: e.color,
      "stroke-width": e.thickness
    });
  }
}, Xb = [
  {
    color: "rgba(224,224,224,1)",
    thickness: 1,
    markup: "path",
    update(s, e) {
      let t;
      const n = e.width, i = e.height, r = e.thickness;
      n - r >= 0 && i - r >= 0 ? t = ["M", n, 0, "H0 M0 0 V0", i].join(" ") : t = "M 0 0 0 0", ue(s, {
        d: t,
        stroke: e.color,
        "stroke-width": e.thickness
      });
    }
  },
  {
    color: "rgba(224,224,224,0.2)",
    thickness: 3,
    factor: 4,
    markup: "path",
    update(s, e) {
      let t;
      const n = e.factor || 1, i = e.width * n, r = e.height * n, o = e.thickness;
      i - o >= 0 && r - o >= 0 ? t = ["M", i, 0, "H0 M0 0 V0", r].join(" ") : t = "M 0 0 0 0", e.width = i, e.height = r, ue(s, {
        d: t,
        stroke: e.color,
        "stroke-width": e.thickness
      });
    }
  }
], Zb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  dot: Wb,
  doubleMesh: Xb,
  fixedDot: Jb,
  mesh: Yb
}, Symbol.toStringTag, { value: "Module" }));
class Sn {
  constructor() {
    this.patterns = {}, this.root = U.create(lo(), {
      width: "100%",
      height: "100%"
    }, [jt("defs")]).node;
  }
  add(e, t) {
    const n = this.root.childNodes[0];
    n && n.appendChild(t), this.patterns[e] = t, U.create("rect", {
      width: "100%",
      height: "100%",
      fill: "url(#".concat(e, ")")
    }).appendTo(this.root);
  }
  get(e) {
    return this.patterns[e];
  }
  has(e) {
    return this.patterns[e] != null;
  }
}
(function(s) {
  s.presets = Zb, s.registry = _e.create({
    type: "grid"
  }), s.registry.register(s.presets, !0);
})(Sn || (Sn = {}));
const _f = function(s) {
  const e = document.createElement("canvas"), t = s.width, n = s.height;
  e.width = t * 2, e.height = n;
  const i = e.getContext("2d");
  return i.drawImage(s, 0, 0, t, n), i.translate(2 * t, 0), i.scale(-1, 1), i.drawImage(s, 0, 0, t, n), e;
}, Of = function(s) {
  const e = document.createElement("canvas"), t = s.width, n = s.height;
  e.width = t, e.height = n * 2;
  const i = e.getContext("2d");
  return i.drawImage(s, 0, 0, t, n), i.translate(0, 2 * n), i.scale(1, -1), i.drawImage(s, 0, 0, t, n), e;
}, Tf = function(s) {
  const e = document.createElement("canvas"), t = s.width, n = s.height;
  e.width = 2 * t, e.height = 2 * n;
  const i = e.getContext("2d");
  return i.drawImage(s, 0, 0, t, n), i.setTransform(-1, 0, 0, -1, e.width, e.height), i.drawImage(s, 0, 0, t, n), i.setTransform(-1, 0, 0, 1, e.width, 0), i.drawImage(s, 0, 0, t, n), i.setTransform(1, 0, 0, -1, 0, e.height), i.drawImage(s, 0, 0, t, n), e;
}, Kb = function(s, e) {
  const t = s.width, n = s.height, i = document.createElement("canvas");
  i.width = t * 3, i.height = n * 3;
  const r = i.getContext("2d"), o = e.angle != null ? -e.angle : -20, a = ce.toRad(o), l = i.width / 4, c = i.height / 4;
  for (let u = 0; u < 4; u += 1)
    for (let f = 0; f < 4; f += 1)
      (u + f) % 2 > 0 && (r.setTransform(1, 0, 0, 1, (2 * u - 1) * l, (2 * f - 1) * c), r.rotate(a), r.drawImage(s, -t / 2, -n / 2, t, n));
  return i;
}, Qb = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  flipX: _f,
  flipXY: Tf,
  flipY: Of,
  watermark: Kb
}, Symbol.toStringTag, { value: "Module" }));
var er;
(function(s) {
  s.presets = Object.assign({}, Qb), s.presets["flip-x"] = _f, s.presets["flip-y"] = Of, s.presets["flip-xy"] = Tf, s.registry = _e.create({
    type: "background pattern"
  }), s.registry.register(s.presets, !0);
})(er || (er = {}));
function Ql(s, e) {
  return s != null ? s : e;
}
function ze(s, e) {
  return s != null && Number.isFinite(s) ? s : e;
}
function e4(s = {}) {
  const e = Ql(s.color, "blue"), t = ze(s.width, 1), n = ze(s.margin, 2), i = ze(s.opacity, 1), r = n, o = n + t;
  return '\n    <filter>\n      <feFlood flood-color="'.concat(e, '" flood-opacity="').concat(i, '" result="colored"/>\n      <feMorphology in="SourceAlpha" result="morphedOuter" operator="dilate" radius="').concat(o, '" />\n      <feMorphology in="SourceAlpha" result="morphedInner" operator="dilate" radius="').concat(r, '" />\n      <feComposite result="morphedOuterColored" in="colored" in2="morphedOuter" operator="in"/>\n      <feComposite operator="xor" in="morphedOuterColored" in2="morphedInner" result="outline"/>\n      <feMerge>\n        <feMergeNode in="outline"/>\n        <feMergeNode in="SourceGraphic"/>\n      </feMerge>\n    </filter>\n  ').trim();
}
function t4(s = {}) {
  const e = Ql(s.color, "red"), t = ze(s.blur, 0), n = ze(s.width, 1), i = ze(s.opacity, 1);
  return '\n      <filter>\n        <feFlood flood-color="'.concat(e, '" flood-opacity="').concat(i, '" result="colored"/>\n        <feMorphology result="morphed" in="SourceGraphic" operator="dilate" radius="').concat(n, '"/>\n        <feComposite result="composed" in="colored" in2="morphed" operator="in"/>\n        <feGaussianBlur result="blured" in="composed" stdDeviation="').concat(t, '"/>\n        <feBlend in="SourceGraphic" in2="blured" mode="normal"/>\n      </filter>\n    ').trim();
}
function n4(s = {}) {
  const e = ze(s.x, 2), t = s.y != null && Number.isFinite(s.y) ? [e, s.y] : e;
  return '\n    <filter>\n      <feGaussianBlur stdDeviation="'.concat(t, '"/>\n    </filter>\n  ').trim();
}
function s4(s = {}) {
  const e = ze(s.dx, 0), t = ze(s.dy, 0), n = Ql(s.color, "black"), i = ze(s.blur, 4), r = ze(s.opacity, 1);
  return "SVGFEDropShadowElement" in window ? '<filter>\n         <feDropShadow stdDeviation="'.concat(i, '" dx="').concat(e, '" dy="').concat(t, '" flood-color="').concat(n, '" flood-opacity="').concat(r, '" />\n       </filter>').trim() : '<filter>\n         <feGaussianBlur in="SourceAlpha" stdDeviation="'.concat(i, '" />\n         <feOffset dx="').concat(e, '" dy="').concat(t, '" result="offsetblur" />\n         <feFlood flood-color="').concat(n, '" />\n         <feComposite in2="offsetblur" operator="in" />\n         <feComponentTransfer>\n           <feFuncA type="linear" slope="').concat(r, '" />\n         </feComponentTransfer>\n         <feMerge>\n           <feMergeNode/>\n           <feMergeNode in="SourceGraphic"/>\n         </feMerge>\n       </filter>').trim();
}
function i4(s = {}) {
  const e = ze(s.amount, 1), t = 0.2126 + 0.7874 * (1 - e), n = 0.7152 - 0.7152 * (1 - e), i = 0.0722 - 0.0722 * (1 - e), r = 0.2126 - 0.2126 * (1 - e), o = 0.7152 + 0.2848 * (1 - e), a = 0.0722 - 0.0722 * (1 - e), l = 0.2126 - 0.2126 * (1 - e), c = 0.0722 + 0.9278 * (1 - e);
  return '\n    <filter>\n      <feColorMatrix type="matrix" values="'.concat(t, " ").concat(n, " ").concat(i, " 0 0 ").concat(r, " ").concat(o, " ").concat(a, " 0 0 ").concat(l, " ").concat(n, " ").concat(c, ' 0 0 0 0 0 1 0"/>\n    </filter>\n  ').trim();
}
function r4(s = {}) {
  const e = ze(s.amount, 1), t = 0.393 + 0.607 * (1 - e), n = 0.769 - 0.769 * (1 - e), i = 0.189 - 0.189 * (1 - e), r = 0.349 - 0.349 * (1 - e), o = 0.686 + 0.314 * (1 - e), a = 0.168 - 0.168 * (1 - e), l = 0.272 - 0.272 * (1 - e), c = 0.534 - 0.534 * (1 - e), u = 0.131 + 0.869 * (1 - e);
  return '\n      <filter>\n        <feColorMatrix type="matrix" values="'.concat(t, " ").concat(n, " ").concat(i, " 0 0 ").concat(r, " ").concat(o, " ").concat(a, " 0 0 ").concat(l, " ").concat(c, " ").concat(u, ' 0 0 0 0 0 1 0"/>\n      </filter>\n    ').trim();
}
function o4(s = {}) {
  const e = ze(s.amount, 1);
  return '\n      <filter>\n        <feColorMatrix type="saturate" values="'.concat(1 - e, '"/>\n      </filter>\n    ').trim();
}
function a4(s = {}) {
  const e = ze(s.angle, 0);
  return '\n      <filter>\n        <feColorMatrix type="hueRotate" values="'.concat(e, '"/>\n      </filter>\n    ').trim();
}
function l4(s = {}) {
  const e = ze(s.amount, 1), t = 1 - e;
  return '\n      <filter>\n        <feComponentTransfer>\n          <feFuncR type="table" tableValues="'.concat(e, " ").concat(t, '"/>\n          <feFuncG type="table" tableValues="').concat(e, " ").concat(t, '"/>\n          <feFuncB type="table" tableValues="').concat(e, " ").concat(t, '"/>\n        </feComponentTransfer>\n      </filter>\n    ').trim();
}
function c4(s = {}) {
  const e = ze(s.amount, 1);
  return '\n    <filter>\n      <feComponentTransfer>\n        <feFuncR type="linear" slope="'.concat(e, '"/>\n        <feFuncG type="linear" slope="').concat(e, '"/>\n        <feFuncB type="linear" slope="').concat(e, '"/>\n      </feComponentTransfer>\n    </filter>\n  ').trim();
}
function h4(s = {}) {
  const e = ze(s.amount, 1), t = 0.5 - e / 2;
  return '\n    <filter>\n     <feComponentTransfer>\n        <feFuncR type="linear" slope="'.concat(e, '" intercept="').concat(t, '"/>\n        <feFuncG type="linear" slope="').concat(e, '" intercept="').concat(t, '"/>\n        <feFuncB type="linear" slope="').concat(e, '" intercept="').concat(t, '"/>\n      </feComponentTransfer>\n    </filter>\n  ').trim();
}
const u4 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  blur: n4,
  brightness: c4,
  contrast: h4,
  dropShadow: s4,
  grayScale: i4,
  highlight: t4,
  hueRotate: a4,
  invert: l4,
  outline: e4,
  saturate: o4,
  sepia: r4
}, Symbol.toStringTag, { value: "Module" }));
var Ys;
(function(s) {
  s.presets = u4, s.registry = _e.create({
    type: "filter"
  }), s.registry.register(s.presets, !0);
})(Ys || (Ys = {}));
const d4 = {
  xlinkHref: "xlink:href",
  xlinkShow: "xlink:show",
  xlinkRole: "xlink:role",
  xlinkType: "xlink:type",
  xlinkArcrole: "xlink:arcrole",
  xlinkTitle: "xlink:title",
  xlinkActuate: "xlink:actuate",
  xmlSpace: "xml:space",
  xmlBase: "xml:base",
  xmlLang: "xml:lang",
  preserveAspectRatio: "preserveAspectRatio",
  requiredExtension: "requiredExtension",
  requiredFeatures: "requiredFeatures",
  systemLanguage: "systemLanguage",
  externalResourcesRequired: "externalResourceRequired"
}, f4 = {
  // We do not set `ref` attribute directly on an element.
  // The attribute itself does not qualify for relative positioning.
}, Lf = {
  position: zo("x", "width", "origin")
}, Df = {
  position: zo("y", "height", "origin")
}, g4 = {
  position: zo("x", "width", "corner")
}, p4 = {
  position: zo("y", "height", "corner")
}, Nf = {
  set: Ln("width", "width")
}, If = {
  set: Ln("height", "height")
}, m4 = {
  set: Ln("rx", "width")
}, w4 = {
  set: Ln("ry", "height")
}, jf = {
  set: ((s) => {
    const e = Ln(s, "width"), t = Ln(s, "height");
    return function(n, i) {
      const r = i.refBBox, o = r.height > r.width ? e : t;
      return G(o, this, n, i);
    };
  })("r")
}, y4 = {
  set(s, { refBBox: e }) {
    let t = parseFloat(s);
    const n = ln(s);
    n && (t /= 100);
    const i = Math.sqrt(e.height * e.height + e.width * e.width);
    let r;
    return Number.isFinite(t) && (n || t >= 0 && t <= 1 ? r = t * i : r = Math.max(t + i, 0)), { r };
  }
}, b4 = {
  set: Ln("cx", "width")
}, v4 = {
  set: Ln("cy", "height")
}, Rf = {
  set: Ff({ resetOffset: !0 })
}, x4 = {
  set: Ff({ resetOffset: !1 })
}, Bf = {
  set: zf({ resetOffset: !0 })
}, C4 = {
  set: zf({ resetOffset: !1 })
}, E4 = jf, S4 = Rf, A4 = Bf, M4 = Lf, k4 = Df, P4 = Nf, _4 = If;
function zo(s, e, t) {
  return (n, { refBBox: i }) => {
    if (n == null)
      return null;
    let r = parseFloat(n);
    const o = ln(n);
    o && (r /= 100);
    let a;
    if (Number.isFinite(r)) {
      const c = i[t];
      o || r > 0 && r < 1 ? a = c[s] + i[e] * r : a = c[s] + r;
    }
    const l = new S();
    return l[s] = a || 0, l;
  };
}
function Ln(s, e) {
  return function(t, { refBBox: n }) {
    let i = parseFloat(t);
    const r = ln(t);
    r && (i /= 100);
    const o = {};
    if (Number.isFinite(i)) {
      const a = r || i >= 0 && i <= 1 ? i * n[e] : Math.max(i + n[e], 0);
      o[s] = a;
    }
    return o;
  };
}
function $f(s, e) {
  const t = "x6-shape", n = e && e.resetOffset;
  return function(i, { elem: r, refBBox: o }) {
    let a = ds(r, t);
    if (!a || a.value !== i) {
      const m = s(i);
      a = {
        value: i,
        shape: m,
        shapeBBox: m.bbox()
      }, ds(r, t, a);
    }
    const l = a.shape.clone(), c = a.shapeBBox.clone(), u = c.getOrigin(), f = o.getOrigin();
    c.x = f.x, c.y = f.y;
    const d = o.getMaxScaleToFit(c, f), g = c.width === 0 || o.width === 0 ? 1 : d.sx, p = c.height === 0 || o.height === 0 ? 1 : d.sy;
    return l.scale(g, p, u), n && l.translate(-u.x, -u.y), l;
  };
}
function Ff(s) {
  function e(n) {
    return F.parse(n);
  }
  const t = $f(e, s);
  return (n, i) => ({
    d: t(n, i).serialize()
  });
}
function zf(s) {
  const e = $f((t) => new ke(t), s);
  return (t, n) => ({
    points: e(t, n).serialize()
  });
}
const O4 = {
  qualify: un,
  set(s, { view: e }) {
    return "url(#".concat(e.graph.defineGradient(s), ")");
  }
}, T4 = {
  qualify: un,
  set(s, { view: e }) {
    const t = e.cell, n = Object.assign({}, s);
    if (t.isEdge() && n.type === "linearGradient") {
      const i = e, r = i.sourcePoint, o = i.targetPoint;
      n.id = "gradient-".concat(n.type, "-").concat(t.id), n.attrs = Object.assign(Object.assign({}, n.attrs), { x1: r.x, y1: r.y, x2: o.x, y2: o.y, gradientUnits: "userSpaceOnUse" }), e.graph.defs.remove(n.id);
    }
    return "url(#".concat(e.graph.defineGradient(n), ")");
  }
}, Vf = {
  qualify(s, { attrs: e }) {
    return e.textWrap == null || !un(e.textWrap);
  },
  set(s, { view: e, elem: t, attrs: n }) {
    const i = "x6-text", r = ds(t, i), o = (u) => {
      try {
        return JSON.parse(u);
      } catch (f) {
        return u;
      }
    }, a = {
      x: n.x,
      eol: n.eol,
      annotations: o(n.annotations),
      textPath: o(n["text-path"] || n.textPath),
      textVerticalAnchor: n["text-vertical-anchor"] || n.textVerticalAnchor,
      displayEmpty: (n["display-empty"] || n.displayEmpty) === "true",
      lineHeight: n["line-height"] || n.lineHeight
    }, l = n["font-size"] || n.fontSize, c = JSON.stringify([s, a]);
    if (l && t.setAttribute("font-size", l), r == null || r !== c) {
      const u = a.textPath;
      if (u != null && typeof u == "object") {
        const f = u.selector;
        if (typeof f == "string") {
          const d = e.find(f)[0];
          d instanceof SVGPathElement && (Jl(d), a.textPath = Object.assign({ "xlink:href": "#".concat(d.id) }, u));
        }
      }
      bf(t, "".concat(s), a), ds(t, i, c);
    }
  }
}, L4 = {
  qualify: un,
  set(s, { view: e, elem: t, attrs: n, refBBox: i }) {
    const r = s, o = r.width || 0;
    ln(o) ? i.width *= parseFloat(o) / 100 : o <= 0 ? i.width += o : i.width = o;
    const a = r.height || 0;
    ln(a) ? i.height *= parseFloat(a) / 100 : a <= 0 ? i.height += a : i.height = a;
    let l, c = r.text;
    c == null && (c = n.text || (t == null ? void 0 : t.textContent)), c != null ? l = vf("".concat(c), i, {
      "font-weight": n["font-weight"] || n.fontWeight,
      "font-size": n["font-size"] || n.fontSize,
      "font-family": n["font-family"] || n.fontFamily,
      lineHeight: n.lineHeight
    }, {
      // svgDocument: view.graph.view.svg,
      ellipsis: r.ellipsis
      // hyphen: info.hyphen as string,
      // breakWord: info.breakWord as boolean,
    }) : l = "", G(Vf.set, this, l, {
      view: e,
      elem: t,
      attrs: n,
      refBBox: i,
      cell: e.cell
    });
  }
}, mi = (s, { attrs: e }) => e.text !== void 0, D4 = {
  qualify: mi
}, N4 = {
  qualify: mi
}, I4 = {
  qualify: mi
}, j4 = {
  qualify: mi
}, R4 = {
  qualify: mi
}, B4 = {
  qualify: mi
}, $4 = {
  qualify(s, { elem: e }) {
    return e instanceof SVGElement;
  },
  set(s, { elem: e }) {
    const t = "x6-title", n = "".concat(s), i = ds(e, t);
    if (i == null || i !== n) {
      ds(e, t, n);
      const r = e.firstChild;
      if (r && r.tagName.toUpperCase() === "TITLE") {
        const o = r;
        o.textContent = n;
      } else {
        const o = document.createElementNS(e.namespaceURI, "title");
        o.textContent = n, e.insertBefore(o, r);
      }
    }
  }
}, F4 = {
  offset: Hf("x", "width", "right")
}, z4 = {
  offset: Hf("y", "height", "bottom")
}, V4 = {
  offset(s, { refBBox: e }) {
    return s ? { x: -e.x, y: -e.y } : { x: 0, y: 0 };
  }
};
function Hf(s, e, t) {
  return (n, { refBBox: i }) => {
    const r = new S();
    let o;
    return n === "middle" ? o = i[e] / 2 : n === t ? o = i[e] : typeof n == "number" && Number.isFinite(n) ? o = n > -1 && n < 1 ? -i[e] * n : -n : ln(n) ? o = i[e] * parseFloat(n) / 100 : o = 0, r[s] = -(i[s] + o), r;
  };
}
const H4 = {
  qualify: un,
  set(s, { elem: e }) {
    wr(e, s);
  }
}, U4 = {
  set(s, { elem: e }) {
    e.innerHTML = "".concat(s);
  }
}, q4 = {
  qualify: un,
  set(s, { view: e }) {
    return "url(#".concat(e.graph.defineFilter(s), ")");
  }
}, G4 = {
  set(s) {
    return s != null && typeof s == "object" && s.id ? s.id : s;
  }
};
function Fn(s, e, t) {
  let n, i;
  typeof e == "object" ? (n = e.x, i = e.y) : (n = e, i = t);
  const r = F.parse(s), o = r.bbox();
  if (o) {
    let a = -o.height / 2 - o.y, l = -o.width / 2 - o.x;
    typeof n == "number" && (l -= n), typeof i == "number" && (a -= i), r.translate(l, a);
  }
  return r.serialize();
}
var Uf = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
const W4 = (s) => {
  var { size: e, width: t, height: n, offset: i, open: r } = s, o = Uf(s, ["size", "width", "height", "offset", "open"]);
  return qf({ size: e, width: t, height: n, offset: i }, r === !0, !0, void 0, o);
}, J4 = (s) => {
  var { size: e, width: t, height: n, offset: i, factor: r } = s, o = Uf(s, ["size", "width", "height", "offset", "factor"]);
  return qf({ size: e, width: t, height: n, offset: i }, !1, !1, r, o);
};
function qf(s, e, t, n = 3 / 4, i = {}) {
  const r = s.size || 10, o = s.width || r, a = s.height || r, l = new F(), c = {};
  if (e)
    l.moveTo(o, 0).lineTo(0, a / 2).lineTo(o, a), c.fill = "none";
  else {
    if (l.moveTo(0, a / 2), l.lineTo(o, 0), !t) {
      const u = Ct(n, 0, 1);
      l.lineTo(o * u, a / 2);
    }
    l.lineTo(o, a), l.close();
  }
  return Object.assign(Object.assign(Object.assign({}, c), i), { tagName: "path", d: Fn(l.serialize(), {
    x: s.offset != null ? s.offset : -o / 2
  }) });
}
var Y4 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
const X4 = (s) => {
  var { size: e, width: t, height: n, offset: i } = s, r = Y4(s, ["size", "width", "height", "offset"]);
  const o = e || 10, a = t || o, l = n || o, c = new F();
  return c.moveTo(0, l / 2).lineTo(a / 2, 0).lineTo(a, l / 2).lineTo(a / 2, l).close(), Object.assign(Object.assign({}, r), { tagName: "path", d: Fn(c.serialize(), i == null ? -a / 2 : i) });
};
var Z4 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
const K4 = (s) => {
  var { d: e, offsetX: t, offsetY: n } = s, i = Z4(s, ["d", "offsetX", "offsetY"]);
  return Object.assign(Object.assign({}, i), { tagName: "path", d: Fn(e, t, n) });
};
var Q4 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
const ev = (s) => {
  var { size: e, width: t, height: n, offset: i } = s, r = Q4(s, ["size", "width", "height", "offset"]);
  const o = e || 10, a = t || o, l = n || o, c = new F();
  return c.moveTo(0, 0).lineTo(a, l).moveTo(0, l).lineTo(a, 0), Object.assign(Object.assign({}, r), { tagName: "path", fill: "none", d: Fn(c.serialize(), i || -a / 2) });
};
var tv = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
const nv = (s) => {
  var { width: e, height: t, offset: n, open: i, flip: r } = s, o = tv(s, ["width", "height", "offset", "open", "flip"]);
  let a = t || 6;
  const l = e || 10, c = i === !0, u = r === !0, f = Object.assign(Object.assign({}, o), { tagName: "path" });
  u && (a = -a);
  const d = new F();
  return d.moveTo(0, a).lineTo(l, 0), c ? f.fill = "none" : (d.lineTo(l, a), d.close()), f.d = Fn(d.serialize(), {
    x: n || -l / 2,
    y: a / 2
  }), f;
};
var Gf = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
const Wf = (s) => {
  var { r: e } = s, t = Gf(s, ["r"]);
  const n = e || 5;
  return Object.assign(Object.assign({ cx: n }, t), { tagName: "circle", r: n });
}, sv = (s) => {
  var { r: e } = s, t = Gf(s, ["r"]);
  const n = e || 5, i = new F();
  return i.moveTo(n, 0).lineTo(n, n * 2), i.moveTo(0, n).lineTo(n * 2, n), {
    children: [
      Object.assign(Object.assign({}, Wf({ r: n })), { fill: "none" }),
      Object.assign(Object.assign({}, t), { tagName: "path", d: Fn(i.serialize(), -n) })
    ]
  };
};
var iv = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
const rv = (s) => {
  var { rx: e, ry: t } = s, n = iv(s, ["rx", "ry"]);
  const i = e || 5, r = t || 5;
  return Object.assign(Object.assign({ cx: i }, n), { tagName: "ellipse", rx: i, ry: r });
}, ov = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  async: nv,
  block: W4,
  circle: Wf,
  circlePlus: sv,
  classic: J4,
  cross: ev,
  diamond: X4,
  ellipse: rv,
  path: K4
}, Symbol.toStringTag, { value: "Module" }));
var Dn;
(function(s) {
  s.presets = ov, s.registry = _e.create({
    type: "marker"
  }), s.registry.register(s.presets, !0);
})(Dn || (Dn = {}));
(function(s) {
  s.normalize = Fn;
})(Dn || (Dn = {}));
var av = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
function ec(s) {
  return typeof s == "string" || un(s);
}
const lv = {
  qualify: ec,
  set(s, { view: e, attrs: t }) {
    return tc("marker-start", s, e, t);
  }
}, cv = {
  qualify: ec,
  set(s, { view: e, attrs: t }) {
    return tc("marker-end", s, e, t, {
      transform: "rotate(180)"
    });
  }
}, hv = {
  qualify: ec,
  set(s, { view: e, attrs: t }) {
    return tc("marker-mid", s, e, t);
  }
};
function tc(s, e, t, n, i = {}) {
  const r = typeof e == "string" ? { name: e } : e, { name: o, args: a } = r, l = av(r, ["name", "args"]);
  let c = l;
  if (o && typeof o == "string") {
    const f = Dn.registry.get(o);
    if (f)
      c = f(Object.assign(Object.assign({}, l), a));
    else
      return Dn.registry.onNotFound(o);
  }
  const u = Object.assign(Object.assign(Object.assign({}, uv(n, s)), i), c);
  return {
    [s]: "url(#".concat(t.graph.defineMarker(u), ")")
  };
}
function uv(s, e) {
  const t = {}, n = s.stroke;
  typeof n == "string" && (t.stroke = n, t.fill = n);
  let i = s.strokeOpacity;
  if (i == null && (i = s["stroke-opacity"]), i == null && (i = s.opacity), i != null && (t["stroke-opacity"] = i, t["fill-opacity"] = i), e !== "marker-mid") {
    const r = parseFloat(s.strokeWidth || s["stroke-width"]);
    if (Number.isFinite(r) && r > 1) {
      const o = Math.ceil(r / 2);
      t.refX = e === "marker-start" ? o : -o;
    }
  }
  return t;
}
const yr = (s, { view: e }) => e.cell.isEdge(), dv = {
  qualify: yr,
  set(s, e) {
    var t, n, i, r;
    const o = e.view, a = s.reverse || !1, l = s.stubs || 0;
    let c;
    if (Number.isFinite(l) && l !== 0)
      if (a) {
        let u, f;
        const d = o.getConnectionLength() || 0;
        l < 0 ? (u = (d + l) / 2, f = -l) : (u = l, f = d - l * 2);
        const g = o.getConnection();
        c = (r = (i = (n = (t = g == null ? void 0 : g.divideAtLength(u)) === null || t === void 0 ? void 0 : t[1]) === null || n === void 0 ? void 0 : n.divideAtLength(f)) === null || i === void 0 ? void 0 : i[0]) === null || r === void 0 ? void 0 : r.serialize();
      } else {
        let u;
        l < 0 ? u = ((o.getConnectionLength() || 0) + l) / 2 : u = l;
        const f = o.getConnection();
        if (f) {
          const d = f.divideAtLength(u), g = f.divideAtLength(-u);
          d && g && (c = "".concat(d[0].serialize(), " ").concat(g[1].serialize()));
        }
      }
    return { d: c || o.getConnectionPathData() };
  }
}, Jf = {
  qualify: yr,
  set: Vo("getTangentAtLength", { rotate: !0 })
}, fv = {
  qualify: yr,
  set: Vo("getTangentAtLength", { rotate: !1 })
}, Yf = {
  qualify: yr,
  set: Vo("getTangentAtRatio", { rotate: !0 })
}, gv = {
  qualify: yr,
  set: Vo("getTangentAtRatio", { rotate: !1 })
}, pv = Jf, mv = Yf;
function Vo(s, e) {
  const t = { x: 1, y: 0 };
  return (n, i) => {
    let r, o;
    const a = i.view, l = a[s](Number(n));
    return l ? (o = e.rotate ? l.vector().vectorAngle(t) : 0, r = l.start) : (r = a.path.start, o = 0), o === 0 ? { transform: "translate(".concat(r.x, ",").concat(r.y, "')") } : {
      transform: "translate(".concat(r.x, ",").concat(r.y, "') rotate(").concat(o, ")")
    };
  };
}
const wv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  annotations: j4,
  atConnectionLength: pv,
  atConnectionLengthIgnoreGradient: fv,
  atConnectionLengthKeepGradient: Jf,
  atConnectionRatio: mv,
  atConnectionRatioIgnoreGradient: gv,
  atConnectionRatioKeepGradient: Yf,
  connection: dv,
  displayEmpty: B4,
  eol: R4,
  fill: O4,
  filter: q4,
  html: U4,
  lineHeight: D4,
  port: G4,
  ref: f4,
  refCx: b4,
  refCy: v4,
  refD: S4,
  refDKeepOffset: x4,
  refDResetOffset: Rf,
  refDx: g4,
  refDy: p4,
  refHeight: If,
  refHeight2: _4,
  refPoints: A4,
  refPointsKeepOffset: C4,
  refPointsResetOffset: Bf,
  refR: E4,
  refRCircumscribed: y4,
  refRInscribed: jf,
  refRx: m4,
  refRy: w4,
  refWidth: Nf,
  refWidth2: P4,
  refX: Lf,
  refX2: M4,
  refY: Df,
  refY2: k4,
  resetOffset: V4,
  sourceMarker: lv,
  stroke: T4,
  style: H4,
  targetMarker: cv,
  text: Vf,
  textPath: I4,
  textVerticalAnchor: N4,
  textWrap: L4,
  title: $4,
  vertexMarker: hv,
  xAlign: F4,
  yAlign: z4
}, Symbol.toStringTag, { value: "Module" }));
var Ut;
(function(s) {
  function e(t, n, i) {
    return !!(t != null && (typeof t == "string" || typeof t.qualify != "function" || G(t.qualify, this, n, i)));
  }
  s.isValidDefinition = e;
})(Ut || (Ut = {}));
(function(s) {
  s.presets = Object.assign(Object.assign({}, d4), wv), s.registry = _e.create({
    type: "attribute definition"
  }), s.registry.register(s.presets, !0);
})(Ut || (Ut = {}));
const Nt = {
  prefixCls: "x6",
  autoInsertCSS: !0,
  useCSSSelector: !0,
  prefix(s) {
    return "".concat(Nt.prefixCls, "-").concat(s);
  }
}, Mh = Nt.prefix("highlighted"), yv = {
  highlight(s, e, t) {
    const n = t && t.className || Mh;
    se(e, n);
  },
  unhighlight(s, e, t) {
    const n = t && t.className || Mh;
    Et(e, n);
  }
}, kh = Nt.prefix("highlight-opacity"), bv = {
  highlight(s, e) {
    se(e, kh);
  },
  unhighlight(s, e) {
    Et(e, kh);
  }
};
var re;
(function(s) {
  s.normalizeMarker = Fn;
  function e(d, g) {
    const p = Mb(d.x, d.y).matrixTransform(g);
    return new S(p.x, p.y);
  }
  s.transformPoint = e;
  function t(d, g) {
    return new $(e(d.start, g), e(d.end, g));
  }
  s.transformLine = t;
  function n(d, g) {
    let p = d instanceof ke ? d.points : d;
    return Array.isArray(p) || (p = []), new ke(p.map((m) => e(m, g)));
  }
  s.transformPolyline = n;
  function i(d, g) {
    const m = jt("svg").createSVGPoint();
    m.x = d.x, m.y = d.y;
    const w = m.matrixTransform(g);
    m.x = d.x + d.width, m.y = d.y;
    const v = m.matrixTransform(g);
    m.x = d.x + d.width, m.y = d.y + d.height;
    const y = m.matrixTransform(g);
    m.x = d.x, m.y = d.y + d.height;
    const b = m.matrixTransform(g), x = Math.min(w.x, v.x, y.x, b.x), C = Math.max(w.x, v.x, y.x, b.x), A = Math.min(w.y, v.y, y.y, b.y), P = Math.max(w.y, v.y, y.y, b.y);
    return new R(x, A, C - x, P - A);
  }
  s.transformRectangle = i;
  function r(d, g, p) {
    let m;
    const w = d.ownerSVGElement;
    if (!w)
      return new R(0, 0, 0, 0);
    try {
      m = d.getBBox();
    } catch (y) {
      m = {
        x: d.clientLeft,
        y: d.clientTop,
        width: d.clientWidth,
        height: d.clientHeight
      };
    }
    if (g)
      return R.create(m);
    const v = Li(d, p || w);
    return i(m, v);
  }
  s.bbox = r;
  function o(d, g = {}) {
    let p;
    if (!d.ownerSVGElement || !Tn(d)) {
      if (wh(d)) {
        const { left: y, top: b, width: x, height: C } = a(d);
        return new R(y, b, x, C);
      }
      return new R(0, 0, 0, 0);
    }
    let w = g.target;
    if (!g.recursive) {
      try {
        p = d.getBBox();
      } catch (b) {
        p = {
          x: d.clientLeft,
          y: d.clientTop,
          width: d.clientWidth,
          height: d.clientHeight
        };
      }
      if (!w)
        return R.create(p);
      const y = Li(d, w);
      return i(p, y);
    }
    {
      const y = d.childNodes, b = y.length;
      if (b === 0)
        return o(d, {
          target: w
        });
      w || (w = d);
      for (let x = 0; x < b; x += 1) {
        const C = y[x];
        let A;
        C.childNodes.length === 0 ? A = o(C, {
          target: w
        }) : A = o(C, {
          target: w,
          recursive: !0
        }), p ? p = p.union(A) : p = A;
      }
      return p;
    }
  }
  s.getBBox = o;
  function a(d) {
    let g = 0, p = 0, m = 0, w = 0;
    if (d) {
      let v = d;
      for (; v; )
        g += v.offsetLeft, p += v.offsetTop, v = v.offsetParent, v && (g += parseInt(xh(v, "borderLeft"), 10), p += parseInt(xh(v, "borderTop"), 10));
      m = d.offsetWidth, w = d.offsetHeight;
    }
    return {
      left: g,
      top: p,
      width: m,
      height: w
    };
  }
  s.getBoundingOffsetRect = a;
  function l(d) {
    const g = (p) => {
      const m = d.getAttribute(p), w = m ? parseFloat(m) : 0;
      return Number.isNaN(w) ? 0 : w;
    };
    switch (d instanceof SVGElement && d.nodeName.toLowerCase()) {
      case "rect":
        return new R(g("x"), g("y"), g("width"), g("height"));
      case "circle":
        return new Dt(g("cx"), g("cy"), g("r"), g("r"));
      case "ellipse":
        return new Dt(g("cx"), g("cy"), g("rx"), g("ry"));
      case "polyline": {
        const p = ho(d);
        return new ke(p);
      }
      case "polygon": {
        const p = ho(d);
        return p.length > 1 && p.push(p[0]), new ke(p);
      }
      case "path": {
        let p = d.getAttribute("d");
        return F.isValid(p) || (p = F.normalize(p)), F.parse(p);
      }
      case "line":
        return new $(g("x1"), g("y1"), g("x2"), g("y2"));
    }
    return o(d);
  }
  s.toGeometryShape = l;
  function c(d, g, p, m) {
    const w = S.create(g), v = S.create(p);
    m || (m = d instanceof SVGSVGElement ? d : d.ownerSVGElement);
    const y = tl(d);
    d.setAttribute("transform", "");
    const b = o(d, {
      target: m
    }).scale(y.sx, y.sy), x = Ei();
    x.setTranslate(-b.x - b.width / 2, -b.y - b.height / 2);
    const C = Ei(), A = w.angleBetween(v, w.clone().translate(1, 0));
    A && C.setRotate(A, 0, 0);
    const P = Ei(), O = w.clone().move(v, b.width / 2);
    P.setTranslate(2 * w.x - O.x, 2 * w.y - O.y);
    const k = Li(d, m), D = Ei();
    D.setMatrix(P.matrix.multiply(C.matrix.multiply(x.matrix.multiply(k.scale(y.sx, y.sy))))), d.setAttribute("transform", pi(D.matrix));
  }
  s.translateAndAutoOrient = c;
  function u(d) {
    if (d == null)
      return null;
    let g = d;
    do {
      let p = g.tagName;
      if (typeof p != "string")
        return null;
      if (p = p.toUpperCase(), gr(g, "x6-port"))
        g = g.nextElementSibling;
      else if (p === "G")
        g = g.firstElementChild;
      else if (p === "TITLE")
        g = g.nextElementSibling;
      else
        break;
    } while (g);
    return g;
  }
  s.findShapeNode = u;
  function f(d) {
    const g = u(d);
    if (!Tn(g)) {
      if (wh(d)) {
        const { left: w, top: v, width: y, height: b } = a(d);
        return new R(w, v, y, b);
      }
      return new R(0, 0, 0, 0);
    }
    return l(g).bbox() || R.create();
  }
  s.getBBoxV2 = f;
})(re || (re = {}));
const vv = {
  padding: 3,
  rx: 0,
  ry: 0,
  attrs: {
    "stroke-width": 3,
    stroke: "#FEB663"
  }
}, xv = {
  highlight(s, e, t) {
    const n = yn.getHighlighterId(e, t);
    if (yn.hasCache(n))
      return;
    t = nu({}, t, vv);
    const i = U.create(e);
    let r, o;
    try {
      r = i.toPathData();
    } catch (u) {
      o = re.bbox(i.node, !0), r = Cf(Object.assign(Object.assign({}, t), o));
    }
    const a = jt("path");
    if (ue(a, Object.assign({ d: r, "pointer-events": "none", "vector-effect": "non-scaling-stroke", fill: "none" }, t.attrs ? Xi(t.attrs) : null)), s.isEdgeElement(e))
      ue(a, "d", s.getConnectionPathData());
    else {
      let u = i.getTransformToElement(s.container);
      const f = t.padding;
      if (f) {
        o == null && (o = re.bbox(i.node, !0));
        const d = o.x + o.width / 2, g = o.y + o.height / 2;
        o = re.transformRectangle(o, u);
        const p = Math.max(o.width, 1), m = Math.max(o.height, 1), w = (p + f) / p, v = (m + f) / m, y = Ve({
          a: w,
          b: 0,
          c: 0,
          d: v,
          e: d - w * d,
          f: g - v * g
        });
        u = u.multiply(y);
      }
      qs(a, u);
    }
    se(a, Nt.prefix("highlight-stroke"));
    const l = s.cell, c = () => yn.removeHighlighter(n);
    l.on("removed", c), l.model && l.model.on("reseted", c), s.container.appendChild(a), yn.setCache(n, a);
  },
  unhighlight(s, e, t) {
    yn.removeHighlighter(yn.getHighlighterId(e, t));
  }
};
var yn;
(function(s) {
  function e(o, a) {
    return Jl(o), o.id + JSON.stringify(a);
  }
  s.getHighlighterId = e;
  const t = {};
  function n(o, a) {
    t[o] = a;
  }
  s.setCache = n;
  function i(o) {
    return t[o] != null;
  }
  s.hasCache = i;
  function r(o) {
    const a = t[o];
    a && (Us(a), delete t[o]);
  }
  s.removeHighlighter = r;
})(yn || (yn = {}));
const Cv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  className: yv,
  opacity: bv,
  stroke: xv
}, Symbol.toStringTag, { value: "Module" }));
var on;
(function(s) {
  function e(t, n) {
    if (typeof n.highlight != "function")
      throw new Error("Highlighter '".concat(t, "' is missing required `highlight()` method"));
    if (typeof n.unhighlight != "function")
      throw new Error("Highlighter '".concat(t, "' is missing required `unhighlight()` method"));
  }
  s.check = e;
})(on || (on = {}));
(function(s) {
  s.presets = Cv, s.registry = _e.create({
    type: "highlighter"
  }), s.registry.register(s.presets, !0);
})(on || (on = {}));
function il(s, e = {}) {
  return new S(Ot(e.x, s.width), Ot(e.y, s.height));
}
function nc(s, e, t) {
  return Object.assign({ angle: e, position: s.toJSON() }, t);
}
const Ev = (s, e) => s.map(({ x: t, y: n, angle: i }) => nc(il(e, { x: t, y: n }), i || 0)), Sv = (s, e, t) => {
  const n = t.start || 0, i = t.step || 20;
  return Xf(s, e, n, (r, o) => (r + 0.5 - o / 2) * i);
}, Av = (s, e, t) => {
  const n = t.start || 0, i = t.step || 360 / s.length;
  return Xf(s, e, n, (r) => r * i);
};
function Xf(s, e, t, n) {
  const i = e.getCenter(), r = e.getTopCenter(), o = e.width / e.height, a = Dt.fromRect(e), l = s.length;
  return s.map((c, u) => {
    const f = t + n(u, l), d = r.clone().rotate(-f, i).scale(o, 1, i), g = c.compensateRotate ? -a.tangentTheta(d) : 0;
    return (c.dx || c.dy) && d.translate(c.dx || 0, c.dy || 0), c.dr && d.move(i, c.dr), nc(d.round(), g, c);
  });
}
var Mv = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
const kv = (s, e, t) => {
  const n = il(e, t.start || e.getOrigin()), i = il(e, t.end || e.getCorner());
  return br(s, n, i, t);
}, Pv = (s, e, t) => br(s, e.getTopLeft(), e.getBottomLeft(), t), _v = (s, e, t) => br(s, e.getTopRight(), e.getBottomRight(), t), Ov = (s, e, t) => br(s, e.getTopLeft(), e.getTopRight(), t), Tv = (s, e, t) => br(s, e.getBottomLeft(), e.getBottomRight(), t);
function br(s, e, t, n) {
  const i = new $(e, t), r = s.length;
  return s.map((o, a) => {
    var { strict: l } = o, c = Mv(o, ["strict"]);
    const u = l || n.strict ? (a + 1) / (r + 1) : (a + 0.5) / r, f = i.pointAt(u);
    return (c.dx || c.dy) && f.translate(c.dx || 0, c.dy || 0), nc(f.round(), 0, c);
  });
}
const Lv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  absolute: Ev,
  bottom: Tv,
  ellipse: Sv,
  ellipseSpread: Av,
  left: Pv,
  line: kv,
  right: _v,
  top: Ov
}, Symbol.toStringTag, { value: "Module" }));
var ns;
(function(s) {
  s.presets = Lv, s.registry = _e.create({
    type: "port layout"
  }), s.registry.register(s.presets, !0);
})(ns || (ns = {}));
const Dv = {
  position: { x: 0, y: 0 },
  angle: 0,
  attrs: {
    ".": {
      y: "0",
      "text-anchor": "start"
    }
  }
};
function zn(s, e) {
  const { x: t, y: n, angle: i, attrs: r } = e || {};
  return nu({}, { angle: i, attrs: r, position: { x: t, y: n } }, s, Dv);
}
const Nv = (s, e, t) => zn({ position: e.getTopLeft() }, t), Iv = (s, e, t) => zn({
  position: { x: -15, y: 0 },
  attrs: { ".": { y: ".3em", "text-anchor": "end" } }
}, t), jv = (s, e, t) => zn({
  position: { x: 15, y: 0 },
  attrs: { ".": { y: ".3em", "text-anchor": "start" } }
}, t), Rv = (s, e, t) => zn({
  position: { x: 0, y: -15 },
  attrs: { ".": { "text-anchor": "middle" } }
}, t), Bv = (s, e, t) => zn({
  position: { x: 0, y: 15 },
  attrs: { ".": { y: ".6em", "text-anchor": "middle" } }
}, t), $v = (s, e, t) => Zf(s, e, !1, t), Fv = (s, e, t) => Zf(s, e, !0, t), zv = (s, e, t) => Kf(s, e, !1, t), Vv = (s, e, t) => Kf(s, e, !0, t);
function Zf(s, e, t, n) {
  const i = n.offset != null ? n.offset : 15, r = e.getCenter().theta(s), o = Qf(e);
  let a, l, c, u, f = 0;
  return r < o[1] || r > o[2] ? (a = ".3em", l = i, c = 0, u = "start") : r < o[0] ? (a = "0", l = 0, c = -i, t ? (f = -90, u = "start") : u = "middle") : r < o[3] ? (a = ".3em", l = -i, c = 0, u = "end") : (a = ".6em", l = 0, c = i, t ? (f = 90, u = "start") : u = "middle"), zn({
    position: {
      x: Math.round(l),
      y: Math.round(c)
    },
    angle: f,
    attrs: {
      ".": {
        y: a,
        "text-anchor": u
      }
    }
  }, n);
}
function Kf(s, e, t, n) {
  const i = n.offset != null ? n.offset : 15, r = e.getCenter().theta(s), o = Qf(e);
  let a, l, c, u, f = 0;
  return r < o[1] || r > o[2] ? (a = ".3em", l = -i, c = 0, u = "end") : r < o[0] ? (a = ".6em", l = 0, c = i, t ? (f = 90, u = "start") : u = "middle") : r < o[3] ? (a = ".3em", l = i, c = 0, u = "start") : (a = "0em", l = 0, c = -i, t ? (f = -90, u = "start") : u = "middle"), zn({
    position: {
      x: Math.round(l),
      y: Math.round(c)
    },
    angle: f,
    attrs: {
      ".": {
        y: a,
        "text-anchor": u
      }
    }
  }, n);
}
function Qf(s) {
  const e = s.getCenter(), t = e.theta(s.getTopLeft()), n = e.theta(s.getBottomLeft()), i = e.theta(s.getBottomRight()), r = e.theta(s.getTopRight());
  return [t, r, i, n];
}
const Hv = (s, e, t) => eg(s.diff(e.getCenter()), !1, t), Uv = (s, e, t) => eg(s.diff(e.getCenter()), !0, t);
function eg(s, e, t) {
  const n = t.offset != null ? t.offset : 20, i = new S(0, 0), r = -s.theta(i), o = s.clone().move(i, n).diff(s).round();
  let a = ".3em", l, c = r;
  return (r + 90) % 180 === 0 ? (l = e ? "end" : "middle", !e && r === -270 && (a = "0em")) : r > -270 && r < -90 ? (l = "start", c = r - 180) : l = "end", zn({
    position: o.round().toJSON(),
    angle: e ? c : 0,
    attrs: {
      ".": {
        y: a,
        "text-anchor": l
      }
    }
  }, t);
}
const qv = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bottom: Bv,
  inside: zv,
  insideOriented: Vv,
  left: Iv,
  manual: Nv,
  outside: $v,
  outsideOriented: Fv,
  radial: Hv,
  radialOriented: Uv,
  right: jv,
  top: Rv
}, Symbol.toStringTag, { value: "Module" }));
var Xs;
(function(s) {
  s.presets = qv, s.registry = _e.create({
    type: "port label layout"
  }), s.registry.register(s.presets, !0);
})(Xs || (Xs = {}));
var Gv = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class pe extends ft {
  get priority() {
    return 2;
  }
  /** If need remove `this.container` DOM */
  get disposeContainer() {
    return !0;
  }
  constructor() {
    super(), this.cid = rl.uniqueId(), pe.views[this.cid] = this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  confirmUpdate(e, t) {
    return 0;
  }
  empty(e = this.container) {
    return pr(e), this;
  }
  unmount(e = this.container) {
    return Us(e), this;
  }
  remove(e = this.container) {
    return e === this.container ? (this.removeEventListeners(document), this.onRemove(), delete pe.views[this.cid], this.disposeContainer && this.unmount(e)) : this.unmount(e), this;
  }
  onRemove() {
  }
  setClass(e, t = this.container) {
    t.classList.value = Array.isArray(e) ? e.join(" ") : e;
  }
  addClass(e, t = this.container) {
    return se(t, Array.isArray(e) ? e.join(" ") : e), this;
  }
  removeClass(e, t = this.container) {
    return Et(t, Array.isArray(e) ? e.join(" ") : e), this;
  }
  setStyle(e, t = this.container) {
    return wr(t, e), this;
  }
  setAttrs(e, t = this.container) {
    return e != null && t != null && ue(t, e), this;
  }
  /**
   * Returns the value of the specified attribute of `node`.
   *
   * If the node does not set a value for attribute, start recursing up
   * the DOM tree from node to lookup for attribute at the ancestors of
   * node. If the recursion reaches CellView's root node and attribute
   * is not found even there, return `null`.
   */
  findAttr(e, t = this.container) {
    let n = t;
    for (; n && n.nodeType === 1; ) {
      const i = n.getAttribute(e);
      if (i != null)
        return i;
      if (n === this.container)
        return null;
      n = n.parentNode;
    }
    return null;
  }
  find(e, t = this.container, n = this.selectors) {
    return pe.find(e, t, n).elems;
  }
  findOne(e, t = this.container, n = this.selectors) {
    const i = this.find(e, t, n);
    return i.length > 0 ? i[0] : null;
  }
  findByAttr(e, t = this.container) {
    let n = t;
    for (; n && n.getAttribute; ) {
      const i = n.getAttribute(e);
      if ((i != null || n === this.container) && i !== "false")
        return n;
      n = n.parentNode;
    }
    return null;
  }
  getSelector(e, t) {
    let n;
    if (e === this.container)
      return typeof t == "string" && (n = "> ".concat(t)), n;
    if (e) {
      const i = Xl(e) + 1;
      n = "".concat(e.tagName.toLowerCase(), ":nth-child(").concat(i, ")"), t && (n += " > ".concat(t)), n = this.getSelector(e.parentNode, n);
    }
    return n;
  }
  prefixClassName(e) {
    return Nt.prefix(e);
  }
  delegateEvents(e, t) {
    if (e == null)
      return this;
    t || this.undelegateEvents();
    const n = /^(\S+)\s*(.*)$/;
    return Object.keys(e).forEach((i) => {
      const r = i.match(n);
      if (r == null)
        return;
      const o = this.getEventHandler(e[i]);
      typeof o == "function" && this.delegateEvent(r[1], r[2], o);
    }), this;
  }
  undelegateEvents() {
    return Ue.off(this.container, this.getEventNamespace()), this;
  }
  delegateDocumentEvents(e, t) {
    return this.addEventListeners(document, e, t), this;
  }
  undelegateDocumentEvents() {
    return this.removeEventListeners(document), this;
  }
  delegateEvent(e, t, n) {
    return Ue.on(this.container, e + this.getEventNamespace(), t, n), this;
  }
  undelegateEvent(e, t, n) {
    const i = e + this.getEventNamespace();
    return t == null ? Ue.off(this.container, i) : typeof t == "string" ? Ue.off(this.container, i, t, n) : Ue.off(this.container, i, t), this;
  }
  addEventListeners(e, t, n) {
    if (t == null)
      return this;
    const i = this.getEventNamespace();
    return Object.keys(t).forEach((r) => {
      const o = this.getEventHandler(t[r]);
      typeof o == "function" && Ue.on(e, r + i, n, o);
    }), this;
  }
  removeEventListeners(e) {
    return e != null && Ue.off(e, this.getEventNamespace()), this;
  }
  getEventNamespace() {
    return ".".concat(Nt.prefixCls, "-event-").concat(this.cid);
  }
  // eslint-disable-next-line
  getEventHandler(e) {
    let t;
    if (typeof e == "string") {
      const n = this[e];
      typeof n == "function" && (t = (...i) => n.call(this, ...i));
    } else
      t = (...n) => e.call(this, ...n);
    return t;
  }
  getEventTarget(e, t = {}) {
    const { target: n, type: i, clientX: r = 0, clientY: o = 0 } = e;
    return t.fromPoint || i === "touchmove" || i === "touchend" ? document.elementFromPoint(r, o) : n;
  }
  stopPropagation(e) {
    return this.setEventData(e, { propagationStopped: !0 }), this;
  }
  isPropagationStopped(e) {
    return this.getEventData(e).propagationStopped === !0;
  }
  getEventData(e) {
    return this.eventData(e);
  }
  setEventData(e, t) {
    return this.eventData(e, t);
  }
  eventData(e, t) {
    if (e == null)
      throw new TypeError("Event object required");
    let n = e.data;
    const i = "__".concat(this.cid, "__");
    return t == null ? n == null ? {} : n[i] || {} : (n == null && (n = e.data = {}), n[i] == null ? n[i] = Object.assign({}, t) : n[i] = Object.assign(Object.assign({}, n[i]), t), n[i]);
  }
  normalizeEvent(e) {
    return pe.normalizeEvent(e);
  }
  dispose() {
    this.remove();
  }
}
Gv([
  pe.dispose()
], pe.prototype, "dispose", null);
(function(s) {
  function e(i, r) {
    return r ? jt(i || "g") : Yl(i || "div");
  }
  s.createElement = e;
  function t(i, r, o) {
    if (!i || i === ".")
      return { elems: [r] };
    if (o) {
      const a = o[i];
      if (a)
        return { elems: Array.isArray(a) ? a : [a] };
    }
    {
      const a = i.includes(">") ? ":scope ".concat(i) : i;
      return {
        isCSSSelector: !0,
        // $(rootElem).find(selector).toArray() as Element[]
        elems: Array.prototype.slice.call(r.querySelectorAll(a))
      };
    }
  }
  s.find = t;
  function n(i) {
    let r = i;
    const o = i.originalEvent, a = o && o.changedTouches && o.changedTouches[0];
    if (a) {
      for (const l in i)
        a[l] === void 0 && (a[l] = i[l]);
      r = a;
    }
    return r;
  }
  s.normalizeEvent = n;
})(pe || (pe = {}));
(function(s) {
  s.views = {};
  function e(t) {
    return s.views[t] || null;
  }
  s.getView = e;
})(pe || (pe = {}));
var rl;
(function(s) {
  let e = 0;
  function t() {
    const n = "v".concat(e);
    return e += 1, n;
  }
  s.uniqueId = t;
})(rl || (rl = {}));
class Wv {
  constructor(e) {
    this.view = e, this.clean();
  }
  clean() {
    this.elemCache && this.elemCache.dispose(), this.elemCache = new sl(), this.pathCache = {};
  }
  get(e) {
    return this.elemCache.has(e) || this.elemCache.set(e, {}), this.elemCache.get(e);
  }
  getData(e) {
    const t = this.get(e);
    return t.data || (t.data = {}), t.data;
  }
  getMatrix(e) {
    const t = this.get(e);
    if (t.matrix == null) {
      const n = this.view.container;
      t.matrix = Tb(e, n);
    }
    return Ve(t.matrix);
  }
  getShape(e) {
    const t = this.get(e);
    return t.shape == null && (t.shape = re.toGeometryShape(e)), t.shape.clone();
  }
  getBoundingRect(e) {
    const t = this.get(e);
    return t.boundingRect == null && (t.boundingRect = re.getBBoxV2(e)), t.boundingRect.clone();
  }
}
var ge;
(function(s) {
  function e(c) {
    return c != null && !t(c);
  }
  s.isJSONMarkup = e;
  function t(c) {
    return c != null && typeof c == "string";
  }
  s.isStringMarkup = t;
  function n(c) {
    return c == null || t(c) ? c : Ce(c);
  }
  s.clone = n;
  function i(c) {
    return "".concat(c).trim().replace(/[\r|\n]/g, " ").replace(/>\s+</g, "><");
  }
  s.sanitize = i;
  function r(c, u = { ns: Fe.svg }) {
    const f = document.createDocumentFragment(), d = {}, g = {}, p = [
      {
        markup: Array.isArray(c) ? c : [c],
        parent: f,
        ns: u.ns
      }
    ];
    for (; p.length > 0; ) {
      const m = p.pop();
      let w = m.ns || Fe.svg;
      const v = m.markup, y = m.parent;
      v.forEach((b) => {
        const x = b.tagName;
        if (!x)
          throw new TypeError("Invalid tagName");
        b.ns && (w = b.ns);
        const C = w ? Yl(x, w) : mh(x), A = b.attrs;
        A && ue(C, Xi(A));
        const P = b.style;
        P && wr(C, P);
        const O = b.className;
        O != null && C.setAttribute("class", Array.isArray(O) ? O.join(" ") : O), b.textContent && (C.textContent = b.textContent);
        const k = b.selector;
        if (k != null) {
          if (g[k])
            throw new TypeError("Selector must be unique");
          g[k] = C;
        }
        if (b.groupSelector) {
          let L = b.groupSelector;
          Array.isArray(L) || (L = [L]), L.forEach((B) => {
            d[B] || (d[B] = []), d[B].push(C);
          });
        }
        y.appendChild(C);
        const D = b.children;
        Array.isArray(D) && p.push({ ns: w, markup: D, parent: C });
      });
    }
    return Object.keys(d).forEach((m) => {
      if (g[m])
        throw new Error("Ambiguous group selector");
      g[m] = d[m];
    }), { fragment: f, selectors: g, groups: d };
  }
  s.parseJSONMarkup = r;
  function o(c) {
    return c instanceof SVGElement ? jt("g") : mh("div");
  }
  function a(c) {
    if (t(c)) {
      const g = U.createVectors(c), p = g.length;
      if (p === 1)
        return {
          elem: g[0].node
        };
      if (p > 1) {
        const m = o(g[0].node);
        return g.forEach((w) => {
          m.appendChild(w.node);
        }), { elem: m };
      }
      return {};
    }
    const u = r(c), f = u.fragment;
    let d = null;
    return f.childNodes.length > 1 ? (d = o(f.firstChild), d.appendChild(f)) : d = f.firstChild, { elem: d, selectors: u.selectors };
  }
  s.renderMarkup = a;
  function l(c) {
    const u = U.createVectors(c), f = document.createDocumentFragment();
    for (let d = 0, g = u.length; d < g; d += 1) {
      const p = u[d].node;
      f.appendChild(p);
    }
    return { fragment: f, selectors: {} };
  }
  s.parseLabelStringMarkup = l;
})(ge || (ge = {}));
(function(s) {
  function e(t, n, i) {
    if (t != null) {
      let r;
      const o = t.tagName.toLowerCase();
      if (t === n)
        return typeof i == "string" ? r = "> ".concat(o, " > ").concat(i) : r = "> ".concat(o), r;
      const a = t.parentNode;
      if (a && a.childNodes.length > 1) {
        const l = Xl(t) + 1;
        r = "".concat(o, ":nth-child(").concat(l, ")");
      } else
        r = o;
      return i && (r += " > ".concat(i)), e(t.parentNode, n, r);
    }
    return i;
  }
  s.getSelector = e;
})(ge || (ge = {}));
(function(s) {
  function e() {
    return "g";
  }
  s.getPortContainerMarkup = e;
  function t() {
    return {
      tagName: "circle",
      selector: "circle",
      attrs: {
        r: 10,
        fill: "#FFFFFF",
        stroke: "#000000"
      }
    };
  }
  s.getPortMarkup = t;
  function n() {
    return {
      tagName: "text",
      selector: "text",
      attrs: {
        fill: "#000000"
      }
    };
  }
  s.getPortLabelMarkup = n;
})(ge || (ge = {}));
(function(s) {
  function e() {
    return [
      {
        tagName: "path",
        selector: "wrap",
        groupSelector: "lines",
        attrs: {
          fill: "none",
          cursor: "pointer",
          stroke: "transparent",
          strokeLinecap: "round"
        }
      },
      {
        tagName: "path",
        selector: "line",
        groupSelector: "lines",
        attrs: {
          fill: "none",
          pointerEvents: "none"
        }
      }
    ];
  }
  s.getEdgeMarkup = e;
})(ge || (ge = {}));
(function(s) {
  function e(t = !1) {
    return {
      tagName: "foreignObject",
      selector: "fo",
      children: [
        {
          ns: Fe.xhtml,
          tagName: "body",
          selector: "foBody",
          attrs: {
            xmlns: Fe.xhtml
          },
          style: {
            width: "100%",
            height: "100%",
            background: "transparent"
          },
          children: t ? [] : [
            {
              tagName: "div",
              selector: "foContent",
              style: {
                width: "100%",
                height: "100%"
              }
            }
          ]
        }
      ]
    };
  }
  s.getForeignObjectMarkup = e;
})(ge || (ge = {}));
class tg {
  constructor(e) {
    this.view = e;
  }
  get cell() {
    return this.view.cell;
  }
  getDefinition(e) {
    return this.cell.getAttrDefinition(e);
  }
  processAttrs(e, t) {
    let n, i, r, o;
    const a = [];
    return Object.keys(t).forEach((l) => {
      const c = t[l], u = this.getDefinition(l), f = G(Ut.isValidDefinition, this.view, u, c, {
        elem: e,
        attrs: t,
        cell: this.cell,
        view: this.view
      });
      if (u && f)
        typeof u == "string" ? (n == null && (n = {}), n[u] = c) : c !== null && a.push({ name: l, definition: u });
      else {
        n == null && (n = {});
        const d = ff.includes(l) ? l : Wd(l);
        n[d] = c;
      }
    }), a.forEach(({ name: l, definition: c }) => {
      const u = t[l];
      typeof c.set == "function" && (i == null && (i = {}), i[l] = u), typeof c.offset == "function" && (r == null && (r = {}), r[l] = u), typeof c.position == "function" && (o == null && (o = {}), o[l] = u);
    }), {
      raw: t,
      normal: n,
      set: i,
      offset: r,
      position: o
    };
  }
  mergeProcessedAttrs(e, t) {
    e.set = Object.assign(Object.assign({}, e.set), t.set), e.position = Object.assign(Object.assign({}, e.position), t.position), e.offset = Object.assign(Object.assign({}, e.offset), t.offset);
    const n = e.normal && e.normal.transform;
    n != null && t.normal && (t.normal.transform = n), e.normal = t.normal;
  }
  findAttrs(e, t, n, i) {
    const r = [], o = new sl();
    return Object.keys(e).forEach((a) => {
      const l = e[a];
      if (!un(l))
        return;
      const { isCSSSelector: c, elems: u } = pe.find(a, t, i);
      n[a] = u;
      for (let f = 0, d = u.length; f < d; f += 1) {
        const g = u[f], p = i && i[a] === g, m = o.get(g);
        if (m) {
          m.array || (r.push(g), m.array = !0, m.attrs = [m.attrs], m.priority = [m.priority]);
          const w = m.attrs, v = m.priority;
          if (p)
            w.unshift(l), v.unshift(-1);
          else {
            const y = ap(v, c ? -1 : d);
            w.splice(y, 0, l), v.splice(y, 0, d);
          }
        } else
          o.set(g, {
            elem: g,
            attrs: l,
            priority: p ? -1 : d,
            array: !1
          });
      }
    }), r.forEach((a) => {
      const l = o.get(a), c = l.attrs;
      l.attrs = c.reduceRight((u, f) => Te(u, f), {});
    }), o;
  }
  updateRelativeAttrs(e, t, n) {
    const i = t.raw || {};
    let r = t.normal || {};
    const o = t.set, a = t.position, l = t.offset, c = () => ({
      elem: e,
      cell: this.cell,
      view: this.view,
      attrs: i,
      refBBox: n.clone()
    });
    if (o != null && Object.keys(o).forEach((w) => {
      const v = o[w], y = this.getDefinition(w);
      if (y != null) {
        const b = G(y.set, this.view, v, c());
        typeof b == "object" ? r = Object.assign(Object.assign({}, r), b) : b != null && (r[w] = b);
      }
    }), e instanceof HTMLElement) {
      this.view.setAttrs(r, e);
      return;
    }
    const u = r.transform, f = u ? "".concat(u) : null, d = Zi(f), g = new S(d.e, d.f);
    u && (delete r.transform, d.e = 0, d.f = 0);
    let p = !1;
    a != null && Object.keys(a).forEach((w) => {
      const v = a[w], y = this.getDefinition(w);
      if (y != null) {
        const b = G(y.position, this.view, v, c());
        b != null && (p = !0, g.translate(S.create(b)));
      }
    }), this.view.setAttrs(r, e);
    let m = !1;
    if (l != null) {
      const w = this.view.getBoundingRectOfElement(e);
      if (w.width > 0 && w.height > 0) {
        const v = re.transformRectangle(w, d);
        Object.keys(l).forEach((y) => {
          const b = l[y], x = this.getDefinition(y);
          if (x != null) {
            const C = G(x.offset, this.view, b, {
              elem: e,
              cell: this.cell,
              view: this.view,
              attrs: i,
              refBBox: v
            });
            C != null && (m = !0, g.translate(S.create(C)));
          }
        });
      }
    }
    (u != null || p || m) && (g.round(1), d.e = g.x, d.f = g.y, e.setAttribute("transform", pi(d)));
  }
  update(e, t, n) {
    const i = {}, r = this.findAttrs(n.attrs || t, e, i, n.selectors), o = n.attrs ? this.findAttrs(t, e, i, n.selectors) : r, a = [];
    r.each((u) => {
      const f = u.elem, d = u.attrs, g = this.processAttrs(f, d);
      if (g.set == null && g.position == null && g.offset == null)
        this.view.setAttrs(g.normal, f);
      else {
        const p = o.get(f), m = p ? p.attrs : null, w = m && d.ref == null ? m.ref : d.ref;
        let v;
        if (w) {
          if (v = (i[w] || this.view.find(w, e, n.selectors))[0], !v)
            throw new Error('"'.concat(w, '" reference does not exist.'));
        } else
          v = null;
        const y = {
          node: f,
          refNode: v,
          attributes: m,
          processedAttributes: g
        }, b = a.findIndex((x) => x.refNode === f);
        b > -1 ? a.splice(b, 0, y) : a.push(y);
      }
    });
    const l = new sl();
    let c;
    a.forEach((u) => {
      const f = u.node, d = u.refNode;
      let g;
      const p = d != null && n.rotatableNode != null && df(n.rotatableNode, d);
      if (d && (g = l.get(d)), !g) {
        const v = p ? n.rotatableNode : e;
        g = d ? re.getBBox(d, { target: v }) : n.rootBBox, d && l.set(d, g);
      }
      let m;
      n.attrs && u.attributes ? (m = this.processAttrs(f, u.attributes), this.mergeProcessedAttrs(m, u.processedAttributes)) : m = u.processedAttributes;
      let w = g;
      p && n.rotatableNode != null && !n.rotatableNode.contains(f) && (c || (c = Zi(ue(n.rotatableNode, "transform"))), w = re.transformRectangle(g, c)), this.updateRelativeAttrs(f, m, w);
    });
  }
}
class ng {
  get cell() {
    return this.view.cell;
  }
  constructor(e, t, n = []) {
    this.view = e;
    const i = {}, r = {};
    let o = 0;
    Object.keys(t).forEach((l) => {
      let c = t[l];
      Array.isArray(c) || (c = [c]), c.forEach((u) => {
        let f = i[u];
        f || (o += 1, f = i[u] = 1 << o), r[l] |= f;
      });
    });
    let a = n;
    if (Array.isArray(a) || (a = [a]), a.forEach((l) => {
      i[l] || (o += 1, i[l] = 1 << o);
    }), o > 25)
      throw new Error("Maximum number of flags exceeded.");
    this.flags = i, this.attrs = r, this.bootstrap = n;
  }
  getFlag(e) {
    const t = this.flags;
    return t == null ? 0 : Array.isArray(e) ? e.reduce((n, i) => n | t[i], 0) : t[e] | 0;
  }
  hasAction(e, t) {
    return e & this.getFlag(t);
  }
  removeAction(e, t) {
    return e ^ e & this.getFlag(t);
  }
  getBootstrapFlag() {
    return this.getFlag(this.bootstrap);
  }
  getChangedFlag() {
    let e = 0;
    return this.attrs && Object.keys(this.attrs).forEach((t) => {
      this.cell.hasChanged(t) && (e |= this.attrs[t]);
    }), e;
  }
}
var Jv = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
}, Yv = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
class Pe extends pe {
  static getDefaults() {
    return this.defaults;
  }
  static config(e) {
    this.defaults = this.getOptions(e);
  }
  static getOptions(e) {
    const t = (c, u) => u != null ? su([
      ...Array.isArray(c) ? c : [c],
      ...Array.isArray(u) ? u : [u]
    ]) : Array.isArray(c) ? [...c] : [c], n = Ce(this.getDefaults()), { bootstrap: i, actions: r, events: o, documentEvents: a } = e, l = Yv(e, ["bootstrap", "actions", "events", "documentEvents"]);
    return i && (n.bootstrap = t(n.bootstrap, i)), r && Object.entries(r).forEach(([c, u]) => {
      const f = n.actions[c];
      u && f ? n.actions[c] = t(f, u) : u && (n.actions[c] = t(u));
    }), o && (n.events = Object.assign(Object.assign({}, n.events), o)), e.documentEvents && (n.documentEvents = Object.assign(Object.assign({}, n.documentEvents), a)), Te(n, l);
  }
  get [Symbol.toStringTag]() {
    return Pe.toStringTag;
  }
  constructor(e, t = {}) {
    super(), this.cell = e, this.options = this.ensureOptions(t), this.graph = this.options.graph, this.attr = new tg(this), this.flag = new ng(this, this.options.actions, this.options.bootstrap), this.cache = new Wv(this), this.setContainer(this.ensureContainer()), this.setup(), this.init();
  }
  init() {
  }
  onRemove() {
    this.removeTools();
  }
  get priority() {
    return this.options.priority;
  }
  get rootSelector() {
    return this.options.rootSelector;
  }
  getConstructor() {
    return this.constructor;
  }
  ensureOptions(e) {
    return this.getConstructor().getOptions(e);
  }
  getContainerTagName() {
    return this.options.isSvgElement ? "g" : "div";
  }
  getContainerStyle() {
  }
  getContainerAttrs() {
    return {
      "data-cell-id": this.cell.id,
      "data-shape": this.cell.shape
    };
  }
  getContainerClassName() {
    return this.prefixClassName("cell");
  }
  ensureContainer() {
    return pe.createElement(this.getContainerTagName(), this.options.isSvgElement);
  }
  setContainer(e) {
    if (this.container !== e) {
      this.undelegateEvents(), this.container = e, this.options.events != null && this.delegateEvents(this.options.events);
      const t = this.getContainerAttrs();
      t != null && this.setAttrs(t, e);
      const n = this.getContainerStyle();
      n != null && this.setStyle(n, e);
      const i = this.getContainerClassName();
      i != null && this.addClass(i, e);
    }
    return this;
  }
  isNodeView() {
    return !1;
  }
  isEdgeView() {
    return !1;
  }
  render() {
    return this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  confirmUpdate(e, t = {}) {
    return 0;
  }
  getBootstrapFlag() {
    return this.flag.getBootstrapFlag();
  }
  getFlag(e) {
    return this.flag.getFlag(e);
  }
  hasAction(e, t) {
    return this.flag.hasAction(e, t);
  }
  removeAction(e, t) {
    return this.flag.removeAction(e, t);
  }
  handleAction(e, t, n, i) {
    if (this.hasAction(e, t)) {
      n();
      const r = [t];
      return i && (typeof i == "string" ? r.push(i) : r.push(...i)), this.removeAction(e, r);
    }
    return e;
  }
  setup() {
    this.cell.on("changed", this.onCellChanged, this);
  }
  onCellChanged({ options: e }) {
    this.onAttrsChange(e);
  }
  onAttrsChange(e) {
    let t = this.flag.getChangedFlag();
    e.updated || !t || (e.dirty && this.hasAction(t, "update") && (t |= this.getFlag("render")), e.toolId && (e.async = !1), this.graph != null && this.graph.renderer.requestViewUpdate(this, t, e));
  }
  parseJSONMarkup(e, t) {
    const n = ge.parseJSONMarkup(e), i = n.selectors, r = this.rootSelector;
    if (t && r) {
      if (i[r])
        throw new Error("Invalid root selector");
      i[r] = t;
    }
    return n;
  }
  can(e) {
    let t = this.graph.options.interacting;
    if (typeof t == "function" && (t = G(t, this.graph, this)), typeof t == "object") {
      let n = t[e];
      return typeof n == "function" && (n = G(n, this.graph, this)), n !== !1;
    }
    return typeof t == "boolean" ? t : !1;
  }
  cleanCache() {
    return this.cache.clean(), this;
  }
  getCache(e) {
    return this.cache.get(e);
  }
  getDataOfElement(e) {
    return this.cache.getData(e);
  }
  getMatrixOfElement(e) {
    return this.cache.getMatrix(e);
  }
  getShapeOfElement(e) {
    return this.cache.getShape(e);
  }
  getBoundingRectOfElement(e) {
    return this.cache.getBoundingRect(e);
  }
  getBBoxOfElement(e) {
    const t = this.getBoundingRectOfElement(e), n = this.getMatrixOfElement(e), i = this.getRootRotatedMatrix(), r = this.getRootTranslatedMatrix();
    return re.transformRectangle(t, r.multiply(i).multiply(n));
  }
  getUnrotatedBBoxOfElement(e) {
    const t = this.getBoundingRectOfElement(e), n = this.getMatrixOfElement(e), i = this.getRootTranslatedMatrix();
    return re.transformRectangle(t, i.multiply(n));
  }
  getBBox(e = {}) {
    let t;
    if (e.useCellGeometry) {
      const n = this.cell, i = n.isNode() ? n.getAngle() : 0;
      t = n.getBBox().bbox(i);
    } else
      t = this.getBBoxOfElement(this.container);
    return this.graph.coord.localToGraphRect(t);
  }
  getRootTranslatedMatrix() {
    const e = this.cell, t = e.isNode() ? e.getPosition() : { x: 0, y: 0 };
    return Ve().translate(t.x, t.y);
  }
  getRootRotatedMatrix() {
    let e = Ve();
    const t = this.cell, n = t.isNode() ? t.getAngle() : 0;
    if (n) {
      const i = t.getBBox(), r = i.width / 2, o = i.height / 2;
      e = e.translate(r, o).rotate(n).translate(-r, -o);
    }
    return e;
  }
  findMagnet(e = this.container) {
    return this.findByAttr("magnet", e);
  }
  updateAttrs(e, t, n = {}) {
    n.rootBBox == null && (n.rootBBox = new R()), n.selectors == null && (n.selectors = this.selectors), this.attr.update(e, t, n);
  }
  isEdgeElement(e) {
    return this.cell.isEdge() && (e == null || e === this.container);
  }
  // #region highlight
  prepareHighlight(e, t = {}) {
    const n = e || this.container;
    return t.partial = n === this.container, n;
  }
  highlight(e, t = {}) {
    const n = this.prepareHighlight(e, t);
    return this.notify("cell:highlight", {
      magnet: n,
      options: t,
      view: this,
      cell: this.cell
    }), this.isEdgeView() ? this.notify("edge:highlight", {
      magnet: n,
      options: t,
      view: this,
      edge: this.cell,
      cell: this.cell
    }) : this.isNodeView() && this.notify("node:highlight", {
      magnet: n,
      options: t,
      view: this,
      node: this.cell,
      cell: this.cell
    }), this;
  }
  unhighlight(e, t = {}) {
    const n = this.prepareHighlight(e, t);
    return this.notify("cell:unhighlight", {
      magnet: n,
      options: t,
      view: this,
      cell: this.cell
    }), this.isNodeView() ? this.notify("node:unhighlight", {
      magnet: n,
      options: t,
      view: this,
      node: this.cell,
      cell: this.cell
    }) : this.isEdgeView() && this.notify("edge:unhighlight", {
      magnet: n,
      options: t,
      view: this,
      edge: this.cell,
      cell: this.cell
    }), this;
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  notifyUnhighlight(e, t) {
  }
  // #endregion
  getEdgeTerminal(e, t, n, i, r) {
    const o = this.cell, a = this.findAttr("port", e), l = e.getAttribute("data-selector"), c = { cell: o.id };
    return l != null && (c.magnet = l), a != null ? (c.port = a, o.isNode() && !o.hasPort(a) && l == null && (c.selector = this.getSelector(e))) : l == null && this.container !== e && (c.selector = this.getSelector(e)), c;
  }
  getMagnetFromEdgeTerminal(e) {
    const t = this.cell, n = this.container, i = e.port;
    let r = e.magnet, o;
    return i != null && t.isNode() && t.hasPort(i) ? o = this.findPortElem(i, r) || n : (r || (r = e.selector), !r && i != null && (r = '[port="'.concat(i, '"]')), o = this.findOne(r, n, this.selectors)), o;
  }
  hasTools(e) {
    const t = this.tools;
    return t == null ? !1 : e == null ? !0 : t.name === e;
  }
  addTools(e) {
    if (this.removeTools(), e) {
      if (!this.can("toolsAddable"))
        return this;
      const t = Le.isToolsView(e) ? e : new Le(e);
      this.tools = t, t.config({ view: this }), t.mount();
    }
    return this;
  }
  updateTools(e = {}) {
    return this.tools && this.tools.update(e), this;
  }
  removeTools() {
    return this.tools && (this.tools.remove(), this.tools = null), this;
  }
  hideTools() {
    return this.tools && this.tools.hide(), this;
  }
  showTools() {
    return this.tools && this.tools.show(), this;
  }
  renderTools() {
    const e = this.cell.getTools();
    return this.addTools(e), this;
  }
  notify(e, t) {
    return this.trigger(e, t), this.graph.trigger(e, t), this;
  }
  getEventArgs(e, t, n) {
    const i = this, r = i.cell;
    return t == null || n == null ? { e, view: i, cell: r } : { e, x: t, y: n, view: i, cell: r };
  }
  onClick(e, t, n) {
    this.notify("cell:click", this.getEventArgs(e, t, n));
  }
  onDblClick(e, t, n) {
    this.notify("cell:dblclick", this.getEventArgs(e, t, n));
  }
  onContextMenu(e, t, n) {
    this.notify("cell:contextmenu", this.getEventArgs(e, t, n));
  }
  onMouseDown(e, t, n) {
    this.cell.model && (this.cachedModelForMouseEvent = this.cell.model, this.cachedModelForMouseEvent.startBatch("mouse")), this.notify("cell:mousedown", this.getEventArgs(e, t, n));
  }
  onMouseUp(e, t, n) {
    this.notify("cell:mouseup", this.getEventArgs(e, t, n)), this.cachedModelForMouseEvent && (this.cachedModelForMouseEvent.stopBatch("mouse", { cell: this.cell }), this.cachedModelForMouseEvent = null);
  }
  onMouseMove(e, t, n) {
    this.notify("cell:mousemove", this.getEventArgs(e, t, n));
  }
  onMouseOver(e) {
    this.notify("cell:mouseover", this.getEventArgs(e));
  }
  onMouseOut(e) {
    this.notify("cell:mouseout", this.getEventArgs(e));
  }
  onMouseEnter(e) {
    this.notify("cell:mouseenter", this.getEventArgs(e));
  }
  onMouseLeave(e) {
    this.notify("cell:mouseleave", this.getEventArgs(e));
  }
  onMouseWheel(e, t, n, i) {
    this.notify("cell:mousewheel", Object.assign({ delta: i }, this.getEventArgs(e, t, n)));
  }
  onCustomEvent(e, t, n, i) {
    this.notify("cell:customevent", Object.assign({ name: t }, this.getEventArgs(e, n, i))), this.notify(t, Object.assign({}, this.getEventArgs(e, n, i)));
  }
  onMagnetMouseDown(e, t, n, i) {
  }
  onMagnetDblClick(e, t, n, i) {
  }
  onMagnetContextMenu(e, t, n, i) {
  }
  onLabelMouseDown(e, t, n) {
  }
  checkMouseleave(e) {
    const t = this.getEventTarget(e, { fromPoint: !0 }), n = this.graph.findViewByElem(t);
    n !== this && (this.onMouseLeave(e), n && n.onMouseEnter(e));
  }
  dispose() {
    this.cell.off("changed", this.onCellChanged, this);
  }
}
Pe.defaults = {
  isSvgElement: !0,
  rootSelector: "root",
  priority: 0,
  bootstrap: [],
  actions: {}
};
Jv([
  Pe.dispose()
], Pe.prototype, "dispose", null);
(function(s) {
  s.Flag = ng, s.Attr = tg;
})(Pe || (Pe = {}));
(function(s) {
  s.toStringTag = "X6.".concat(s.name);
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof s)
      return !0;
    const n = t[Symbol.toStringTag], i = t;
    return (n == null || n === s.toStringTag) && typeof i.isNodeView == "function" && typeof i.isEdgeView == "function" && typeof i.confirmUpdate == "function";
  }
  s.isCellView = e;
})(Pe || (Pe = {}));
(function(s) {
  function e(n) {
    return function(i) {
      i.config({ priority: n });
    };
  }
  s.priority = e;
  function t(n) {
    return function(i) {
      i.config({ bootstrap: n });
    };
  }
  s.bootstrap = t;
})(Pe || (Pe = {}));
(function(s) {
  s.registry = _e.create({
    type: "view"
  });
})(Pe || (Pe = {}));
class Le extends pe {
  get name() {
    return this.options.name;
  }
  get graph() {
    return this.cellView.graph;
  }
  get cell() {
    return this.cellView.cell;
  }
  get [Symbol.toStringTag]() {
    return Le.toStringTag;
  }
  constructor(e = {}) {
    super(), this.svgContainer = this.createContainer(!0, e), this.htmlContainer = this.createContainer(!1, e), this.config(e);
  }
  createContainer(e, t) {
    const n = e ? pe.createElement("g", !0) : pe.createElement("div", !1);
    return se(n, this.prefixClassName("cell-tools")), t.className && se(n, t.className), n;
  }
  config(e) {
    if (this.options = Object.assign(Object.assign({}, this.options), e), !Pe.isCellView(e.view) || e.view === this.cellView)
      return this;
    this.cellView = e.view, this.cell.isEdge() ? (se(this.svgContainer, this.prefixClassName("edge-tools")), se(this.htmlContainer, this.prefixClassName("edge-tools"))) : this.cell.isNode() && (se(this.svgContainer, this.prefixClassName("node-tools")), se(this.htmlContainer, this.prefixClassName("node-tools"))), this.svgContainer.setAttribute("data-cell-id", this.cell.id), this.htmlContainer.setAttribute("data-cell-id", this.cell.id), this.name && (this.svgContainer.setAttribute("data-tools-name", this.name), this.htmlContainer.setAttribute("data-tools-name", this.name));
    const t = this.options.items;
    if (!Array.isArray(t))
      return this;
    this.tools = [];
    const n = [];
    t.forEach((i) => {
      Le.ToolItem.isToolItem(i) ? i.name === "vertices" ? n.unshift(i) : n.push(i) : (typeof i == "object" ? i.name : i) === "vertices" ? n.unshift(i) : n.push(i);
    });
    for (let i = 0; i < n.length; i += 1) {
      const r = n[i];
      let o;
      if (Le.ToolItem.isToolItem(r))
        o = r;
      else {
        const a = typeof r == "object" ? r.name : r, l = typeof r == "object" ? r.args || {} : {};
        if (a) {
          if (this.cell.isNode()) {
            const c = Ks.registry.get(a);
            if (c)
              o = new c(l);
            else
              return Ks.registry.onNotFound(a);
          } else if (this.cell.isEdge()) {
            const c = Qs.registry.get(a);
            if (c)
              o = new c(l);
            else
              return Qs.registry.onNotFound(a);
          }
        }
      }
      o && (o.config(this.cellView, this), o.render(), (o.options.isSVGElement !== !1 ? this.svgContainer : this.htmlContainer).appendChild(o.container), this.tools.push(o));
    }
    return this;
  }
  update(e = {}) {
    const t = this.tools;
    return t && t.forEach((n) => {
      e.toolId !== n.cid && n.isVisible() && n.update();
    }), this;
  }
  focus(e) {
    const t = this.tools;
    return t && t.forEach((n) => {
      e === n ? n.show() : n.hide();
    }), this;
  }
  blur(e) {
    const t = this.tools;
    return t && t.forEach((n) => {
      n !== e && !n.isVisible() && (n.show(), n.update());
    }), this;
  }
  hide() {
    return this.focus(null);
  }
  show() {
    return this.blur(null);
  }
  remove() {
    const e = this.tools;
    return e && (e.forEach((t) => t.remove()), this.tools = null), Us(this.svgContainer), Us(this.htmlContainer), super.remove();
  }
  mount() {
    const e = this.tools, t = this.cellView;
    if (t && e) {
      const n = e.some((r) => r.options.isSVGElement !== !1), i = e.some((r) => r.options.isSVGElement === !1);
      n && (this.options.local ? t.container : t.graph.view.decorator).appendChild(this.svgContainer), i && this.graph.container.appendChild(this.htmlContainer);
    }
    return this;
  }
}
(function(s) {
  s.toStringTag = "X6.".concat(s.name);
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof s)
      return !0;
    const n = t[Symbol.toStringTag], i = t;
    return (n == null || n === s.toStringTag) && i.graph != null && i.cell != null && typeof i.config == "function" && typeof i.update == "function" && typeof i.focus == "function" && typeof i.blur == "function" && typeof i.show == "function" && typeof i.hide == "function";
  }
  s.isToolsView = e;
})(Le || (Le = {}));
(function(s) {
  class e extends pe {
    static getDefaults() {
      return this.defaults;
    }
    static config(n) {
      this.defaults = this.getOptions(n);
    }
    static getOptions(n) {
      return Te(Ce(this.getDefaults()), n);
    }
    get graph() {
      return this.cellView.graph;
    }
    get cell() {
      return this.cellView.cell;
    }
    get name() {
      return this.options.name;
    }
    get [Symbol.toStringTag]() {
      return e.toStringTag;
    }
    constructor(n = {}) {
      super(), this.visible = !0, this.options = this.getOptions(n), this.container = pe.createElement(this.options.tagName || "g", this.options.isSVGElement !== !1), se(this.container, this.prefixClassName("cell-tool")), typeof this.options.className == "string" && se(this.container, this.options.className), this.init();
    }
    init() {
    }
    getOptions(n) {
      return this.constructor.getOptions(n);
    }
    delegateEvents() {
      return this.options.events && super.delegateEvents(this.options.events), this;
    }
    config(n, i) {
      return this.cellView = n, this.parent = i, this.stamp(this.container), this.cell.isEdge() ? se(this.container, this.prefixClassName("edge-tool")) : this.cell.isNode() && se(this.container, this.prefixClassName("node-tool")), this.name && this.container.setAttribute("data-tool-name", this.name), this.delegateEvents(), this;
    }
    render() {
      this.empty();
      const n = this.options.markup;
      if (n) {
        const i = ge.parseJSONMarkup(n);
        this.container.appendChild(i.fragment), this.childNodes = i.selectors;
      }
      return this.onRender(), this;
    }
    onRender() {
    }
    update() {
      return this;
    }
    stamp(n) {
      n && n.setAttribute("data-cell-id", this.cellView.cell.id);
    }
    show() {
      return this.container.style.display = "", this.visible = !0, this;
    }
    hide() {
      return this.container.style.display = "none", this.visible = !1, this;
    }
    isVisible() {
      return this.visible;
    }
    focus() {
      const n = this.options.focusOpacity;
      return n != null && Number.isFinite(n) && (this.container.style.opacity = "".concat(n)), this.parent.focus(this), this;
    }
    blur() {
      return this.container.style.opacity = "", this.parent.blur(this), this;
    }
    guard(n) {
      return this.graph == null || this.cellView == null ? !0 : this.graph.view.guard(n, this.cellView);
    }
  }
  e.defaults = {
    isSVGElement: !0,
    tagName: "g"
  }, s.ToolItem = e, function(t) {
    let n = 0;
    function i(o) {
      return o ? Ul(o) : (n += 1, "CustomTool".concat(n));
    }
    function r(o) {
      const a = Vl(i(o.name), this);
      return a.config(o), a;
    }
    t.define = r;
  }(e = s.ToolItem || (s.ToolItem = {})), function(t) {
    t.toStringTag = "X6.".concat(t.name);
    function n(i) {
      if (i == null)
        return !1;
      if (i instanceof t)
        return !0;
      const r = i[Symbol.toStringTag], o = i;
      return (r == null || r === t.toStringTag) && o.graph != null && o.cell != null && typeof o.config == "function" && typeof o.update == "function" && typeof o.focus == "function" && typeof o.blur == "function" && typeof o.show == "function" && typeof o.hide == "function" && typeof o.isVisible == "function";
    }
    t.isToolItem = n;
  }(e = s.ToolItem || (s.ToolItem = {}));
})(Le || (Le = {}));
const Xv = (s) => s;
function Ph(s, e) {
  return e === 0 ? "0%" : "".concat(Math.round(s / e * 100), "%");
}
function sg(s) {
  return (t, n, i, r) => n.isEdgeElement(i) ? Kv(s, t, n, i, r) : Zv(s, t, n, i, r);
}
function Zv(s, e, t, n, i) {
  const r = t.cell, o = r.getAngle(), a = t.getUnrotatedBBoxOfElement(n), l = r.getBBox().getCenter(), c = S.create(i).rotate(o, l);
  let u = c.x - a.x, f = c.y - a.y;
  return s && (u = Ph(u, a.width), f = Ph(f, a.height)), e.anchor = {
    name: "topLeft",
    args: {
      dx: u,
      dy: f,
      rotate: !0
    }
  }, e;
}
function Kv(s, e, t, n, i) {
  const r = t.getConnection();
  if (!r)
    return e;
  const o = r.closestPointLength(i);
  if (s) {
    const a = r.length();
    e.anchor = {
      name: "ratio",
      args: {
        ratio: o / a
      }
    };
  } else
    e.anchor = {
      name: "length",
      args: {
        length: o
      }
    };
  return e;
}
const Qv = sg(!0), e6 = sg(!1), t6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  noop: Xv,
  pinAbsolute: e6,
  pinRelative: Qv
}, Symbol.toStringTag, { value: "Module" }));
var ol;
(function(s) {
  s.presets = t6, s.registry = _e.create({
    type: "connection strategy"
  }), s.registry.register(s.presets, !0);
})(ol || (ol = {}));
function ig(s, e, t, n) {
  return G(ol.presets.pinRelative, this.graph, {}, e, t, s, this.cell, n, {}).anchor;
}
function rg(s, e) {
  return e ? s.cell.getBBox() : s.cell.isEdge() ? s.getConnection().bbox() : s.getUnrotatedBBoxOfElement(s.container);
}
class Nn extends Le.ToolItem {
  onRender() {
    se(this.container, this.prefixClassName("cell-tool-button")), this.update();
  }
  update() {
    return this.updatePosition(), this;
  }
  updatePosition() {
    const t = this.cellView.cell.isEdge() ? this.getEdgeMatrix() : this.getNodeMatrix();
    qs(this.container, t, { absolute: !0 });
  }
  getNodeMatrix() {
    const e = this.cellView, t = this.options;
    let { x: n = 0, y: i = 0 } = t;
    const { offset: r, useCellGeometry: o, rotate: a } = t;
    let l = rg(e, o);
    const c = e.cell.getAngle();
    a || (l = l.bbox(c));
    let u = 0, f = 0;
    typeof r == "number" ? (u = r, f = r) : typeof r == "object" && (u = r.x, f = r.y), n = Ot(n, l.width), i = Ot(i, l.height);
    let d = Ve().translate(l.x + l.width / 2, l.y + l.height / 2);
    return a && (d = d.rotate(c)), d = d.translate(n + u - l.width / 2, i + f - l.height / 2), d;
  }
  getEdgeMatrix() {
    const e = this.cellView, t = this.options, { offset: n = 0, distance: i = 0, rotate: r } = t;
    let o, a, l;
    const c = Ot(i, 1);
    c >= 0 && c <= 1 ? o = e.getTangentAtRatio(c) : o = e.getTangentAtLength(c), o ? (a = o.start, l = o.vector().vectorAngle(new S(1, 0)) || 0) : (a = e.getConnection().start, l = 0);
    let u = Ve().translate(a.x, a.y).rotate(l);
    return typeof n == "object" ? u = u.translate(n.x || 0, n.y || 0) : u = u.translate(0, n), r || (u = u.rotate(-l)), u;
  }
  onMouseDown(e) {
    if (this.guard(e))
      return;
    e.stopPropagation(), e.preventDefault();
    const t = this.options.onClick;
    typeof t == "function" && G(t, this.cellView, {
      e,
      view: this.cellView,
      cell: this.cellView.cell,
      btn: this
    });
  }
}
(function(s) {
  s.config({
    name: "button",
    useCellGeometry: !0,
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown"
    }
  });
})(Nn || (Nn = {}));
(function(s) {
  s.Remove = s.define({
    name: "button-remove",
    markup: [
      {
        tagName: "circle",
        selector: "button",
        attrs: {
          r: 7,
          fill: "#FF1D00",
          cursor: "pointer"
        }
      },
      {
        tagName: "path",
        selector: "icon",
        attrs: {
          d: "M -3 -3 3 3 M -3 3 3 -3",
          fill: "none",
          stroke: "#FFFFFF",
          "stroke-width": 2,
          "pointer-events": "none"
        }
      }
    ],
    distance: 60,
    offset: 0,
    useCellGeometry: !0,
    onClick({ view: e, btn: t }) {
      t.parent.remove(), e.cell.remove({ ui: !0, toolId: t.cid });
    }
  });
})(Nn || (Nn = {}));
var n6 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
class go extends Le.ToolItem {
  onRender() {
    if (se(this.container, this.prefixClassName("cell-tool-boundary")), this.options.attrs) {
      const e = this.options.attrs, { class: t } = e, n = n6(e, ["class"]);
      ue(this.container, Xi(n)), t && se(this.container, t);
    }
    this.update();
  }
  update() {
    const e = this.cellView, t = this.options, { useCellGeometry: n, rotate: i } = t, r = us(t.padding);
    let o = rg(e, n).moveAndExpand({
      x: -r.left,
      y: -r.top,
      width: r.left + r.right,
      height: r.top + r.bottom
    });
    const a = e.cell;
    if (a.isNode()) {
      const l = a.getAngle();
      if (l)
        if (i) {
          const c = a.getBBox().getCenter();
          el(this.container, l, c.x, c.y, {
            absolute: !0
          });
        } else
          o = o.bbox(l);
    }
    return ue(this.container, o.toJSON()), this;
  }
}
(function(s) {
  s.config({
    name: "boundary",
    tagName: "rect",
    padding: 10,
    useCellGeometry: !0,
    attrs: {
      fill: "none",
      stroke: "#333",
      "stroke-width": 0.5,
      "stroke-dasharray": "5, 5",
      "pointer-events": "none"
    }
  });
})(go || (go = {}));
class tr extends Le.ToolItem {
  constructor() {
    super(...arguments), this.handles = [];
  }
  get vertices() {
    return this.cellView.cell.getVertices();
  }
  onRender() {
    return this.addClass(this.prefixClassName("edge-tool-vertices")), this.options.addable && this.updatePath(), this.resetHandles(), this.renderHandles(), this;
  }
  update() {
    return this.vertices.length === this.handles.length ? this.updateHandles() : (this.resetHandles(), this.renderHandles()), this.options.addable && this.updatePath(), this;
  }
  resetHandles() {
    const e = this.handles;
    this.handles = [], e && e.forEach((t) => {
      this.stopHandleListening(t), t.remove();
    });
  }
  renderHandles() {
    const e = this.vertices;
    for (let t = 0, n = e.length; t < n; t += 1) {
      const i = e[t], r = this.options.createHandle, o = this.options.processHandle, a = r({
        index: t,
        graph: this.graph,
        guard: (l) => this.guard(l),
        attrs: this.options.attrs || {}
      });
      o && o(a), a.updatePosition(i.x, i.y), this.stamp(a.container), this.container.appendChild(a.container), this.handles.push(a), this.startHandleListening(a);
    }
  }
  updateHandles() {
    const e = this.vertices;
    for (let t = 0, n = e.length; t < n; t += 1) {
      const i = e[t], r = this.handles[t];
      r && r.updatePosition(i.x, i.y);
    }
  }
  updatePath() {
    const e = this.childNodes.connection;
    e && e.setAttribute("d", this.cellView.getConnectionPathData());
  }
  startHandleListening(e) {
    const t = this.cellView;
    t.can("vertexMovable") && (e.on("change", this.onHandleChange, this), e.on("changing", this.onHandleChanging, this), e.on("changed", this.onHandleChanged, this)), t.can("vertexDeletable") && e.on("remove", this.onHandleRemove, this);
  }
  stopHandleListening(e) {
    const t = this.cellView;
    t.can("vertexMovable") && (e.off("change", this.onHandleChange, this), e.off("changing", this.onHandleChanging, this), e.off("changed", this.onHandleChanged, this)), t.can("vertexDeletable") && e.off("remove", this.onHandleRemove, this);
  }
  getNeighborPoints(e) {
    const t = this.cellView, n = this.vertices, i = e > 0 ? n[e - 1] : t.sourceAnchor, r = e < n.length - 1 ? n[e + 1] : t.targetAnchor;
    return {
      prev: S.create(i),
      next: S.create(r)
    };
  }
  getMouseEventArgs(e) {
    const t = this.normalizeEvent(e), { x: n, y: i } = this.graph.snapToGrid(t.clientX, t.clientY);
    return { e: t, x: n, y: i };
  }
  onHandleChange({ e }) {
    this.focus();
    const t = this.cellView;
    if (t.cell.startBatch("move-vertex", { ui: !0, toolId: this.cid }), !this.options.stopPropagation) {
      const { e: n, x: i, y: r } = this.getMouseEventArgs(e);
      this.eventData(n, { start: { x: i, y: r } }), t.notifyMouseDown(n, i, r);
    }
  }
  onHandleChanging({ handle: e, e: t }) {
    const n = this.cellView, i = e.options.index, { e: r, x: o, y: a } = this.getMouseEventArgs(t), l = { x: o, y: a };
    this.snapVertex(l, i), n.cell.setVertexAt(i, l, { ui: !0, toolId: this.cid }), e.updatePosition(l.x, l.y), this.options.stopPropagation || n.notifyMouseMove(r, o, a);
  }
  stopBatch(e) {
    this.cell.stopBatch("move-vertex", { ui: !0, toolId: this.cid }), e && this.cell.stopBatch("add-vertex", { ui: !0, toolId: this.cid });
  }
  onHandleChanged({ e }) {
    const t = this.options, n = this.cellView;
    if (t.addable && this.updatePath(), !t.removeRedundancies) {
      this.stopBatch(this.eventData(e).vertexAdded);
      return;
    }
    n.removeRedundantLinearVertices({
      ui: !0,
      toolId: this.cid
    }) && this.render(), this.blur(), this.stopBatch(this.eventData(e).vertexAdded);
    const { e: r, x: o, y: a } = this.getMouseEventArgs(e);
    if (!this.options.stopPropagation) {
      n.notifyMouseUp(r, o, a);
      const { start: l } = this.eventData(r);
      if (l) {
        const { x: c, y: u } = l;
        c === o && u === a && n.onClick(r, o, a);
      }
    }
    n.checkMouseleave(r), t.onChanged && t.onChanged({ edge: n.cell, edgeView: n });
  }
  snapVertex(e, t) {
    const n = this.options.snapRadius || 0;
    if (n > 0) {
      const i = this.getNeighborPoints(t), r = i.prev, o = i.next;
      Math.abs(e.x - r.x) < n ? e.x = r.x : Math.abs(e.x - o.x) < n && (e.x = o.x), Math.abs(e.y - r.y) < n ? e.y = i.prev.y : Math.abs(e.y - o.y) < n && (e.y = o.y);
    }
  }
  onHandleRemove({ handle: e, e: t }) {
    if (this.options.removable) {
      const n = e.options.index, i = this.cellView;
      i.cell.removeVertexAt(n, { ui: !0 }), this.options.addable && this.updatePath(), i.checkMouseleave(this.normalizeEvent(t));
    }
  }
  allowAddVertex(e) {
    const t = this.guard(e), n = this.options.addable && this.cellView.can("vertexAddable"), i = this.options.modifiers ? Gs.isMatch(e, this.options.modifiers) : !0;
    return !t && n && i;
  }
  onPathMouseDown(e) {
    const t = this.cellView;
    if (!this.allowAddVertex(e))
      return;
    e.stopPropagation(), e.preventDefault();
    const n = this.normalizeEvent(e), i = this.graph.snapToGrid(n.clientX, n.clientY).toJSON();
    t.cell.startBatch("add-vertex", { ui: !0, toolId: this.cid });
    const r = t.getVertexIndex(i.x, i.y);
    this.snapVertex(i, r), t.cell.insertVertex(i, r, {
      ui: !0,
      toolId: this.cid
    }), this.render();
    const o = this.handles[r];
    this.eventData(n, { vertexAdded: !0 }), o.onMouseDown(n);
  }
  onRemove() {
    this.resetHandles();
  }
}
(function(s) {
  class e extends pe {
    get graph() {
      return this.options.graph;
    }
    constructor(n) {
      super(), this.options = n, this.render(), this.delegateEvents({
        mousedown: "onMouseDown",
        touchstart: "onMouseDown",
        dblclick: "onDoubleClick"
      });
    }
    render() {
      this.container = pe.createElement("circle", !0);
      const n = this.options.attrs;
      if (typeof n == "function") {
        const i = s.getDefaults();
        this.setAttrs(Object.assign(Object.assign({}, i.attrs), n(this)));
      } else
        this.setAttrs(n);
      this.addClass(this.prefixClassName("edge-tool-vertex"));
    }
    updatePosition(n, i) {
      this.setAttrs({ cx: n, cy: i });
    }
    onMouseDown(n) {
      this.options.guard(n) || (n.stopPropagation(), n.preventDefault(), this.graph.view.undelegateEvents(), this.delegateDocumentEvents({
        mousemove: "onMouseMove",
        touchmove: "onMouseMove",
        mouseup: "onMouseUp",
        touchend: "onMouseUp",
        touchcancel: "onMouseUp"
      }, n.data), this.emit("change", { e: n, handle: this }));
    }
    onMouseMove(n) {
      this.emit("changing", { e: n, handle: this });
    }
    onMouseUp(n) {
      this.emit("changed", { e: n, handle: this }), this.undelegateDocumentEvents(), this.graph.view.delegateEvents();
    }
    onDoubleClick(n) {
      this.emit("remove", { e: n, handle: this });
    }
  }
  s.Handle = e;
})(tr || (tr = {}));
(function(s) {
  const e = Nt.prefix("edge-tool-vertex-path");
  s.config({
    name: "vertices",
    snapRadius: 20,
    addable: !0,
    removable: !0,
    removeRedundancies: !0,
    stopPropagation: !0,
    attrs: {
      r: 6,
      fill: "#333",
      stroke: "#fff",
      cursor: "move",
      "stroke-width": 2
    },
    createHandle: (t) => new s.Handle(t),
    markup: [
      {
        tagName: "path",
        selector: "connection",
        className: e,
        attrs: {
          fill: "none",
          stroke: "transparent",
          "stroke-width": 10,
          cursor: "pointer"
        }
      }
    ],
    events: {
      ["mousedown .".concat(e)]: "onPathMouseDown",
      ["touchstart .".concat(e)]: "onPathMouseDown"
    }
  });
})(tr || (tr = {}));
class nr extends Le.ToolItem {
  constructor() {
    super(...arguments), this.handles = [];
  }
  get vertices() {
    return this.cellView.cell.getVertices();
  }
  update() {
    return this.render(), this;
  }
  onRender() {
    se(this.container, this.prefixClassName("edge-tool-segments")), this.resetHandles();
    const e = this.cellView, t = [...this.vertices];
    t.unshift(e.sourcePoint), t.push(e.targetPoint);
    for (let n = 0, i = t.length; n < i - 1; n += 1) {
      const r = t[n], o = t[n + 1], a = this.renderHandle(r, o, n);
      this.stamp(a.container), this.handles.push(a);
    }
    return this;
  }
  renderHandle(e, t, n) {
    const i = this.options.createHandle({
      index: n,
      graph: this.graph,
      guard: (r) => this.guard(r),
      attrs: this.options.attrs || {}
    });
    return this.options.processHandle && this.options.processHandle(i), this.updateHandle(i, e, t), this.container.appendChild(i.container), this.startHandleListening(i), i;
  }
  startHandleListening(e) {
    e.on("change", this.onHandleChange, this), e.on("changing", this.onHandleChanging, this), e.on("changed", this.onHandleChanged, this);
  }
  stopHandleListening(e) {
    e.off("change", this.onHandleChange, this), e.off("changing", this.onHandleChanging, this), e.off("changed", this.onHandleChanged, this);
  }
  resetHandles() {
    const e = this.handles;
    this.handles = [], e && e.forEach((t) => {
      this.stopHandleListening(t), t.remove();
    });
  }
  shiftHandleIndexes(e) {
    const t = this.handles;
    for (let n = 0, i = t.length; n < i; n += 1)
      t[n].options.index += e;
  }
  resetAnchor(e, t) {
    const n = this.cellView.cell, i = {
      ui: !0,
      toolId: this.cid
    };
    t ? n.prop([e, "anchor"], t, i) : n.removeProp([e, "anchor"], i);
  }
  snapHandle(e, t, n) {
    const i = e.options.axis, r = e.options.index, l = this.cellView.cell.getVertices(), c = l[r - 2] || n.sourceAnchor, u = l[r + 1] || n.targetAnchor, f = this.options.snapRadius;
    return Math.abs(t[i] - c[i]) < f ? t[i] = c[i] : Math.abs(t[i] - u[i]) < f && (t[i] = u[i]), t;
  }
  onHandleChanging({ handle: e, e: t }) {
    const n = this.graph, i = this.options, r = this.cellView, o = i.anchor, a = e.options.axis, l = e.options.index - 1, c = this.getEventData(t), u = this.normalizeEvent(t), f = n.snapToGrid(u.clientX, u.clientY), d = this.snapHandle(e, f.clone(), c), g = Ce(this.vertices);
    let p = g[l], m = g[l + 1];
    const w = r.sourceView, v = r.sourceBBox;
    let y = !1, b = !1;
    if (p ? l === 0 ? v.containsPoint(p) ? (g.shift(), this.shiftHandleIndexes(-1), y = !0) : (p[a] = d[a], b = !0) : p[a] = d[a] : (p = r.sourceAnchor.toJSON(), p[a] = d[a], v.containsPoint(p) ? y = !0 : (g.unshift(p), this.shiftHandleIndexes(1), b = !0)), typeof o == "function" && w) {
      if (y) {
        const O = c.sourceAnchor.clone();
        O[a] = d[a];
        const k = G(o, r, O, w, r.sourceMagnet || w.container, "source", r, this);
        this.resetAnchor("source", k);
      }
      b && this.resetAnchor("source", c.sourceAnchorDef);
    }
    const x = r.targetView, C = r.targetBBox;
    let A = !1, P = !1;
    if (m ? l === g.length - 2 ? C.containsPoint(m) ? (g.pop(), A = !0) : (m[a] = d[a], P = !0) : m[a] = d[a] : (m = r.targetAnchor.toJSON(), m[a] = d[a], C.containsPoint(m) ? A = !0 : (g.push(m), P = !0)), typeof o == "function" && x) {
      if (A) {
        const O = c.targetAnchor.clone();
        O[a] = d[a];
        const k = G(o, r, O, x, r.targetMagnet || x.container, "target", r, this);
        this.resetAnchor("target", k);
      }
      P && this.resetAnchor("target", c.targetAnchorDef);
    }
    S.equalPoints(g, this.vertices) || this.cellView.cell.setVertices(g, { ui: !0, toolId: this.cid }), this.updateHandle(e, p, m, 0), i.stopPropagation || r.notifyMouseMove(u, f.x, f.y);
  }
  onHandleChange({ handle: e, e: t }) {
    const n = this.options, i = this.handles, r = this.cellView, o = e.options.index;
    if (Array.isArray(i)) {
      for (let a = 0, l = i.length; a < l; a += 1)
        a !== o && i[a].hide();
      if (this.focus(), this.setEventData(t, {
        sourceAnchor: r.sourceAnchor.clone(),
        targetAnchor: r.targetAnchor.clone(),
        sourceAnchorDef: Ce(this.cell.prop(["source", "anchor"])),
        targetAnchorDef: Ce(this.cell.prop(["target", "anchor"]))
      }), this.cell.startBatch("move-segment", { ui: !0, toolId: this.cid }), !n.stopPropagation) {
        const a = this.normalizeEvent(t), l = this.graph.snapToGrid(a.clientX, a.clientY);
        r.notifyMouseDown(a, l.x, l.y);
      }
    }
  }
  onHandleChanged({ e }) {
    const t = this.options, n = this.cellView;
    t.removeRedundancies && n.removeRedundantLinearVertices({ ui: !0, toolId: this.cid });
    const i = this.normalizeEvent(e), r = this.graph.snapToGrid(i.clientX, i.clientY);
    this.render(), this.blur(), this.cell.stopBatch("move-segment", { ui: !0, toolId: this.cid }), t.stopPropagation || n.notifyMouseUp(i, r.x, r.y), n.checkMouseleave(i), t.onChanged && t.onChanged({ edge: n.cell, edgeView: n });
  }
  updateHandle(e, t, n, i = 0) {
    const r = this.options.precision || 0, o = Math.abs(t.x - n.x) < r, a = Math.abs(t.y - n.y) < r;
    if (o || a) {
      const l = new $(t, n);
      if (l.length() < this.options.threshold)
        e.hide();
      else {
        const u = l.getCenter(), f = o ? "x" : "y";
        u[f] += i || 0;
        const d = l.vector().vectorAngle(new S(1, 0));
        e.updatePosition(u.x, u.y, d, this.cellView), e.show(), e.options.axis = f;
      }
    } else
      e.hide();
  }
  onRemove() {
    this.resetHandles();
  }
}
(function(s) {
  class e extends pe {
    constructor(n) {
      super(), this.options = n, this.render(), this.delegateEvents({
        mousedown: "onMouseDown",
        touchstart: "onMouseDown"
      });
    }
    render() {
      this.container = pe.createElement("rect", !0);
      const n = this.options.attrs;
      if (typeof n == "function") {
        const i = s.getDefaults();
        this.setAttrs(Object.assign(Object.assign({}, i.attrs), n(this)));
      } else
        this.setAttrs(n);
      this.addClass(this.prefixClassName("edge-tool-segment"));
    }
    updatePosition(n, i, r, o) {
      const a = o.getClosestPoint(new S(n, i)) || new S(n, i);
      let l = Ve().translate(a.x, a.y);
      if (a.equals({ x: n, y: i }))
        l = l.rotate(r);
      else {
        let u = new $(n, i, a.x, a.y).vector().vectorAngle(new S(1, 0));
        u !== 0 && (u += 90), l = l.rotate(u);
      }
      this.setAttrs({
        transform: pi(l),
        cursor: r % 180 === 0 ? "row-resize" : "col-resize"
      });
    }
    onMouseDown(n) {
      this.options.guard(n) || (this.trigger("change", { e: n, handle: this }), n.stopPropagation(), n.preventDefault(), this.options.graph.view.undelegateEvents(), this.delegateDocumentEvents({
        mousemove: "onMouseMove",
        touchmove: "onMouseMove",
        mouseup: "onMouseUp",
        touchend: "onMouseUp",
        touchcancel: "onMouseUp"
      }, n.data));
    }
    onMouseMove(n) {
      this.emit("changing", { e: n, handle: this });
    }
    onMouseUp(n) {
      this.emit("changed", { e: n, handle: this }), this.undelegateDocumentEvents(), this.options.graph.view.delegateEvents();
    }
    show() {
      this.container.style.display = "";
    }
    hide() {
      this.container.style.display = "none";
    }
  }
  s.Handle = e;
})(nr || (nr = {}));
(function(s) {
  s.config({
    name: "segments",
    precision: 0.5,
    threshold: 40,
    snapRadius: 10,
    stopPropagation: !0,
    removeRedundancies: !0,
    attrs: {
      width: 20,
      height: 8,
      x: -10,
      y: -4,
      rx: 4,
      ry: 4,
      fill: "#333",
      stroke: "#fff",
      "stroke-width": 2
    },
    createHandle: (e) => new s.Handle(e),
    anchor: ig
  });
})(nr || (nr = {}));
class po extends Le.ToolItem {
  get type() {
    return this.options.type;
  }
  onRender() {
    se(this.container, this.prefixClassName("edge-tool-".concat(this.type, "-anchor"))), this.toggleArea(!1), this.update();
  }
  update() {
    const e = this.type;
    return this.cellView.getTerminalView(e) ? (this.updateAnchor(), this.updateArea(), this.container.style.display = "") : this.container.style.display = "none", this;
  }
  updateAnchor() {
    const e = this.childNodes;
    if (!e)
      return;
    const t = e.anchor;
    if (!t)
      return;
    const n = this.type, i = this.cellView, r = this.options, o = i.getTerminalAnchor(n), a = i.cell.prop([n, "anchor"]);
    t.setAttribute("transform", "translate(".concat(o.x, ", ").concat(o.y, ")"));
    const l = a ? r.customAnchorAttrs : r.defaultAnchorAttrs;
    l && Object.keys(l).forEach((c) => {
      t.setAttribute(c, l[c]);
    });
  }
  updateArea() {
    const e = this.childNodes;
    if (!e)
      return;
    const t = e.area;
    if (!t)
      return;
    const n = this.type, i = this.cellView, r = i.getTerminalView(n);
    if (r) {
      const o = r.cell, a = i.getTerminalMagnet(n);
      let l = this.options.areaPadding || 0;
      Number.isFinite(l) || (l = 0);
      let c, u, f;
      r.isEdgeElement(a) ? (c = r.getBBox(), u = 0, f = c.getCenter()) : (c = r.getUnrotatedBBoxOfElement(a), u = o.getAngle(), f = c.getCenter(), u && f.rotate(-u, o.getBBox().getCenter())), c.inflate(l), ue(t, {
        x: -c.width / 2,
        y: -c.height / 2,
        width: c.width,
        height: c.height,
        transform: "translate(".concat(f.x, ", ").concat(f.y, ") rotate(").concat(u, ")")
      });
    }
  }
  toggleArea(e) {
    if (this.childNodes) {
      const t = this.childNodes.area;
      t && (t.style.display = e ? "" : "none");
    }
  }
  onMouseDown(e) {
    this.guard(e) || (e.stopPropagation(), e.preventDefault(), this.graph.view.undelegateEvents(), this.options.documentEvents && this.delegateDocumentEvents(this.options.documentEvents), this.focus(), this.toggleArea(this.options.restrictArea), this.cell.startBatch("move-anchor", {
      ui: !0,
      toolId: this.cid
    }));
  }
  resetAnchor(e) {
    const t = this.type, n = this.cell;
    e ? n.prop([t, "anchor"], e, {
      rewrite: !0,
      ui: !0,
      toolId: this.cid
    }) : n.removeProp([t, "anchor"], {
      ui: !0,
      toolId: this.cid
    });
  }
  onMouseMove(e) {
    const t = this.type, n = this.cellView, i = n.getTerminalView(t);
    if (i == null)
      return;
    const r = this.normalizeEvent(e), o = i.cell, a = n.getTerminalMagnet(t);
    let l = this.graph.coord.clientToLocalPoint(r.clientX, r.clientY);
    const c = this.options.snap;
    if (typeof c == "function") {
      const d = G(c, n, l, i, a, t, n, this);
      l = S.create(d);
    }
    if (this.options.restrictArea)
      if (i.isEdgeElement(a)) {
        const d = i.getClosestPoint(l);
        d && (l = d);
      } else {
        const d = i.getUnrotatedBBoxOfElement(a), g = o.getAngle(), p = o.getBBox().getCenter(), m = l.clone().rotate(g, p);
        d.containsPoint(m) || (l = d.getNearestPointToPoint(m).rotate(-g, p));
      }
    let u;
    const f = this.options.anchor;
    typeof f == "function" && (u = G(f, n, l, i, a, t, n, this)), this.resetAnchor(u), this.update();
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onMouseUp(e) {
    this.graph.view.delegateEvents(), this.undelegateDocumentEvents(), this.blur(), this.toggleArea(!1);
    const t = this.cellView;
    this.options.removeRedundancies && t.removeRedundantLinearVertices({ ui: !0, toolId: this.cid }), this.cell.stopBatch("move-anchor", { ui: !0, toolId: this.cid });
  }
  onDblClick() {
    const e = this.options.resetAnchor;
    e && this.resetAnchor(e === !0 ? void 0 : e), this.update();
  }
}
(function(s) {
  s.config({
    tagName: "g",
    markup: [
      {
        tagName: "circle",
        selector: "anchor",
        attrs: {
          cursor: "pointer"
        }
      },
      {
        tagName: "rect",
        selector: "area",
        attrs: {
          "pointer-events": "none",
          fill: "none",
          stroke: "#33334F",
          "stroke-dasharray": "2,4",
          rx: 5,
          ry: 5
        }
      }
    ],
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown",
      dblclick: "onDblClick"
    },
    documentEvents: {
      mousemove: "onMouseMove",
      touchmove: "onMouseMove",
      mouseup: "onMouseUp",
      touchend: "onMouseUp",
      touchcancel: "onMouseUp"
    },
    customAnchorAttrs: {
      "stroke-width": 4,
      stroke: "#33334F",
      fill: "#FFFFFF",
      r: 5
    },
    defaultAnchorAttrs: {
      "stroke-width": 2,
      stroke: "#FFFFFF",
      fill: "#33334F",
      r: 6
    },
    areaPadding: 6,
    snapRadius: 10,
    resetAnchor: !0,
    restrictArea: !0,
    removeRedundancies: !0,
    anchor: ig,
    snap(e, t, n, i, r, o) {
      const a = o.options.snapRadius || 0, l = i === "source", c = l ? 0 : -1, u = this.cell.getVertexAt(c) || this.getTerminalAnchor(l ? "target" : "source");
      return u && (Math.abs(u.x - e.x) < a && (e.x = u.x), Math.abs(u.y - e.y) < a && (e.y = u.y)), e;
    }
  });
})(po || (po = {}));
const s6 = po.define({
  name: "source-anchor",
  type: "source"
}), i6 = po.define({
  name: "target-anchor",
  type: "target"
});
var r6 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
class mo extends Le.ToolItem {
  get type() {
    return this.options.type;
  }
  get ratio() {
    return this.options.ratio;
  }
  init() {
    if (this.options.attrs) {
      const e = this.options.attrs, { class: t } = e, n = r6(e, ["class"]);
      this.setAttrs(n, this.container), t && se(this.container, t);
    }
  }
  onRender() {
    se(this.container, this.prefixClassName("edge-tool-".concat(this.type, "-arrowhead"))), this.update();
  }
  update() {
    const e = this.ratio, t = this.cellView, n = t.getTangentAtRatio(e), i = n ? n.start : t.getPointAtRatio(e), r = n && n.vector().vectorAngle(new S(1, 0)) || 0;
    if (!i)
      return this;
    const o = Ve().translate(i.x, i.y).rotate(r);
    return qs(this.container, o, { absolute: !0 }), this;
  }
  onMouseDown(e) {
    if (this.guard(e))
      return;
    e.stopPropagation(), e.preventDefault();
    const t = this.cellView;
    if (t.can("arrowheadMovable")) {
      t.cell.startBatch("move-arrowhead", {
        ui: !0,
        toolId: this.cid
      });
      const n = this.graph.snapToGrid(e.clientX, e.clientY), i = t.prepareArrowheadDragging(this.type, {
        x: n.x,
        y: n.y,
        options: Object.assign(Object.assign({}, this.options), { toolId: this.cid })
      });
      this.cellView.setEventData(e, i), this.delegateDocumentEvents(this.options.documentEvents, e.data), t.graph.view.undelegateEvents(), this.container.style.pointerEvents = "none";
    }
    this.focus();
  }
  onMouseMove(e) {
    const t = this.normalizeEvent(e), n = this.graph.snapToGrid(t.clientX, t.clientY);
    this.cellView.onMouseMove(t, n.x, n.y), this.update();
  }
  onMouseUp(e) {
    this.undelegateDocumentEvents();
    const t = this.normalizeEvent(e), n = this.cellView, i = this.graph.snapToGrid(t.clientX, t.clientY);
    n.onMouseUp(t, i.x, i.y), this.graph.view.delegateEvents(), this.blur(), this.container.style.pointerEvents = "", n.cell.stopBatch("move-arrowhead", {
      ui: !0,
      toolId: this.cid
    });
  }
}
(function(s) {
  s.config({
    tagName: "path",
    isSVGElement: !0,
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown"
    },
    documentEvents: {
      mousemove: "onMouseMove",
      touchmove: "onMouseMove",
      mouseup: "onMouseUp",
      touchend: "onMouseUp",
      touchcancel: "onMouseUp"
    }
  });
})(mo || (mo = {}));
const o6 = mo.define({
  name: "source-arrowhead",
  type: "source",
  ratio: 0,
  attrs: {
    d: "M 10 -8 -10 0 10 8 Z",
    fill: "#333",
    stroke: "#fff",
    "stroke-width": 2,
    cursor: "move"
  }
}), a6 = mo.define({
  name: "target-arrowhead",
  type: "target",
  ratio: 1,
  attrs: {
    d: "M -10 -8 10 0 -10 8 Z",
    fill: "#333",
    stroke: "#fff",
    "stroke-width": 2,
    cursor: "move"
  }
});
class Zs extends Le.ToolItem {
  constructor() {
    super(...arguments), this.labelIndex = -1, this.distance = 0.5, this.dblClick = this.onCellDblClick.bind(this);
  }
  onRender() {
    const e = this.cellView;
    e && e.on("cell:dblclick", this.dblClick);
  }
  createElement() {
    const e = [
      this.prefixClassName("".concat(this.cell.isEdge() ? "edge" : "node", "-tool-editor")),
      this.prefixClassName("cell-tool-editor")
    ];
    this.editor = Le.createElement("div", !1), this.addClass(e, this.editor), this.editor.contentEditable = "true", this.container.appendChild(this.editor);
  }
  removeElement() {
    this.undelegateDocumentEvents(), this.editor && (this.container.removeChild(this.editor), this.editor = null);
  }
  updateEditor() {
    const { cell: e, editor: t } = this;
    if (!t)
      return;
    const { style: n } = t;
    e.isNode() ? this.updateNodeEditorTransform() : e.isEdge() && this.updateEdgeEditorTransform();
    const { attrs: i } = this.options;
    n.fontSize = "".concat(i.fontSize, "px"), n.fontFamily = i.fontFamily, n.color = i.color, n.backgroundColor = i.backgroundColor;
    const r = this.getCellText() || "";
    return t.innerText = r, this.setCellText(""), this;
  }
  updateNodeEditorTransform() {
    const { graph: e, cell: t, editor: n } = this;
    if (!n)
      return;
    let i = S.create(), r = 20, o = "", { x: a, y: l } = this.options;
    const { width: c, height: u } = this.options;
    if (typeof a < "u" && typeof l < "u") {
      const g = t.getBBox();
      a = Ot(a, g.width), l = Ot(l, g.height), i = g.topLeft.translate(a, l), r = g.width - a * 2;
    } else {
      const g = t.getBBox();
      i = g.center, r = g.width - 4, o = "translate(-50%, -50%)";
    }
    const f = e.scale(), { style: d } = n;
    i = e.localToGraph(i), d.left = "".concat(i.x, "px"), d.top = "".concat(i.y, "px"), d.transform = "scale(".concat(f.sx, ", ").concat(f.sy, ") ").concat(o), d.minWidth = "".concat(r, "px"), typeof c == "number" && (d.width = "".concat(c, "px")), typeof u == "number" && (d.height = "".concat(u, "px"));
  }
  updateEdgeEditorTransform() {
    if (!this.event)
      return;
    const { graph: e, editor: t } = this;
    if (!t)
      return;
    let n = S.create(), i = 20;
    const { style: r } = t, o = this.event.target, a = o.parentElement;
    if (a && gr(a, this.prefixClassName("edge-label"))) {
      const u = a.getAttribute("data-index") || "0";
      this.labelIndex = parseInt(u, 10);
      const f = a.getAttribute("transform"), { translation: d } = $o(f);
      n = new S(d.tx, d.ty), i = re.getBBox(o).width;
    } else {
      if (!this.options.labelAddable)
        return this;
      n = e.clientToLocal(S.create(this.event.clientX, this.event.clientY));
      const f = this.cellView.path.closestPointLength(n);
      this.distance = f, this.labelIndex = -1;
    }
    n = e.localToGraph(n);
    const c = e.scale();
    r.left = "".concat(n.x, "px"), r.top = "".concat(n.y, "px"), r.minWidth = "".concat(i, "px"), r.transform = "scale(".concat(c.sx, ", ").concat(c.sy, ") translate(-50%, -50%)");
  }
  onDocumentMouseUp(e) {
    if (this.editor && e.target !== this.editor) {
      const t = this.editor.innerText.replace(/\n$/, "") || "";
      this.setCellText(t !== "" ? t : null), this.removeElement();
    }
  }
  onCellDblClick({ e }) {
    this.editor || (e.stopPropagation(), this.removeElement(), this.event = e, this.createElement(), this.updateEditor(), this.autoFocus(), this.delegateDocumentEvents(this.options.documentEvents));
  }
  onMouseDown(e) {
    e.stopPropagation();
  }
  autoFocus() {
    setTimeout(() => {
      this.editor && (this.editor.focus(), this.selectText());
    });
  }
  selectText() {
    if (window.getSelection && this.editor) {
      const e = document.createRange(), t = window.getSelection();
      e.selectNodeContents(this.editor), t.removeAllRanges(), t.addRange(e);
    }
  }
  getCellText() {
    const { getText: e } = this.options;
    if (typeof e == "function")
      return G(e, this.cellView, {
        cell: this.cell,
        index: this.labelIndex
      });
    if (typeof e == "string") {
      if (this.cell.isNode())
        return this.cell.attr(e);
      if (this.cell.isEdge() && this.labelIndex !== -1)
        return this.cell.prop("labels/".concat(this.labelIndex, "/attrs/").concat(e));
    }
  }
  setCellText(e) {
    const t = this.options.setText;
    if (typeof t == "function") {
      G(t, this.cellView, {
        cell: this.cell,
        value: e,
        index: this.labelIndex,
        distance: this.distance
      });
      return;
    }
    if (typeof t == "string") {
      if (this.cell.isNode()) {
        e !== null && this.cell.attr(t, e);
        return;
      }
      if (this.cell.isEdge()) {
        const n = this.cell;
        if (this.labelIndex === -1) {
          if (e) {
            const i = {
              position: {
                distance: this.distance
              },
              attrs: {}
            };
            gi(i, "attrs/".concat(t), e), n.appendLabel(i);
          }
        } else
          e !== null ? n.prop("labels/".concat(this.labelIndex, "/attrs/").concat(t), e) : typeof this.labelIndex == "number" && n.removeLabelAt(this.labelIndex);
      }
    }
  }
  onRemove() {
    const e = this.cellView;
    e && e.off("cell:dblclick", this.dblClick), this.removeElement();
  }
}
(function(s) {
  s.config({
    tagName: "div",
    isSVGElement: !1,
    events: {
      mousedown: "onMouseDown",
      touchstart: "onMouseDown"
    },
    documentEvents: {
      mouseup: "onDocumentMouseUp",
      touchend: "onDocumentMouseUp",
      touchcancel: "onDocumentMouseUp"
    }
  });
})(Zs || (Zs = {}));
(function(s) {
  s.NodeEditor = s.define({
    attrs: {
      fontSize: 14,
      fontFamily: "Arial, helvetica, sans-serif",
      color: "#000",
      backgroundColor: "#fff"
    },
    getText: "text/text",
    setText: "text/text"
  }), s.EdgeEditor = s.define({
    attrs: {
      fontSize: 14,
      fontFamily: "Arial, helvetica, sans-serif",
      color: "#000",
      backgroundColor: "#fff"
    },
    labelAddable: !0,
    getText: "label/text",
    setText: "label/text"
  });
})(Zs || (Zs = {}));
var og = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
}, Ks;
(function(s) {
  s.presets = {
    boundary: go,
    button: Nn,
    "button-remove": Nn.Remove,
    "node-editor": Zs.NodeEditor
  }, s.registry = _e.create({
    type: "node tool",
    process(e, t) {
      if (typeof t == "function")
        return t;
      let n = Le.ToolItem;
      const { inherit: i } = t, r = og(t, ["inherit"]);
      if (i) {
        const o = this.get(i);
        o == null ? this.onNotFound(i, "inherited") : n = o;
      }
      return r.name == null && (r.name = e), n.define.call(n, r);
    }
  }), s.registry.register(s.presets, !0);
})(Ks || (Ks = {}));
var Qs;
(function(s) {
  s.presets = {
    boundary: go,
    vertices: tr,
    segments: nr,
    button: Nn,
    "button-remove": Nn.Remove,
    "source-anchor": s6,
    "target-anchor": i6,
    "source-arrowhead": o6,
    "target-arrowhead": a6,
    "edge-editor": Zs.EdgeEditor
  }, s.registry = _e.create({
    type: "edge tool",
    process(e, t) {
      if (typeof t == "function")
        return t;
      let n = Le.ToolItem;
      const { inherit: i } = t, r = og(t, ["inherit"]);
      if (i) {
        const o = this.get(i);
        o == null ? this.onNotFound(i, "inherited") : n = o;
      }
      return r.name == null && (r.name = e), n.define.call(n, r);
    }
  }), s.registry.register(s.presets, !0);
})(Qs || (Qs = {}));
const l6 = pn("center"), c6 = pn("topCenter"), h6 = pn("bottomCenter"), u6 = pn("leftMiddle"), d6 = pn("rightMiddle"), f6 = pn("topLeft"), g6 = pn("topRight"), p6 = pn("bottomLeft"), m6 = pn("bottomRight");
function pn(s) {
  return function(e, t, n, i = {}) {
    const r = i.rotate ? e.getUnrotatedBBoxOfElement(t) : e.getBBoxOfElement(t), o = r[s];
    o.x += Ot(i.dx, r.width), o.y += Ot(i.dy, r.height);
    const a = e.cell;
    return i.rotate ? o.rotate(-a.getAngle(), a.getBBox().getCenter()) : o;
  };
}
function Ho(s) {
  return function(e, t, n, i) {
    if (n instanceof Element) {
      const r = this.graph.findViewByElem(n);
      let o;
      if (r)
        if (r.isEdgeElement(n)) {
          const a = i.fixedAt != null ? i.fixedAt : "50%";
          o = ag(r, a);
        } else
          o = r.getBBoxOfElement(n).getCenter();
      else
        o = new S();
      return s.call(this, e, t, o, i);
    }
    return s.apply(this, arguments);
  };
}
function ag(s, e) {
  const t = ln(e), n = typeof e == "string" ? parseFloat(e) : e;
  return t ? s.getPointAtRatio(n / 100) : s.getPointAtLength(n);
}
const w6 = function(s, e, t, n) {
  const i = ce.normalize(s.cell.getAngle()), r = s.getBBoxOfElement(e), o = r.getCenter(), a = r.getTopLeft(), l = r.getBottomRight();
  let c = n.padding;
  if (Number.isFinite(c) || (c = 0), a.y + c <= t.y && t.y <= l.y - c) {
    const u = t.y - o.y;
    o.x += i === 0 || i === 180 ? 0 : u * 1 / Math.tan(ce.toRad(i)), o.y += u;
  } else if (a.x + c <= t.x && t.x <= l.x - c) {
    const u = t.x - o.x;
    o.y += i === 90 || i === 270 ? 0 : u * Math.tan(ce.toRad(i)), o.x += u;
  }
  return o;
}, y6 = Ho(w6), b6 = function(s, e, t, n, i) {
  const r = s.cell.getConnectionPoint(this.cell, i);
  return (n.dx || n.dy) && r.translate(n.dx || 0, n.dy || 0), r;
}, v6 = function(s, e, t, n) {
  let i, r = 0, o;
  const a = s.cell;
  n.rotate ? (i = s.getUnrotatedBBoxOfElement(e), o = a.getBBox().getCenter(), r = a.getAngle()) : i = s.getBBoxOfElement(e);
  const l = n.padding;
  l != null && Number.isFinite(l) && i.inflate(l), n.rotate && t.rotate(r, o);
  const c = i.getNearestSideToPoint(t);
  let u;
  switch (c) {
    case "left":
      u = i.getLeftMiddle();
      break;
    case "right":
      u = i.getRightMiddle();
      break;
    case "top":
      u = i.getTopCenter();
      break;
    case "bottom":
      u = i.getBottomCenter();
      break;
  }
  const f = n.direction;
  return f === "H" ? (c === "top" || c === "bottom") && (t.x <= i.x + i.width ? u = i.getLeftMiddle() : u = i.getRightMiddle()) : f === "V" && (t.y <= i.y + i.height ? u = i.getTopCenter() : u = i.getBottomCenter()), n.rotate ? u.rotate(-r, o) : u;
}, x6 = Ho(v6), C6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  bottom: h6,
  bottomLeft: p6,
  bottomRight: m6,
  center: l6,
  left: u6,
  midSide: x6,
  nodeCenter: b6,
  orth: y6,
  right: d6,
  top: c6,
  topLeft: f6,
  topRight: g6
}, Symbol.toStringTag, { value: "Module" }));
var ei;
(function(s) {
  s.presets = C6, s.registry = _e.create({
    type: "node endpoint"
  }), s.registry.register(s.presets, !0);
})(ei || (ei = {}));
const E6 = function(s, e, t, n) {
  let i = n.ratio != null ? n.ratio : 0.5;
  return i > 1 && (i /= 100), s.getPointAtRatio(i);
}, S6 = function(s, e, t, n) {
  const i = n.length != null ? n.length : 20;
  return s.getPointAtLength(i);
}, lg = function(s, e, t, n) {
  const i = s.getClosestPoint(t);
  return i != null ? i : new S();
}, A6 = Ho(lg), M6 = function(s, e, t, n) {
  const r = s.getConnection(), o = s.getConnectionSubdivisions(), a = new $(t.clone().translate(0, 1e6), t.clone().translate(0, -1e6)), l = new $(t.clone().translate(1e6, 0), t.clone().translate(-1e6, 0)), c = a.intersect(r, {
    segmentSubdivisions: o
  }), u = l.intersect(r, {
    segmentSubdivisions: o
  }), f = [];
  return c && f.push(...c), u && f.push(...u), f.length > 0 ? t.closest(f) : n.fallbackAt != null ? ag(s, n.fallbackAt) : G(lg, this, s, e, t, n);
}, k6 = Ho(M6), P6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  closest: A6,
  length: S6,
  orth: k6,
  ratio: E6
}, Symbol.toStringTag, { value: "Module" }));
var ti;
(function(s) {
  s.presets = P6, s.registry = _e.create({
    type: "edge endpoint"
  }), s.registry.register(s.presets, !0);
})(ti || (ti = {}));
function Uo(s, e, t) {
  let n;
  if (typeof t == "object") {
    if (Number.isFinite(t.y)) {
      const r = new $(e, s), { start: o, end: a } = r.parallel(t.y);
      e = o, s = a;
    }
    n = t.x;
  } else
    n = t;
  if (n == null || !Number.isFinite(n))
    return s;
  const i = s.distance(e);
  return n === 0 && i > 0 ? s : s.move(e, -Math.min(n, i - 1));
}
function wo(s) {
  const e = s.getAttribute("stroke-width");
  return e === null ? 0 : parseFloat(e) || 0;
}
function _6(s) {
  if (s == null)
    return null;
  let e = s;
  do {
    let t = e.tagName;
    if (typeof t != "string")
      return null;
    if (t = t.toUpperCase(), t === "G")
      e = e.firstElementChild;
    else if (t === "TITLE")
      e = e.nextElementSibling;
    else
      break;
  } while (e);
  return e;
}
const cg = function(s, e, t, n) {
  const i = e.getBBoxOfElement(t);
  n.stroked && i.inflate(wo(t) / 2);
  const r = s.intersect(i), o = r && r.length ? s.start.closest(r) : s.end;
  return Uo(o, s.start, n.offset);
}, O6 = function(s, e, t, n, i) {
  const r = e.cell, o = r.isNode() ? r.getAngle() : 0;
  if (o === 0)
    return G(cg, this, s, e, t, n, i);
  const a = e.getUnrotatedBBoxOfElement(t);
  n.stroked && a.inflate(wo(t) / 2);
  const l = a.getCenter(), c = s.clone().rotate(o, l), u = c.setLength(1e6).intersect(a), f = u && u.length ? c.start.closest(u).rotate(-o, l) : s.end;
  return Uo(f, s.start, n.offset);
}, T6 = function(s, e, t, n) {
  let i, r;
  const o = s.end, a = n.selector;
  if (typeof a == "string" ? i = e.findOne(a) : Array.isArray(a) ? i = Hl(t, a) : i = _6(t), !Tn(i)) {
    if (i === t || !Tn(t))
      return o;
    i = t;
  }
  const l = e.getShapeOfElement(i), c = e.getMatrixOfElement(i), u = e.getRootTranslatedMatrix(), f = e.getRootRotatedMatrix(), d = u.multiply(f).multiply(c), g = d.inverse(), p = re.transformLine(s, g), m = p.start.clone(), w = e.getDataOfElement(i);
  if (n.insideout === !1) {
    w.shapeBBox == null && (w.shapeBBox = l.bbox());
    const x = w.shapeBBox;
    if (x != null && x.containsPoint(m))
      return o;
  }
  n.extrapolate === !0 && p.setLength(1e6);
  let v;
  if (F.isPath(l)) {
    const x = n.precision || 2;
    w.segmentSubdivisions == null && (w.segmentSubdivisions = l.getSegmentSubdivisions({
      precision: x
    })), v = {
      precision: x,
      segmentSubdivisions: w.segmentSubdivisions
    }, r = p.intersect(l, v);
  } else
    r = p.intersect(l);
  r ? Array.isArray(r) && (r = m.closest(r)) : n.sticky === !0 && (R.isRectangle(l) ? r = l.getNearestPointToPoint(m) : Dt.isEllipse(l) ? r = l.intersectsWithLineFromCenterToPoint(m) : r = l.closestPoint(m, v));
  const y = r ? re.transformPoint(r, d) : o;
  let b = n.offset || 0;
  return n.stroked !== !1 && (typeof b == "object" ? (b = Object.assign({}, b), b.x == null && (b.x = 0), b.x += wo(i) / 2) : b += wo(i) / 2), Uo(y, s.start, b);
};
function L6(s, e, t = 0) {
  const { start: n, end: i } = s;
  let r, o, a, l;
  switch (e) {
    case "left":
      l = "x", r = i, o = n, a = -1;
      break;
    case "right":
      l = "x", r = n, o = i, a = 1;
      break;
    case "top":
      l = "y", r = i, o = n, a = -1;
      break;
    case "bottom":
      l = "y", r = n, o = i, a = 1;
      break;
    default:
      return;
  }
  n[l] < i[l] ? r[l] = o[l] : o[l] = r[l], Number.isFinite(t) && (r[l] += a * t, o[l] += a * t);
}
const D6 = function(s, e, t, n) {
  const { alignOffset: i, align: r } = n;
  return r && L6(s, r, i), Uo(s.end, s.start, n.offset);
}, N6 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  anchor: D6,
  bbox: cg,
  boundary: T6,
  rect: O6
}, Symbol.toStringTag, { value: "Module" }));
var ni;
(function(s) {
  s.presets = N6, s.registry = _e.create({
    type: "connection point"
  }), s.registry.register(s.presets, !0);
})(ni || (ni = {}));
const I6 = function(s) {
  return [...s];
}, j6 = function(s, e, t) {
  const n = e.side || "bottom", i = us(e.padding || 40), r = t.sourceBBox, o = t.targetBBox, a = r.getCenter(), l = o.getCenter();
  let c, u, f;
  switch (n) {
    case "top":
      f = -1, c = "y", u = "height";
      break;
    case "left":
      f = -1, c = "x", u = "width";
      break;
    case "right":
      f = 1, c = "x", u = "width";
      break;
    case "bottom":
    default:
      f = 1, c = "y", u = "height";
      break;
  }
  return a[c] += f * (r[u] / 2 + i[n]), l[c] += f * (o[u] / 2 + i[n]), f * (a[c] - l[c]) > 0 ? l[c] = a[c] : a[c] = l[c], [a.toJSON(), ...s, l.toJSON()];
};
function Nr(s) {
  return new R(s.x, s.y, 0, 0);
}
function yo(s = {}) {
  const e = us(s.padding || 20);
  return {
    x: -e.left,
    y: -e.top,
    width: e.left + e.right,
    height: e.top + e.bottom
  };
}
function hg(s, e = {}) {
  return s.sourceBBox.clone().moveAndExpand(yo(e));
}
function ug(s, e = {}) {
  return s.targetBBox.clone().moveAndExpand(yo(e));
}
function R6(s, e = {}) {
  return s.sourceAnchor ? s.sourceAnchor : hg(s, e).getCenter();
}
function B6(s, e = {}) {
  return s.targetAnchor ? s.targetAnchor : ug(s, e).getCenter();
}
const dg = function(s, e, t) {
  let n = hg(t, e), i = ug(t, e);
  const r = R6(t, e), o = B6(t, e);
  n = n.union(Nr(r)), i = i.union(Nr(o));
  const a = s.map((u) => S.create(u));
  a.unshift(r), a.push(o);
  let l = null;
  const c = [];
  for (let u = 0, f = a.length - 1; u < f; u += 1) {
    let d = null;
    const g = a[u], p = a[u + 1], m = mt.getBearing(g, p) != null;
    if (u === 0)
      u + 1 === f ? n.intersectsWithRect(i.clone().inflate(1)) ? d = mt.insideNode(g, p, n, i) : m || (d = mt.nodeToNode(g, p, n, i)) : n.containsPoint(p) ? d = mt.insideNode(g, p, n, Nr(p).moveAndExpand(yo(e))) : m || (d = mt.nodeToVertex(g, p, n));
    else if (u + 1 === f) {
      const w = m && mt.getBearing(p, g) === l;
      i.containsPoint(g) || w ? d = mt.insideNode(g, p, Nr(g).moveAndExpand(yo(e)), i, l) : m || (d = mt.vertexToNode(g, p, i, l));
    } else
      m || (d = mt.vertexToVertex(g, p, l));
    d ? (c.push(...d.points), l = d.direction) : l = mt.getBearing(g, p), u + 1 < f && c.push(p);
  }
  return c;
};
var mt;
(function(s) {
  const e = {
    N: "S",
    S: "N",
    E: "W",
    W: "E"
  }, t = {
    N: -Math.PI / 2 * 3,
    S: -Math.PI / 2,
    E: 0,
    W: Math.PI
  };
  function n(f, d, g) {
    let p = new S(f.x, d.y);
    return g.containsPoint(p) && (p = new S(d.x, f.y)), p;
  }
  function i(f, d) {
    return f[d === "W" || d === "E" ? "width" : "height"];
  }
  s.getBBoxSize = i;
  function r(f, d) {
    return f.x === d.x ? f.y > d.y ? "N" : "S" : f.y === d.y ? f.x > d.x ? "W" : "E" : null;
  }
  s.getBearing = r;
  function o(f, d, g) {
    const p = new S(f.x, d.y), m = new S(d.x, f.y), w = r(f, p), v = r(f, m), y = g ? e[g] : null, b = w === g || w !== y && (v === y || v !== g) ? p : m;
    return { points: [b], direction: r(b, d) };
  }
  s.vertexToVertex = o;
  function a(f, d, g) {
    const p = n(f, d, g);
    return { points: [p], direction: r(p, d) };
  }
  s.nodeToVertex = a;
  function l(f, d, g, p) {
    const m = [new S(f.x, d.y), new S(d.x, f.y)], w = m.filter((b) => !g.containsPoint(b)), v = w.filter((b) => r(b, f) !== p);
    let y;
    if (v.length > 0)
      return y = v.filter((b) => r(f, b) === p).pop(), y = y || v[0], {
        points: [y],
        direction: r(y, d)
      };
    {
      y = lp(m, w)[0];
      const b = S.create(d).move(y, -i(g, p) / 2);
      return {
        points: [n(b, f, g), b],
        direction: r(b, d)
      };
    }
  }
  s.vertexToNode = l;
  function c(f, d, g, p) {
    let m = a(d, f, p);
    const w = m.points[0];
    if (g.containsPoint(w)) {
      m = a(f, d, g);
      const v = m.points[0];
      if (p.containsPoint(v)) {
        const y = S.create(f).move(v, -i(g, r(f, v)) / 2), b = S.create(d).move(w, -i(p, r(d, w)) / 2), x = new $(y, b).getCenter(), C = a(f, x, g), A = o(x, d, C.direction);
        m.points = [C.points[0], A.points[0]], m.direction = A.direction;
      }
    }
    return m;
  }
  s.nodeToNode = c;
  function u(f, d, g, p, m) {
    const w = g.union(p).inflate(1), v = w.getCenter(), y = v.distance(d) > v.distance(f), b = y ? d : f, x = y ? f : d;
    let C, A, P;
    m ? (C = S.fromPolar(w.width + w.height, t[m], b), C = w.getNearestPointToPoint(C).move(C, -1)) : C = w.getNearestPointToPoint(b).move(b, 1), A = n(C, x, w);
    let O;
    C.round().equals(A.round()) ? (A = S.fromPolar(w.width + w.height, ce.toRad(C.theta(b)) + Math.PI / 2, x), A = w.getNearestPointToPoint(A).move(x, 1).round(), P = n(C, A, w), O = y ? [A, P, C] : [C, P, A]) : O = y ? [A, C] : [C, A];
    const k = r(y ? C : A, d);
    return {
      points: O,
      direction: k
    };
  }
  s.insideNode = u;
})(mt || (mt = {}));
const $6 = {
  step: 10,
  maxLoopCount: 2e3,
  precision: 1,
  maxDirectionChange: 90,
  perpendicular: !0,
  excludeTerminals: [],
  excludeNodes: [],
  excludeShapes: [],
  startDirections: ["top", "right", "bottom", "left"],
  endDirections: ["top", "right", "bottom", "left"],
  directionMap: {
    top: { x: 0, y: -1 },
    right: { x: 1, y: 0 },
    bottom: { x: 0, y: 1 },
    left: { x: -1, y: 0 }
  },
  cost() {
    return vn(this.step, this);
  },
  directions() {
    const s = vn(this.step, this), e = vn(this.cost, this);
    return [
      { cost: e, offsetX: s, offsetY: 0 },
      { cost: e, offsetX: -s, offsetY: 0 },
      { cost: e, offsetX: 0, offsetY: s },
      { cost: e, offsetX: 0, offsetY: -s }
    ];
  },
  penalties() {
    const s = vn(this.step, this);
    return {
      0: 0,
      45: s / 2,
      90: s / 2
    };
  },
  paddingBox() {
    const s = vn(this.step, this);
    return {
      x: -s,
      y: -s,
      width: 2 * s,
      height: 2 * s
    };
  },
  fallbackRouter: dg,
  draggingRouter: null,
  snapToGrid: !0
};
function vn(s, e) {
  return typeof s == "function" ? s.call(e) : s;
}
function F6(s) {
  const e = Object.keys(s).reduce((t, n) => {
    const i = t;
    return n === "fallbackRouter" || n === "draggingRouter" || n === "fallbackRoute" ? i[n] = s[n] : i[n] = vn(s[n], s), t;
  }, {});
  if (e.padding) {
    const t = us(e.padding);
    e.paddingBox = {
      x: -t.left,
      y: -t.top,
      width: t.left + t.right,
      height: t.top + t.bottom
    };
  }
  return e.directions.forEach((t) => {
    const n = new S(0, 0), i = new S(t.offsetX, t.offsetY);
    t.angle = ce.normalize(n.theta(i));
  }), e;
}
const _h = 1, Oh = 2;
class z6 {
  constructor() {
    this.items = [], this.hash = {}, this.values = {};
  }
  add(e, t) {
    this.hash[e] ? this.items.splice(this.items.indexOf(e), 1) : this.hash[e] = _h, this.values[e] = t;
    const n = cp(this.items, e, (i) => this.values[i]);
    this.items.splice(n, 0, e);
  }
  pop() {
    const e = this.items.shift();
    return e && (this.hash[e] = Oh), e;
  }
  isOpen(e) {
    return this.hash[e] === _h;
  }
  isClose(e) {
    return this.hash[e] === Oh;
  }
  isEmpty() {
    return this.items.length === 0;
  }
}
class V6 {
  constructor(e) {
    this.options = e, this.mapGridSize = 100, this.map = {};
  }
  /**
   * Builds a map of all nodes for quicker obstacle queries i.e. is a point
   * contained in any obstacle?
   *
   * A simplified grid search.
   */
  build(e, t) {
    const n = this.options, i = n.excludeTerminals.reduce((c, u) => {
      const f = t[u];
      if (f) {
        const d = e.getCell(f.cell);
        d && c.push(d);
      }
      return c;
    }, []);
    let r = [];
    const o = e.getCell(t.getSourceCellId());
    o && (r = pc(r, o.getAncestors().map((c) => c.id)));
    const a = e.getCell(t.getTargetCellId());
    a && (r = pc(r, a.getAncestors().map((c) => c.id)));
    const l = this.mapGridSize;
    return e.getNodes().reduce((c, u) => {
      const f = i.some((w) => w.id === u.id), d = u.shape ? n.excludeShapes.includes(u.shape) : !1, g = n.excludeNodes.some((w) => typeof w == "string" ? u.id === w : w === u), p = r.includes(u.id), m = d || f || g || p;
      if (u.isVisible() && !m) {
        const w = u.getBBox().moveAndExpand(n.paddingBox), v = w.getOrigin().snapToGrid(l), y = w.getCorner().snapToGrid(l);
        for (let b = v.x; b <= y.x; b += l)
          for (let x = v.y; x <= y.y; x += l) {
            const C = new S(b, x).toString();
            c[C] == null && (c[C] = []), c[C].push(w);
          }
      }
      return c;
    }, this.map), this;
  }
  isAccessible(e) {
    const t = e.clone().snapToGrid(this.mapGridSize).toString(), n = this.map[t];
    return n ? n.every((i) => !i.containsPoint(e)) : !0;
  }
}
function fg(s, e) {
  const t = s.sourceBBox.clone();
  return e && e.paddingBox ? t.moveAndExpand(e.paddingBox) : t;
}
function gg(s, e) {
  const t = s.targetBBox.clone();
  return e && e.paddingBox ? t.moveAndExpand(e.paddingBox) : t;
}
function pg(s, e) {
  return s.sourceAnchor ? s.sourceAnchor : fg(s, e).getCenter();
}
function H6(s, e) {
  return s.targetAnchor ? s.targetAnchor : gg(s, e).getCenter();
}
function xa(s, e, t, n, i) {
  const r = 360 / t, o = s.theta(U6(s, e, n, i)), a = ce.normalize(o + r / 2);
  return r * Math.floor(a / r);
}
function U6(s, e, t, n) {
  const i = n.step, r = e.x - s.x, o = e.y - s.y, a = r / t.x, l = o / t.y, c = a * i, u = l * i;
  return new S(s.x + c, s.y + u);
}
function Th(s, e) {
  const t = Math.abs(s - e);
  return t > 180 ? 360 - t : t;
}
function q6(s, e) {
  const t = e.step;
  return e.directions.forEach((n) => {
    n.gridOffsetX = n.offsetX / t * s.x, n.gridOffsetY = n.offsetY / t * s.y;
  }), e.directions;
}
function G6(s, e, t) {
  return {
    source: e.clone(),
    x: Lh(t.x - e.x, s),
    y: Lh(t.y - e.y, s)
  };
}
function Lh(s, e) {
  if (!s)
    return e;
  const t = Math.abs(s), n = Math.round(t / e);
  if (!n)
    return t;
  const i = n * e, o = (t - i) / n;
  return e + o;
}
function W6(s, e) {
  const t = e.source, n = le.snapToGrid(s.x - t.x, e.x) + t.x, i = le.snapToGrid(s.y - t.y, e.y) + t.y;
  return new S(n, i);
}
function Si(s, e) {
  return s.round(e);
}
function Wr(s, e, t) {
  return Si(W6(s.clone(), e), t);
}
function Ii(s) {
  return s.toString();
}
function Ca(s) {
  return new S(s.x === 0 ? 0 : Math.abs(s.x) / s.x, s.y === 0 ? 0 : Math.abs(s.y) / s.y);
}
function Dh(s, e) {
  let t = 1 / 0;
  for (let n = 0, i = e.length; n < i; n += 1) {
    const r = s.manhattanDistance(e[n]);
    r < t && (t = r);
  }
  return t;
}
function Nh(s, e, t, n, i) {
  const r = i.precision, o = i.directionMap, a = s.diff(e.getCenter()), l = Object.keys(o).reduce((c, u) => {
    if (t.includes(u)) {
      const f = o[u], d = new S(s.x + f.x * (Math.abs(a.x) + e.width), s.y + f.y * (Math.abs(a.y) + e.height)), p = new $(s, d).intersect(e) || [];
      let m, w = null;
      for (let v = 0; v < p.length; v += 1) {
        const y = p[v], b = s.squaredDistance(y);
        (m == null || b > m) && (m = b, w = y);
      }
      if (w) {
        let v = Wr(w, n, r);
        e.containsPoint(v) && (v = Wr(v.translate(f.x * n.x, f.y * n.y), n, r)), c.push(v);
      }
    }
    return c;
  }, []);
  return e.containsPoint(s) || l.push(Wr(s, n, r)), l;
}
function J6(s, e, t, n, i) {
  const r = [];
  let o = Ca(i.diff(t)), a = Ii(t), l = s[a], c;
  for (; l; ) {
    c = e[a];
    const d = Ca(c.diff(l));
    d.equals(o) || (r.unshift(c), o = d), a = Ii(l), l = s[a];
  }
  const u = e[a];
  return Ca(u.diff(n)).equals(o) || r.unshift(u), r;
}
function Y6(s, e, t, n, i) {
  const r = i.precision;
  let o, a;
  R.isRectangle(e) ? o = Si(pg(s, i).clone(), r) : o = Si(e.clone(), r), R.isRectangle(t) ? a = Si(H6(s, i).clone(), r) : a = Si(t.clone(), r);
  const l = G6(i.step, o, a), c = o, u = a;
  let f, d;
  if (R.isRectangle(e) ? f = Nh(c, e, i.startDirections, l, i) : f = [c], R.isRectangle(t) ? d = Nh(a, t, i.endDirections, l, i) : d = [u], f = f.filter((g) => n.isAccessible(g)), d = d.filter((g) => n.isAccessible(g)), f.length > 0 && d.length > 0) {
    const g = new z6(), p = {}, m = {}, w = {};
    for (let D = 0, L = f.length; D < L; D += 1) {
      const B = f[D], ee = Ii(B);
      g.add(ee, Dh(B, d)), p[ee] = B, w[ee] = 0;
    }
    const v = i.previousDirectionAngle, y = v === void 0;
    let b, x;
    const C = q6(l, i), A = C.length, P = d.reduce((D, L) => {
      const B = Ii(L);
      return D.push(B), D;
    }, []), O = S.equalPoints(f, d);
    let k = i.maxLoopCount;
    for (; !g.isEmpty() && k > 0; ) {
      const D = g.pop(), L = p[D], B = m[D], ee = w[D], q = L.equals(c), _ = B == null;
      let I;
      if (_ ? y ? q ? I = null : I = xa(c, L, A, l, i) : I = v : I = xa(B, L, A, l, i), !(_ && O) && P.indexOf(D) >= 0)
        return i.previousDirectionAngle = I, J6(m, p, L, c, u);
      for (let oe = 0; oe < A; oe += 1) {
        b = C[oe];
        const ne = b.angle;
        if (x = Th(I, ne), !(y && q) && x > i.maxDirectionChange)
          continue;
        const ye = Wr(L.clone().translate(b.gridOffsetX || 0, b.gridOffsetY || 0), l, r), Se = Ii(ye);
        if (g.isClose(Se) || !n.isAccessible(ye))
          continue;
        if (P.indexOf(Se) >= 0 && !ye.equals(u)) {
          const Ke = xa(ye, u, A, l, i);
          if (Th(ne, Ke) > i.maxDirectionChange)
            continue;
        }
        const Rt = b.cost, Wt = q ? 0 : i.penalties[x], ot = ee + Rt + Wt;
        (!g.isOpen(Se) || ot < w[Se]) && (p[Se] = ye, m[Se] = L, w[Se] = ot, g.add(Se, ot + Dh(ye, d)));
      }
      k -= 1;
    }
  }
  return i.fallbackRoute ? G(i.fallbackRoute, this, c, u, i) : null;
}
function X6(s, e = 10) {
  if (s.length <= 1)
    return s;
  for (let t = 0, n = s.length; t < n - 1; t += 1) {
    const i = s[t], r = s[t + 1];
    if (i.x === r.x) {
      const o = e * Math.round(i.x / e);
      i.x !== o && (i.x = o, r.x = o);
    } else if (i.y === r.y) {
      const o = e * Math.round(i.y / e);
      i.y !== o && (i.y = o, r.y = o);
    }
  }
  return s;
}
const Z6 = function(s, e, t) {
  const n = F6(e), i = fg(t, n), r = gg(t, n), o = pg(t, n), a = new V6(n).build(t.graph.model, t.cell), l = s.map((g) => S.create(g)), c = [];
  let u = o, f, d;
  for (let g = 0, p = l.length; g <= p; g += 1) {
    let m = null;
    if (f = d || i, d = l[g], d == null) {
      d = r;
      const v = t.cell;
      if ((v.getSourceCellId() == null || v.getTargetCellId() == null) && typeof n.draggingRouter == "function") {
        const b = f === i ? o : f, x = d.getOrigin();
        m = G(n.draggingRouter, t, b, x, n);
      }
    }
    if (m == null && (m = Y6(t, f, d, a, n)), m === null)
      return console.warn("Unable to execute manhattan algorithm, use orth instead"), G(n.fallbackRouter, this, s, n, t);
    const w = m[0];
    w && w.equals(u) && m.shift(), u = m[m.length - 1] || u, c.push(...m);
  }
  return n.snapToGrid ? X6(c, t.graph.grid.getGridSize()) : c;
}, mg = function(s, e, t) {
  return G(Z6, this, s, Object.assign(Object.assign({}, $6), e), t);
}, K6 = {
  maxDirectionChange: 45,
  // an array of directions to find next points on the route
  // different from start/end directions
  directions() {
    const s = vn(this.step, this), e = vn(this.cost, this), t = Math.ceil(Math.sqrt(s * s << 1));
    return [
      { cost: e, offsetX: s, offsetY: 0 },
      { cost: t, offsetX: s, offsetY: s },
      { cost: e, offsetX: 0, offsetY: s },
      { cost: t, offsetX: -s, offsetY: s },
      { cost: e, offsetX: -s, offsetY: 0 },
      { cost: t, offsetX: -s, offsetY: -s },
      { cost: e, offsetX: 0, offsetY: -s },
      { cost: t, offsetX: s, offsetY: -s }
    ];
  },
  // a simple route used in situations when main routing method fails
  // (exceed max number of loop iterations, inaccessible)
  fallbackRoute(s, e, t) {
    const n = s.theta(e), i = [];
    let r = { x: e.x, y: s.y }, o = { x: s.x, y: e.y };
    if (n % 180 > 90) {
      const b = r;
      r = o, o = b;
    }
    const a = n % 90 < 45 ? r : o, l = new $(s, a), c = 90 * Math.ceil(n / 90), u = S.fromPolar(l.squaredLength(), ce.toRad(c + 135), a), f = new $(e, u), d = l.intersectsWithLine(f), g = d || e, p = d ? g : s, m = 360 / t.directions.length, w = p.theta(e), v = ce.normalize(w + m / 2), y = m * Math.floor(v / m);
    return t.previousDirectionAngle = y, g && i.push(g.round()), i.push(e), i;
  }
}, Q6 = function(s, e, t) {
  return G(mg, this, s, Object.assign(Object.assign({}, K6), e), t);
}, e3 = function(s, e, t) {
  const n = e.offset || 32, i = e.min == null ? 16 : e.min;
  let r = 0, o = e.direction;
  const a = t.sourceBBox, l = t.targetBBox, c = a.getCenter(), u = l.getCenter();
  if (typeof n == "number" && (r = n), o == null) {
    let v = l.left - a.right, y = l.top - a.bottom;
    v >= 0 && y >= 0 ? o = v >= y ? "L" : "T" : v <= 0 && y >= 0 ? (v = a.left - l.right, v >= 0 ? o = v >= y ? "R" : "T" : o = "T") : v >= 0 && y <= 0 ? (y = a.top - l.bottom, y >= 0 ? o = v >= y ? "L" : "B" : o = "L") : (v = a.left - l.right, y = a.top - l.bottom, v >= 0 && y >= 0 ? o = v >= y ? "R" : "B" : v <= 0 && y >= 0 ? o = "B" : v >= 0 && y <= 0 ? o = "R" : o = Math.abs(v) > Math.abs(y) ? "R" : "B");
  }
  o === "H" ? o = u.x - c.x >= 0 ? "L" : "R" : o === "V" && (o = u.y - c.y >= 0 ? "T" : "B"), n === "center" && (o === "L" ? r = (l.left - a.right) / 2 : o === "R" ? r = (a.left - l.right) / 2 : o === "T" ? r = (l.top - a.bottom) / 2 : o === "B" && (r = (a.top - l.bottom) / 2));
  let f, d, g;
  const p = o === "L" || o === "R";
  if (p) {
    if (u.y === c.y)
      return [...s];
    g = o === "L" ? 1 : -1, f = "x", d = "width";
  } else {
    if (u.x === c.x)
      return [...s];
    g = o === "T" ? 1 : -1, f = "y", d = "height";
  }
  const m = c.clone(), w = u.clone();
  if (m[f] += g * (a[d] / 2 + r), w[f] -= g * (l[d] / 2 + r), p) {
    const v = m.x, y = w.x, b = a.width / 2 + i, x = l.width / 2 + i;
    u.x > c.x ? y <= v && (m.x = Math.max(y, c.x + b), w.x = Math.min(v, u.x - x)) : y >= v && (m.x = Math.min(y, c.x - b), w.x = Math.max(v, u.x + x));
  } else {
    const v = m.y, y = w.y, b = a.height / 2 + i, x = l.height / 2 + i;
    u.y > c.y ? y <= v && (m.y = Math.max(y, c.y + b), w.y = Math.min(v, u.y - x)) : y >= v && (m.y = Math.min(y, c.y - b), w.y = Math.max(v, u.y + x));
  }
  return [m.toJSON(), ...s, w.toJSON()];
};
function Es(s, e) {
  if (e != null && e !== !1) {
    const t = typeof e == "boolean" ? 0 : e;
    if (t > 0) {
      const n = S.create(s[1]).move(s[2], t), i = S.create(s[1]).move(s[0], t);
      return [n.toJSON(), ...s, i.toJSON()];
    }
    {
      const n = s[1];
      return [Object.assign({}, n), ...s, Object.assign({}, n)];
    }
  }
  return s;
}
const t3 = function(s, e, t) {
  const n = e.width || 50, r = (e.height || 80) / 2, o = e.angle || "auto", a = t.sourceAnchor, l = t.targetAnchor, c = t.sourceBBox, u = t.targetBBox;
  if (a.equals(l)) {
    const f = (v) => {
      const y = ce.toRad(v), b = Math.sin(y), x = Math.cos(y), C = new S(a.x + x * n, a.y + b * n), A = new S(C.x - x * r, C.y - b * r), P = A.clone().rotate(-90, C), O = A.clone().rotate(90, C);
      return [P.toJSON(), C.toJSON(), O.toJSON()];
    }, d = (v) => {
      const y = a.clone().move(v, -1), b = new $(y, v);
      return !c.containsPoint(v) && !c.intersectsWithLine(b);
    }, g = [0, 90, 180, 270, 45, 135, 225, 315];
    if (typeof o == "number")
      return Es(f(o), e.merge);
    const p = c.getCenter();
    if (p.equals(a))
      return Es(f(0), e.merge);
    const m = p.angleBetween(a, p.clone().translate(1, 0));
    let w = f(m);
    if (d(w[1]))
      return Es(w, e.merge);
    for (let v = 1, y = g.length; v < y; v += 1)
      if (w = f(m + g[v]), d(w[1]))
        return Es(w, e.merge);
    return Es(w, e.merge);
  }
  {
    const f = new $(a, l);
    let d = f.parallel(-n), g = d.getCenter(), p = d.start.clone().move(d.end, r), m = d.end.clone().move(d.start, r);
    const w = f.parallel(-1), v = new $(w.start, g), y = new $(w.end, g);
    if ((c.containsPoint(g) || u.containsPoint(g) || c.intersectsWithLine(v) || c.intersectsWithLine(y) || u.intersectsWithLine(v) || u.intersectsWithLine(y)) && (d = f.parallel(n), g = d.getCenter(), p = d.start.clone().move(d.end, r), m = d.end.clone().move(d.start, r)), e.merge) {
      const b = new $(a, l), x = new $(g, b.center).setLength(Number.MAX_SAFE_INTEGER), C = c.intersectsWithLine(x), A = u.intersectsWithLine(x), P = C ? Array.isArray(C) ? C : [C] : [];
      A && (Array.isArray(A) ? P.push(...A) : P.push(A));
      const O = b.center.closest(P);
      O ? (t.sourceAnchor = O.clone(), t.targetAnchor = O.clone()) : (t.sourceAnchor = b.center.clone(), t.targetAnchor = b.center.clone());
    }
    return Es([p.toJSON(), g.toJSON(), m.toJSON()], e.merge);
  }
}, n3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  er: e3,
  loop: t3,
  manhattan: mg,
  metro: Q6,
  normal: I6,
  oneSide: j6,
  orth: dg
}, Symbol.toStringTag, { value: "Module" }));
var An;
(function(s) {
  s.presets = n3, s.registry = _e.create({
    type: "router"
  }), s.registry.register(s.presets, !0);
})(An || (An = {}));
const s3 = function(s, e, t, n = {}) {
  const i = [s, ...t, e], r = new ke(i), o = new F(r);
  return n.raw ? o : o.serialize();
}, i3 = function(s, e, t, n = {}) {
  const i = t.length === 3 ? 0 : 1, r = S.create(t[0 + i]), o = S.create(t[2 + i]), a = S.create(t[1 + i]);
  if (!S.equals(s, e)) {
    const c = new S((s.x + e.x) / 2, (s.y + e.y) / 2), u = c.angleBetween(S.create(s).rotate(90, c), a);
    u > 1 && (r.rotate(180 - u, c), o.rotate(180 - u, c), a.rotate(180 - u, c));
  }
  const l = "\n     M ".concat(s.x, " ").concat(s.y, "\n     Q ").concat(r.x, " ").concat(r.y, " ").concat(a.x, " ").concat(a.y, "\n     Q ").concat(o.x, " ").concat(o.y, " ").concat(e.x, " ").concat(e.y, "\n  ");
  return n.raw ? F.parse(l) : l;
}, r3 = function(s, e, t, n = {}) {
  const i = new F();
  i.appendSegment(F.createSegment("M", s));
  const r = 1 / 3, o = 2 / 3, a = n.radius || 10;
  let l, c;
  for (let u = 0, f = t.length; u < f; u += 1) {
    const d = S.create(t[u]), g = t[u - 1] || s, p = t[u + 1] || e;
    l = c || d.distance(g) / 2, c = d.distance(p) / 2;
    const m = -Math.min(a, l), w = -Math.min(a, c), v = d.clone().move(g, m).round(), y = d.clone().move(p, w).round(), b = new S(r * v.x + o * d.x, o * d.y + r * v.y), x = new S(r * y.x + o * d.x, o * d.y + r * y.y);
    i.appendSegment(F.createSegment("L", v)), i.appendSegment(F.createSegment("C", b, x, y));
  }
  return i.appendSegment(F.createSegment("L", e)), n.raw ? i : i.serialize();
}, o3 = function(s, e, t, n = {}) {
  let i, r = n.direction;
  if (t && t.length !== 0) {
    const o = [s, ...t, e], a = xe.throughPoints(o);
    i = new F(a);
  } else if (i = new F(), i.appendSegment(F.createSegment("M", s)), r || (r = Math.abs(s.x - e.x) >= Math.abs(s.y - e.y) ? "H" : "V"), r === "H") {
    const o = (s.x + e.x) / 2;
    i.appendSegment(F.createSegment("C", o, s.y, o, e.y, e.x, e.y));
  } else {
    const o = (s.y + e.y) / 2;
    i.appendSegment(F.createSegment("C", s.x, o, e.x, o, e.x, e.y));
  }
  return n.raw ? i : i.serialize();
}, Ih = 1, Ir = 1 / 3, jr = 2 / 3;
function a3(s) {
  let e = s.graph._jumpOverUpdateList;
  if (e == null && (e = s.graph._jumpOverUpdateList = [], s.graph.on("cell:mouseup", () => {
    const t = s.graph._jumpOverUpdateList;
    setTimeout(() => {
      for (let n = 0; n < t.length; n += 1)
        t[n].update();
    });
  }), s.graph.on("model:reseted", () => {
    e = s.graph._jumpOverUpdateList = [];
  })), e.indexOf(s) < 0) {
    e.push(s);
    const t = () => e.splice(e.indexOf(s), 1);
    s.cell.once("change:connector", t), s.cell.once("removed", t);
  }
}
function Ea(s, e, t = []) {
  const n = [s, ...t, e], i = [];
  return n.forEach((r, o) => {
    const a = n[o + 1];
    a != null && i.push(new $(r, a));
  }), i;
}
function l3(s, e) {
  const t = [];
  return e.forEach((n) => {
    const i = s.intersectsWithLine(n);
    i && t.push(i);
  }), t;
}
function jh(s, e) {
  return new $(s, e).squaredLength();
}
function c3(s, e, t) {
  return e.reduce((n, i, r) => {
    if (bo.includes(i))
      return n;
    const o = n.pop() || s, a = S.create(i).move(o.start, -t);
    let l = S.create(i).move(o.start, +t);
    const c = e[r + 1];
    if (c != null) {
      const d = l.distance(c);
      d <= t && (l = c.move(o.start, d), bo.push(c));
    } else if (a.distance(o.end) < t * 2 + Ih)
      return n.push(o), n;
    if (l.distance(o.start) < t * 2 + Ih)
      return n.push(o), n;
    const f = new $(a, l);
    return sr.push(f), n.push(new $(o.start, a), f, new $(l, o.end)), n;
  }, []);
}
function Rh(s, e, t, n) {
  const i = new F();
  let r;
  return r = F.createSegment("M", s[0].start), i.appendSegment(r), s.forEach((o, a) => {
    if (sr.includes(o)) {
      let l, c, u, f;
      if (t === "arc") {
        l = -90, c = o.start.diff(o.end), (c.x < 0 || c.x === 0 && c.y < 0) && (l += 180);
        const g = o.getCenter(), p = new $(g, o.end).rotate(l, g);
        let m;
        m = new $(o.start, g), u = m.pointAt(2 / 3).rotate(l, o.start), f = p.pointAt(1 / 3).rotate(-l, p.end), r = F.createSegment("C", u, f, p.end), i.appendSegment(r), m = new $(g, o.end), u = p.pointAt(1 / 3).rotate(l, p.end), f = m.pointAt(1 / 3).rotate(-l, o.end), r = F.createSegment("C", u, f, o.end), i.appendSegment(r);
      } else if (t === "gap")
        r = F.createSegment("M", o.end), i.appendSegment(r);
      else if (t === "cubic") {
        l = o.start.theta(o.end);
        const d = e * 0.6;
        let g = e * 1.35;
        c = o.start.diff(o.end), (c.x < 0 || c.x === 0 && c.y < 0) && (g *= -1), u = new S(o.start.x + d, o.start.y + g).rotate(l, o.start), f = new S(o.end.x - d, o.end.y + g).rotate(l, o.end), r = F.createSegment("C", u, f, o.end), i.appendSegment(r);
      }
    } else {
      const l = s[a + 1];
      n === 0 || !l || sr.includes(l) ? (r = F.createSegment("L", o.end), i.appendSegment(r)) : h3(n, i, o.end, o.start, l.end);
    }
  }), i;
}
function h3(s, e, t, n, i) {
  const r = t.distance(n) / 2, o = t.distance(i) / 2, a = -Math.min(s, r), l = -Math.min(s, o), c = t.clone().move(n, a).round(), u = t.clone().move(i, l).round(), f = new S(Ir * c.x + jr * t.x, jr * t.y + Ir * c.y), d = new S(Ir * u.x + jr * t.x, jr * t.y + Ir * u.y);
  let g;
  g = F.createSegment("L", c), e.appendSegment(g), g = F.createSegment("C", f, d, u), e.appendSegment(g);
}
let sr, bo;
const u3 = function(s, e, t, n = {}) {
  sr = [], bo = [], a3(this);
  const i = n.size || 5, r = n.type || "arc", o = n.radius || 0, a = n.ignoreConnectors || ["smooth"], l = this.graph, u = l.model.getEdges();
  if (u.length === 1)
    return Rh(Ea(s, e, t), i, r, o);
  const f = this.cell, d = u.indexOf(f), g = l.options.connecting.connector || {}, p = u.filter((x, C) => {
    const A = x.getConnector() || g;
    return a.includes(A.name) ? !1 : C > d ? A.name !== "jumpover" : !0;
  }), m = p.map((x) => l.findViewByCell(x)), w = Ea(s, e, t), v = m.map((x) => x == null ? [] : x === this ? w : Ea(x.sourcePoint, x.targetPoint, x.routePoints)), y = [];
  w.forEach((x) => {
    const C = p.reduce((A, P, O) => {
      if (P !== f) {
        const k = l3(x, v[O]);
        A.push(...k);
      }
      return A;
    }, []).sort((A, P) => jh(x.start, A) - jh(x.start, P));
    C.length > 0 ? y.push(...c3(x, C, i)) : y.push(x);
  });
  const b = Rh(y, i, r, o);
  return sr = [], bo = [], n.raw ? b : b.serialize();
}, d3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  jumpover: u3,
  loop: i3,
  normal: s3,
  rounded: r3,
  smooth: o3
}, Symbol.toStringTag, { value: "Module" }));
var ss;
(function(s) {
  s.presets = d3, s.registry = _e.create({
    type: "connector"
  }), s.registry.register(s.presets, !0);
})(ss || (ss = {}));
var f3 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class wg extends ft {
  constructor(e = {}) {
    super(), this.pending = !1, this.changing = !1, this.data = {}, this.mutate(Ce(e)), this.changed = {};
  }
  mutate(e, t = {}) {
    const n = t.unset === !0, i = t.silent === !0, r = [], o = this.changing;
    this.changing = !0, o || (this.previous = Ce(this.data), this.changed = {});
    const a = this.data, l = this.previous, c = this.changed;
    if (Object.keys(e).forEach((u) => {
      const f = u, d = e[f];
      nn(a[f], d) || r.push(f), nn(l[f], d) ? delete c[f] : c[f] = d, n ? delete a[f] : a[f] = d;
    }), !i && r.length > 0 && (this.pending = !0, this.pendingOptions = t, r.forEach((u) => {
      this.emit("change:*", {
        key: u,
        options: t,
        store: this,
        current: a[u],
        previous: l[u]
      });
    })), o)
      return this;
    if (!i)
      for (; this.pending; )
        this.pending = !1, this.emit("changed", {
          current: a,
          previous: l,
          store: this,
          options: this.pendingOptions
        });
    return this.pending = !1, this.changing = !1, this.pendingOptions = null, this;
  }
  get(e, t) {
    if (e == null)
      return this.data;
    const n = this.data[e];
    return n == null ? t : n;
  }
  getPrevious(e) {
    if (this.previous) {
      const t = this.previous[e];
      return t == null ? void 0 : t;
    }
  }
  set(e, t, n) {
    return e != null && (typeof e == "object" ? this.mutate(e, t) : this.mutate({ [e]: t }, n)), this;
  }
  remove(e, t) {
    const i = {};
    let r;
    if (typeof e == "string")
      i[e] = void 0, r = t;
    else if (Array.isArray(e))
      e.forEach((o) => i[o] = void 0), r = t;
    else {
      for (const o in this.data)
        i[o] = void 0;
      r = e;
    }
    return this.mutate(i, Object.assign(Object.assign({}, r), { unset: !0 })), this;
  }
  getByPath(e) {
    return Hl(this.data, e, "/");
  }
  setByPath(e, t, n = {}) {
    const i = "/", r = Array.isArray(e) ? [...e] : e.split(i), o = Array.isArray(e) ? e.join(i) : e, a = r[0], l = r.length;
    if (n.propertyPath = o, n.propertyValue = t, n.propertyPathArray = r, l === 1)
      this.set(a, t, n);
    else {
      const c = {};
      let u = c, f = a;
      for (let p = 1; p < l; p += 1) {
        const m = r[p], w = Number.isFinite(Number(m));
        u = u[f] = w ? [] : {}, f = m;
      }
      gi(c, r, t, i);
      const d = Ce(this.data);
      n.rewrite && fh(d, e, i);
      const g = Te(d, c);
      this.set(a, g[a], n);
    }
    return this;
  }
  removeByPath(e, t) {
    const n = Array.isArray(e) ? e : e.split("/"), i = n[0];
    if (n.length === 1)
      this.remove(i, t);
    else {
      const r = n.slice(1), o = Ce(this.get(i));
      o && fh(o, r), this.set(i, o, t);
    }
    return this;
  }
  hasChanged(e) {
    return e == null ? Object.keys(this.changed).length > 0 : e in this.changed;
  }
  /**
   * Returns an object containing all the data that have changed,
   * or `null` if there are no changes. Useful for determining what
   * parts of a view need to be updated.
   */
  getChanges(e) {
    if (e == null)
      return this.hasChanged() ? Ce(this.changed) : null;
    const t = this.changing ? this.previous : this.data, n = {};
    let i;
    for (const r in e) {
      const o = e[r];
      nn(t[r], o) || (n[r] = o, i = !0);
    }
    return i ? Ce(n) : null;
  }
  /**
   * Returns a copy of the store's `data` object.
   */
  toJSON() {
    return Ce(this.data);
  }
  clone() {
    const e = this.constructor;
    return new e(this.data);
  }
  dispose() {
    this.off(), this.data = {}, this.previous = {}, this.changed = {}, this.pending = !1, this.changing = !1, this.pendingOptions = null, this.trigger("disposed", { store: this });
  }
}
f3([
  ft.dispose()
], wg.prototype, "dispose", null);
class ir {
  constructor(e) {
    this.cell = e, this.ids = {}, this.cache = {};
  }
  get() {
    return Object.keys(this.ids);
  }
  start(e, t, n = {}, i = "/") {
    const r = this.cell.getPropByPath(e), o = hp(n, ir.defaultOptions), a = this.getTiming(o.timing), l = this.getInterp(o.interp, r, t);
    let c = 0;
    const u = Array.isArray(e) ? e.join(i) : e, f = Array.isArray(e) ? e : e.split(i), d = () => {
      const g = (/* @__PURE__ */ new Date()).getTime();
      c === 0 && (c = g);
      let m = (g - c) / o.duration;
      m < 1 ? this.ids[u] = requestAnimationFrame(d) : m = 1;
      const w = l(a(m));
      this.cell.setPropByPath(f, w), n.progress && n.progress(Object.assign({ progress: m, currentValue: w }, this.getArgs(u))), m === 1 && (this.cell.notify("transition:complete", this.getArgs(u)), n.complete && n.complete(this.getArgs(u)), this.cell.notify("transition:finish", this.getArgs(u)), n.finish && n.finish(this.getArgs(u)), this.clean(u));
    };
    return setTimeout(() => {
      this.stop(e, void 0, i), this.cache[u] = { startValue: r, targetValue: t, options: o }, this.ids[u] = requestAnimationFrame(d), this.cell.notify("transition:start", this.getArgs(u)), n.start && n.start(this.getArgs(u));
    }, n.delay), this.stop.bind(this, e, i, n);
  }
  stop(e, t = {}, n = "/") {
    const i = Array.isArray(e) ? e : e.split(n);
    return Object.keys(this.ids).filter((r) => nn(i, r.split(n).slice(0, i.length))).forEach((r) => {
      cancelAnimationFrame(this.ids[r]);
      const o = this.cache[r], a = this.getArgs(r), l = Object.assign(Object.assign({}, o.options), t), c = l.jumpedToEnd;
      c && o.targetValue != null && (this.cell.setPropByPath(r, o.targetValue), this.cell.notify("transition:end", Object.assign({}, a)), this.cell.notify("transition:complete", Object.assign({}, a)), l.complete && l.complete(Object.assign({}, a)));
      const u = Object.assign({ jumpedToEnd: c }, a);
      this.cell.notify("transition:stop", Object.assign({}, u)), l.stop && l.stop(Object.assign({}, u)), this.cell.notify("transition:finish", Object.assign({}, a)), l.finish && l.finish(Object.assign({}, a)), this.clean(r);
    }), this;
  }
  clean(e) {
    delete this.ids[e], delete this.cache[e];
  }
  getTiming(e) {
    return typeof e == "string" ? fs[e] : e;
  }
  getInterp(e, t, n) {
    return e ? e(t, n) : typeof n == "number" ? Kn.number(t, n) : typeof n == "string" ? n[0] === "#" ? Kn.color(t, n) : Kn.unit(t, n) : Kn.object(t, n);
  }
  getArgs(e) {
    const t = this.cache[e];
    return {
      path: e,
      startValue: t.startValue,
      targetValue: t.targetValue,
      cell: this.cell
    };
  }
}
(function(s) {
  s.defaultOptions = {
    delay: 10,
    duration: 100,
    timing: "linear"
  };
})(ir || (ir = {}));
var g3 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
}, yg = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
class te extends ft {
  static config(e) {
    const { markup: t, propHooks: n, attrHooks: i } = e, r = yg(e, ["markup", "propHooks", "attrHooks"]);
    t != null && (this.markup = t), n && (this.propHooks = this.propHooks.slice(), Array.isArray(n) ? this.propHooks.push(...n) : typeof n == "function" ? this.propHooks.push(n) : Object.values(n).forEach((o) => {
      typeof o == "function" && this.propHooks.push(o);
    })), i && (this.attrHooks = Object.assign(Object.assign({}, this.attrHooks), i)), this.defaults = Te({}, this.defaults, r);
  }
  static getMarkup() {
    return this.markup;
  }
  static getDefaults(e) {
    return e ? this.defaults : Ce(this.defaults);
  }
  static getAttrHooks() {
    return this.attrHooks;
  }
  static applyPropHooks(e, t) {
    return this.propHooks.reduce((n, i) => i ? G(i, e, n) : n, t);
  }
  // #endregion
  get [Symbol.toStringTag]() {
    return te.toStringTag;
  }
  constructor(e = {}) {
    super();
    const n = this.constructor.getDefaults(!0), i = Te({}, this.preprocess(n), this.preprocess(e));
    this.id = i.id || ao(), this.store = new wg(i), this.animation = new ir(this), this.setup(), this.init(), this.postprocess(e);
  }
  init() {
  }
  // #region model
  get model() {
    return this._model;
  }
  set model(e) {
    this._model !== e && (this._model = e);
  }
  // #endregion
  preprocess(e, t) {
    const n = e.id, r = this.constructor.applyPropHooks(this, e);
    return n == null && t !== !0 && (r.id = ao()), r;
  }
  postprocess(e) {
  }
  // eslint-disable-line
  setup() {
    this.store.on("change:*", (e) => {
      const { key: t, current: n, previous: i, options: r } = e;
      this.notify("change:*", {
        key: t,
        options: r,
        current: n,
        previous: i,
        cell: this
      }), this.notify("change:".concat(t), {
        options: r,
        current: n,
        previous: i,
        cell: this
      });
      const o = t;
      (o === "source" || o === "target") && this.notify("change:terminal", {
        type: o,
        current: n,
        previous: i,
        options: r,
        cell: this
      });
    }), this.store.on("changed", ({ options: e }) => this.notify("changed", { options: e, cell: this }));
  }
  notify(e, t) {
    this.trigger(e, t);
    const n = this.model;
    return n && (n.notify("cell:".concat(e), t), this.isNode() ? n.notify("node:".concat(e), Object.assign(Object.assign({}, t), { node: this })) : this.isEdge() && n.notify("edge:".concat(e), Object.assign(Object.assign({}, t), { edge: this }))), this;
  }
  isNode() {
    return !1;
  }
  isEdge() {
    return !1;
  }
  isSameStore(e) {
    return this.store === e.store;
  }
  get view() {
    return this.store.get("view");
  }
  get shape() {
    return this.store.get("shape", "");
  }
  getProp(e, t) {
    return e == null ? this.store.get() : this.store.get(e, t);
  }
  setProp(e, t, n) {
    if (typeof e == "string")
      this.store.set(e, t, n);
    else {
      const i = this.preprocess(e, !0);
      this.store.set(Te({}, this.getProp(), i), t), this.postprocess(e);
    }
    return this;
  }
  removeProp(e, t) {
    return typeof e == "string" || Array.isArray(e) ? this.store.removeByPath(e, t) : this.store.remove(t), this;
  }
  hasChanged(e) {
    return e == null ? this.store.hasChanged() : this.store.hasChanged(e);
  }
  getPropByPath(e) {
    return this.store.getByPath(e);
  }
  setPropByPath(e, t, n = {}) {
    return this.model && (e === "children" ? this._children = t ? t.map((i) => this.model.getCell(i)).filter((i) => i != null) : null : e === "parent" && (this._parent = t ? this.model.getCell(t) : null)), this.store.setByPath(e, t, n), this;
  }
  removePropByPath(e, t = {}) {
    const n = Array.isArray(e) ? e : e.split("/");
    return n[0] === "attrs" && (t.dirty = !0), this.store.removeByPath(n, t), this;
  }
  prop(e, t, n) {
    return e == null ? this.getProp() : typeof e == "string" || Array.isArray(e) ? arguments.length === 1 ? this.getPropByPath(e) : t == null ? this.removePropByPath(e, n || {}) : this.setPropByPath(e, t, n || {}) : this.setProp(e, t || {});
  }
  previous(e) {
    return this.store.getPrevious(e);
  }
  // #endregion
  // #region zIndex
  get zIndex() {
    return this.getZIndex();
  }
  set zIndex(e) {
    e == null ? this.removeZIndex() : this.setZIndex(e);
  }
  getZIndex() {
    return this.store.get("zIndex");
  }
  setZIndex(e, t = {}) {
    return this.store.set("zIndex", e, t), this;
  }
  removeZIndex(e = {}) {
    return this.store.remove("zIndex", e), this;
  }
  toFront(e = {}) {
    const t = this.model;
    if (t) {
      let n = t.getMaxZIndex(), i;
      e.deep ? (i = this.getDescendants({ deep: !0, breadthFirst: !0 }), i.unshift(this)) : i = [this], n = n - i.length + 1;
      const r = t.total();
      let o = t.indexOf(this) !== r - i.length;
      o || (o = i.some((a, l) => a.getZIndex() !== n + l)), o && this.batchUpdate("to-front", () => {
        n += i.length, i.forEach((a, l) => {
          a.setZIndex(n + l, e);
        });
      });
    }
    return this;
  }
  toBack(e = {}) {
    const t = this.model;
    if (t) {
      let n = t.getMinZIndex(), i;
      e.deep ? (i = this.getDescendants({ deep: !0, breadthFirst: !0 }), i.unshift(this)) : i = [this];
      let r = t.indexOf(this) !== 0;
      r || (r = i.some((o, a) => o.getZIndex() !== n + a)), r && this.batchUpdate("to-back", () => {
        n -= i.length, i.forEach((o, a) => {
          o.setZIndex(n + a, e);
        });
      });
    }
    return this;
  }
  // #endregion
  // #region markup
  get markup() {
    return this.getMarkup();
  }
  set markup(e) {
    e == null ? this.removeMarkup() : this.setMarkup(e);
  }
  getMarkup() {
    let e = this.store.get("markup");
    return e == null && (e = this.constructor.getMarkup()), e;
  }
  setMarkup(e, t = {}) {
    return this.store.set("markup", e, t), this;
  }
  removeMarkup(e = {}) {
    return this.store.remove("markup", e), this;
  }
  // #endregion
  // #region attrs
  get attrs() {
    return this.getAttrs();
  }
  set attrs(e) {
    e == null ? this.removeAttrs() : this.setAttrs(e);
  }
  getAttrs() {
    const e = this.store.get("attrs");
    return e ? Object.assign({}, e) : {};
  }
  setAttrs(e, t = {}) {
    if (e == null)
      this.removeAttrs(t);
    else {
      const n = (i) => this.store.set("attrs", i, t);
      if (t.overwrite === !0)
        n(e);
      else {
        const i = this.getAttrs();
        t.deep === !1 ? n(Object.assign(Object.assign({}, i), e)) : n(Te({}, i, e));
      }
    }
    return this;
  }
  replaceAttrs(e, t = {}) {
    return this.setAttrs(e, Object.assign(Object.assign({}, t), { overwrite: !0 }));
  }
  updateAttrs(e, t = {}) {
    return this.setAttrs(e, Object.assign(Object.assign({}, t), { deep: !1 }));
  }
  removeAttrs(e = {}) {
    return this.store.remove("attrs", e), this;
  }
  getAttrDefinition(e) {
    if (!e)
      return null;
    const n = this.constructor.getAttrHooks() || {};
    let i = n[e] || Ut.registry.get(e);
    if (!i) {
      const r = Eo(e);
      i = n[r] || Ut.registry.get(r);
    }
    return i || null;
  }
  getAttrByPath(e) {
    return e == null || e === "" ? this.getAttrs() : this.getPropByPath(this.prefixAttrPath(e));
  }
  setAttrByPath(e, t, n = {}) {
    return this.setPropByPath(this.prefixAttrPath(e), t, n), this;
  }
  removeAttrByPath(e, t = {}) {
    return this.removePropByPath(this.prefixAttrPath(e), t), this;
  }
  prefixAttrPath(e) {
    return Array.isArray(e) ? ["attrs"].concat(e) : "attrs/".concat(e);
  }
  attr(e, t, n) {
    return e == null ? this.getAttrByPath() : typeof e == "string" || Array.isArray(e) ? arguments.length === 1 ? this.getAttrByPath(e) : t == null ? this.removeAttrByPath(e, n || {}) : this.setAttrByPath(e, t, n || {}) : this.setAttrs(e, t || {});
  }
  // #endregion
  // #region visible
  get visible() {
    return this.isVisible();
  }
  set visible(e) {
    this.setVisible(e);
  }
  setVisible(e, t = {}) {
    return this.store.set("visible", e, t), this;
  }
  isVisible() {
    return this.store.get("visible") !== !1;
  }
  show(e = {}) {
    return this.isVisible() || this.setVisible(!0, e), this;
  }
  hide(e = {}) {
    return this.isVisible() && this.setVisible(!1, e), this;
  }
  toggleVisible(e, t = {}) {
    const n = typeof e == "boolean" ? e : !this.isVisible(), i = typeof e == "boolean" ? t : e;
    return n ? this.show(i) : this.hide(i), this;
  }
  // #endregion
  // #region data
  get data() {
    return this.getData();
  }
  set data(e) {
    this.setData(e);
  }
  getData() {
    return this.store.get("data");
  }
  setData(e, t = {}) {
    if (e == null)
      this.removeData(t);
    else {
      const n = (i) => this.store.set("data", i, t);
      if (t.overwrite === !0)
        n(e);
      else {
        const i = this.getData();
        t.deep === !1 ? n(typeof e == "object" ? Object.assign(Object.assign({}, i), e) : e) : n(Te({}, i, e));
      }
    }
    return this;
  }
  replaceData(e, t = {}) {
    return this.setData(e, Object.assign(Object.assign({}, t), { overwrite: !0 }));
  }
  updateData(e, t = {}) {
    return this.setData(e, Object.assign(Object.assign({}, t), { deep: !1 }));
  }
  removeData(e = {}) {
    return this.store.remove("data", e), this;
  }
  // #endregion
  // #region parent children
  get parent() {
    return this.getParent();
  }
  get children() {
    return this.getChildren();
  }
  getParentId() {
    return this.store.get("parent");
  }
  getParent() {
    const e = this.getParentId();
    if (e && this.model) {
      const t = this.model.getCell(e);
      return this._parent = t, t;
    }
    return null;
  }
  getChildren() {
    const e = this.store.get("children");
    if (e && e.length && this.model) {
      const t = e.map((n) => {
        var i;
        return (i = this.model) === null || i === void 0 ? void 0 : i.getCell(n);
      }).filter((n) => n != null);
      return this._children = t, [...t];
    }
    return null;
  }
  hasParent() {
    return this.parent != null;
  }
  isParentOf(e) {
    return e != null && e.getParent() === this;
  }
  isChildOf(e) {
    return e != null && this.getParent() === e;
  }
  eachChild(e, t) {
    return this.children && this.children.forEach(e, t), this;
  }
  filterChild(e, t) {
    return this.children ? this.children.filter(e, t) : [];
  }
  getChildCount() {
    return this.children == null ? 0 : this.children.length;
  }
  getChildIndex(e) {
    return this.children == null ? -1 : this.children.indexOf(e);
  }
  getChildAt(e) {
    return this.children != null && e >= 0 ? this.children[e] : null;
  }
  getAncestors(e = {}) {
    const t = [];
    let n = this.getParent();
    for (; n; )
      t.push(n), n = e.deep !== !1 ? n.getParent() : null;
    return t;
  }
  getDescendants(e = {}) {
    if (e.deep !== !1) {
      if (e.breadthFirst) {
        const t = [], n = this.getChildren() || [];
        for (; n.length > 0; ) {
          const i = n.shift(), r = i.getChildren();
          t.push(i), r && n.push(...r);
        }
        return t;
      }
      {
        const t = this.getChildren() || [];
        return t.forEach((n) => {
          t.push(...n.getDescendants(e));
        }), t;
      }
    }
    return this.getChildren() || [];
  }
  isDescendantOf(e, t = {}) {
    if (e == null)
      return !1;
    if (t.deep !== !1) {
      let n = this.getParent();
      for (; n; ) {
        if (n === e)
          return !0;
        n = n.getParent();
      }
      return !1;
    }
    return this.isChildOf(e);
  }
  isAncestorOf(e, t = {}) {
    return e == null ? !1 : e.isDescendantOf(this, t);
  }
  contains(e) {
    return this.isAncestorOf(e);
  }
  getCommonAncestor(...e) {
    return te.getCommonAncestor(this, ...e);
  }
  setParent(e, t = {}) {
    return this._parent = e, e ? this.store.set("parent", e.id, t) : this.store.remove("parent", t), this;
  }
  setChildren(e, t = {}) {
    return this._children = e, e != null ? this.store.set("children", e.map((n) => n.id), t) : this.store.remove("children", t), this;
  }
  unembed(e, t = {}) {
    const n = this.children;
    if (n != null && e != null) {
      const i = this.getChildIndex(e);
      i !== -1 && (n.splice(i, 1), e.setParent(null, t), this.setChildren(n, t));
    }
    return this;
  }
  embed(e, t = {}) {
    return e.addTo(this, t), this;
  }
  addTo(e, t = {}) {
    return te.isCell(e) ? e.addChild(this, t) : e.addCell(this, t), this;
  }
  insertTo(e, t, n = {}) {
    return e.insertChild(this, t, n), this;
  }
  addChild(e, t = {}) {
    return this.insertChild(e, void 0, t);
  }
  insertChild(e, t, n = {}) {
    if (e != null && e !== this) {
      const i = e.getParent(), r = this !== i;
      let o = t;
      if (o == null && (o = this.getChildCount(), r || (o -= 1)), i) {
        const l = i.getChildren();
        if (l) {
          const c = l.indexOf(e);
          c >= 0 && (e.setParent(null, n), l.splice(c, 1), i.setChildren(l, n));
        }
      }
      let a = this.children;
      if (a == null ? (a = [], a.push(e)) : a.splice(o, 0, e), e.setParent(this, n), this.setChildren(a, n), r && this.model) {
        const l = this.model.getIncomingEdges(this), c = this.model.getOutgoingEdges(this);
        l && l.forEach((u) => u.updateParent(n)), c && c.forEach((u) => u.updateParent(n));
      }
      this.model && this.model.addCell(e, n);
    }
    return this;
  }
  removeFromParent(e = {}) {
    const t = this.getParent();
    if (t != null) {
      const n = t.getChildIndex(this);
      t.removeChildAt(n, e);
    }
    return this;
  }
  removeChild(e, t = {}) {
    const n = this.getChildIndex(e);
    return this.removeChildAt(n, t);
  }
  removeChildAt(e, t = {}) {
    const n = this.getChildAt(e);
    return this.children != null && n != null && (this.unembed(n, t), n.remove(t)), n;
  }
  remove(e = {}) {
    return this.batchUpdate("remove", () => {
      const t = this.getParent();
      t && t.removeChild(this, e), e.deep !== !1 && this.eachChild((n) => n.remove(e)), this.model && this.model.removeCell(this, e);
    }), this;
  }
  transition(e, t, n = {}, i = "/") {
    return this.animation.start(e, t, n, i);
  }
  stopTransition(e, t, n = "/") {
    return this.animation.stop(e, t, n), this;
  }
  getTransitions() {
    return this.animation.get();
  }
  // #endregion
  // #region transform
  // eslint-disable-next-line
  translate(e, t, n) {
    return this;
  }
  scale(e, t, n, i) {
    return this;
  }
  addTools(e, t, n) {
    const i = Array.isArray(e) ? e : [e], r = typeof t == "string" ? t : null, o = typeof t == "object" ? t : typeof n == "object" ? n : {};
    if (o.reset)
      return this.setTools({ name: r, items: i, local: o.local }, o);
    let a = Ce(this.getTools());
    if (a == null || r == null || a.name === r)
      return a == null && (a = {}), a.items || (a.items = []), a.name = r, a.items = [...a.items, ...i], this.setTools(Object.assign({}, a), o);
  }
  setTools(e, t = {}) {
    return e == null ? this.removeTools() : this.store.set("tools", te.normalizeTools(e), t), this;
  }
  getTools() {
    return this.store.get("tools");
  }
  removeTools(e = {}) {
    return this.store.remove("tools", e), this;
  }
  hasTools(e) {
    const t = this.getTools();
    return t == null ? !1 : e == null ? !0 : t.name === e;
  }
  hasTool(e) {
    const t = this.getTools();
    return t == null ? !1 : t.items.some((n) => typeof n == "string" ? n === e : n.name === e);
  }
  removeTool(e, t = {}) {
    const n = Ce(this.getTools());
    if (n) {
      let i = !1;
      const r = n.items.slice(), o = (a) => {
        r.splice(a, 1), i = !0;
      };
      if (typeof e == "number")
        o(e);
      else
        for (let a = r.length - 1; a >= 0; a -= 1) {
          const l = r[a];
          (typeof l == "string" ? l === e : l.name === e) && o(a);
        }
      i && (n.items = r, this.setTools(n, t));
    }
    return this;
  }
  // #endregion
  // #region common
  // eslint-disable-next-line
  getBBox(e) {
    return new R();
  }
  // eslint-disable-next-line
  getConnectionPoint(e, t) {
    return new S();
  }
  toJSON(e = {}) {
    const t = Object.assign({}, this.store.get()), n = Object.prototype.toString, i = this.isNode() ? "node" : this.isEdge() ? "edge" : "cell";
    if (!t.shape) {
      const p = this.constructor;
      throw new Error("Unable to serialize ".concat(i, ' missing "shape" prop, check the ').concat(i, ' "').concat(p.name || n.call(p), '"'));
    }
    const r = this.constructor, o = e.diff === !0, a = t.attrs || {}, l = r.getDefaults(!0), c = o ? this.preprocess(l, !0) : l, u = c.attrs || {}, f = {};
    Object.entries(t).forEach(([p, m]) => {
      if (m != null && !Array.isArray(m) && typeof m == "object" && !un(m))
        throw new Error("Can only serialize ".concat(i, ' with plain-object props, but got a "').concat(n.call(m), '" type of key "').concat(p, '" on ').concat(i, ' "').concat(this.id, '"'));
      if (p !== "attrs" && p !== "shape" && o) {
        const w = c[p];
        nn(m, w) && delete t[p];
      }
    }), Object.keys(a).forEach((p) => {
      const m = a[p], w = u[p];
      Object.keys(m).forEach((v) => {
        const y = m[v], b = w ? w[v] : null;
        y != null && typeof y == "object" && !Array.isArray(y) ? Object.keys(y).forEach((x) => {
          const C = y[x];
          if (w == null || b == null || !Ci(b) || !nn(b[x], C)) {
            f[p] == null && (f[p] = {}), f[p][v] == null && (f[p][v] = {});
            const A = f[p][v];
            A[x] = C;
          }
        }) : (w == null || !nn(b, y)) && (f[p] == null && (f[p] = {}), f[p][v] = y);
      });
    });
    const d = Object.assign(Object.assign({}, t), { attrs: iu(f) ? void 0 : f });
    d.attrs == null && delete d.attrs;
    const g = d;
    return g.angle === 0 && delete g.angle, Ce(g);
  }
  clone(e = {}) {
    if (!e.deep) {
      const n = Object.assign({}, this.store.get());
      e.keepId || delete n.id, delete n.parent, delete n.children;
      const i = this.constructor;
      return new i(n);
    }
    return te.deepClone(this)[this.id];
  }
  findView(e) {
    return e.findViewByCell(this);
  }
  // #endregion
  // #region batch
  startBatch(e, t = {}, n = this.model) {
    return this.notify("batch:start", { name: e, data: t, cell: this }), n && n.startBatch(e, Object.assign(Object.assign({}, t), { cell: this })), this;
  }
  stopBatch(e, t = {}, n = this.model) {
    return n && n.stopBatch(e, Object.assign(Object.assign({}, t), { cell: this })), this.notify("batch:stop", { name: e, data: t, cell: this }), this;
  }
  batchUpdate(e, t, n) {
    const i = this.model;
    this.startBatch(e, n, i);
    const r = t();
    return this.stopBatch(e, n, i), r;
  }
  // #endregion
  // #region IDisposable
  dispose() {
    this.removeFromParent(), this.store.dispose();
  }
}
te.defaults = {};
te.attrHooks = {};
te.propHooks = [];
g3([
  ft.dispose()
], te.prototype, "dispose", null);
(function(s) {
  function e(t) {
    return typeof t == "string" ? { items: [t] } : Array.isArray(t) ? { items: t } : t.items ? t : {
      items: [t]
    };
  }
  s.normalizeTools = e;
})(te || (te = {}));
(function(s) {
  s.toStringTag = "X6.".concat(s.name);
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof s)
      return !0;
    const n = t[Symbol.toStringTag], i = t;
    return (n == null || n === s.toStringTag) && typeof i.isNode == "function" && typeof i.isEdge == "function" && typeof i.prop == "function" && typeof i.attr == "function";
  }
  s.isCell = e;
})(te || (te = {}));
(function(s) {
  function e(...r) {
    const o = r.filter((l) => l != null).map((l) => l.getAncestors()).sort((l, c) => l.length - c.length);
    return o.shift().find((l) => o.every((c) => c.includes(l))) || null;
  }
  s.getCommonAncestor = e;
  function t(r, o = {}) {
    let a = null;
    for (let l = 0, c = r.length; l < c; l += 1) {
      const u = r[l];
      let f = u.getBBox(o);
      if (f) {
        if (u.isNode()) {
          const d = u.getAngle();
          d != null && d !== 0 && (f = f.bbox(d));
        }
        a = a == null ? f : a.union(f);
      }
    }
    return a;
  }
  s.getCellsBBox = t;
  function n(r) {
    const o = [r, ...r.getDescendants({ deep: !0 })];
    return s.cloneCells(o);
  }
  s.deepClone = n;
  function i(r) {
    const o = su(r), a = o.reduce((l, c) => (l[c.id] = c.clone(), l), {});
    return o.forEach((l) => {
      const c = a[l.id];
      if (c.isEdge()) {
        const d = c.getSourceCellId(), g = c.getTargetCellId();
        d && a[d] && c.setSource(Object.assign(Object.assign({}, c.getSource()), { cell: a[d].id })), g && a[g] && c.setTarget(Object.assign(Object.assign({}, c.getTarget()), { cell: a[g].id }));
      }
      const u = l.getParent();
      u && a[u.id] && c.setParent(a[u.id]);
      const f = l.getChildren();
      if (f && f.length) {
        const d = f.reduce((g, p) => (a[p.id] && g.push(a[p.id]), g), []);
        d.length > 0 && c.setChildren(d);
      }
    }), a;
  }
  s.cloneCells = i;
})(te || (te = {}));
(function(s) {
  s.config({
    propHooks(e) {
      var { tools: t } = e, n = yg(e, ["tools"]);
      return t && (n.tools = s.normalizeTools(t)), n;
    }
  });
})(te || (te = {}));
var si;
(function(s) {
  let e, t;
  function n(o, a) {
    return a ? e != null && e.exist(o) : t != null && t.exist(o);
  }
  s.exist = n;
  function i(o) {
    e = o;
  }
  s.setEdgeRegistry = i;
  function r(o) {
    t = o;
  }
  s.setNodeRegistry = r;
})(si || (si = {}));
class p3 {
  constructor(e) {
    this.ports = [], this.groups = {}, this.init(Ce(e));
  }
  getPorts() {
    return this.ports;
  }
  getGroup(e) {
    return e != null ? this.groups[e] : null;
  }
  getPortsByGroup(e) {
    return this.ports.filter((t) => t.group === e || t.group == null && e == null);
  }
  getPortsLayoutByGroup(e, t) {
    const n = this.getPortsByGroup(e), i = e ? this.getGroup(e) : null, r = i ? i.position : null, o = r ? r.name : null;
    let a;
    if (o != null) {
      const f = ns.registry.get(o);
      if (f == null)
        return ns.registry.onNotFound(o);
      a = f;
    } else
      a = ns.presets.left;
    const l = n.map((f) => f && f.position && f.position.args || {}), c = r && r.args || {};
    return a(l, t, c).map((f, d) => {
      const g = n[d];
      return {
        portLayout: f,
        portId: g.id,
        portSize: g.size,
        portAttrs: g.attrs,
        labelSize: g.label.size,
        labelLayout: this.getPortLabelLayout(g, S.create(f.position), t)
      };
    });
  }
  init(e) {
    const { groups: t, items: n } = e;
    t != null && Object.keys(t).forEach((i) => {
      this.groups[i] = this.parseGroup(t[i]);
    }), Array.isArray(n) && n.forEach((i) => {
      this.ports.push(this.parsePort(i));
    });
  }
  parseGroup(e) {
    return Object.assign(Object.assign({}, e), { label: this.getLabel(e, !0), position: this.getPortPosition(e.position, !0) });
  }
  parsePort(e) {
    const t = Object.assign({}, e), n = this.getGroup(e.group) || {};
    return t.markup = t.markup || n.markup, t.attrs = Te({}, n.attrs, t.attrs), t.position = this.createPosition(n, t), t.label = Te({}, n.label, this.getLabel(t)), t.zIndex = this.getZIndex(n, t), t.size = Object.assign(Object.assign({}, n.size), t.size), t;
  }
  getZIndex(e, t) {
    return typeof t.zIndex == "number" ? t.zIndex : typeof e.zIndex == "number" || e.zIndex === "auto" ? e.zIndex : "auto";
  }
  createPosition(e, t) {
    return Te({
      name: "left",
      args: {}
    }, e.position, { args: t.args });
  }
  getPortPosition(e, t = !1) {
    if (e == null) {
      if (t)
        return { name: "left", args: {} };
    } else {
      if (typeof e == "string")
        return {
          name: e,
          args: {}
        };
      if (Array.isArray(e))
        return {
          name: "absolute",
          args: { x: e[0], y: e[1] }
        };
      if (typeof e == "object")
        return e;
    }
    return { args: {} };
  }
  getPortLabelPosition(e, t = !1) {
    if (e == null) {
      if (t)
        return { name: "left", args: {} };
    } else {
      if (typeof e == "string")
        return {
          name: e,
          args: {}
        };
      if (typeof e == "object")
        return e;
    }
    return { args: {} };
  }
  getLabel(e, t = !1) {
    const n = e.label || {};
    return n.position = this.getPortLabelPosition(n.position, t), n;
  }
  getPortLabelLayout(e, t, n) {
    const i = e.label.position.name || "left", r = e.label.position.args || {}, o = Xs.registry.get(i) || Xs.presets.left;
    return o ? o(t, n, r) : null;
  }
}
var qo = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
let Re = class bg extends te {
  get [Symbol.toStringTag]() {
    return bg.toStringTag;
  }
  constructor(e = {}) {
    super(e), this.initPorts();
  }
  preprocess(e, t) {
    const { x: n, y: i, width: r, height: o } = e, a = qo(e, ["x", "y", "width", "height"]);
    if (n != null || i != null) {
      const l = a.position;
      a.position = Object.assign(Object.assign({}, l), { x: n != null ? n : l ? l.x : 0, y: i != null ? i : l ? l.y : 0 });
    }
    if (r != null || o != null) {
      const l = a.size;
      a.size = Object.assign(Object.assign({}, l), { width: r != null ? r : l ? l.width : 0, height: o != null ? o : l ? l.height : 0 });
    }
    return super.preprocess(a, t);
  }
  isNode() {
    return !0;
  }
  size(e, t, n) {
    return e === void 0 ? this.getSize() : typeof e == "number" ? this.setSize(e, t, n) : this.setSize(e, t);
  }
  getSize() {
    const e = this.store.get("size");
    return e ? Object.assign({}, e) : { width: 1, height: 1 };
  }
  setSize(e, t, n) {
    return typeof e == "object" ? this.resize(e.width, e.height, t) : this.resize(e, t, n), this;
  }
  resize(e, t, n = {}) {
    this.startBatch("resize", n);
    const i = n.direction;
    if (i) {
      const r = this.getSize();
      switch (i) {
        case "left":
        case "right":
          t = r.height;
          break;
        case "top":
        case "bottom":
          e = r.width;
          break;
      }
      let a = {
        right: 0,
        "top-right": 0,
        top: 1,
        "top-left": 1,
        left: 2,
        "bottom-left": 2,
        bottom: 3,
        "bottom-right": 3
      }[i];
      const l = ce.normalize(this.getAngle() || 0);
      n.absolute && (a += Math.floor((l + 45) / 90), a %= 4);
      const c = this.getBBox();
      let u;
      a === 0 ? u = c.getBottomLeft() : a === 1 ? u = c.getCorner() : a === 2 ? u = c.getTopRight() : u = c.getOrigin();
      const f = u.clone().rotate(-l, c.getCenter()), d = Math.sqrt(e * e + t * t) / 2;
      let g = a * Math.PI / 2;
      g += Math.atan(a % 2 === 0 ? t / e : e / t), g -= ce.toRad(l);
      const m = S.fromPolar(d, g, f).clone().translate(e / -2, t / -2);
      this.store.set("size", { width: e, height: t }, n), this.setPosition(m.x, m.y, n);
    } else
      this.store.set("size", { width: e, height: t }, n);
    return this.stopBatch("resize", n), this;
  }
  scale(e, t, n, i = {}) {
    const r = this.getBBox().scale(e, t, n == null ? void 0 : n);
    return this.startBatch("scale", i), this.setPosition(r.x, r.y, i), this.resize(r.width, r.height, i), this.stopBatch("scale"), this;
  }
  position(e, t, n) {
    return typeof e == "number" ? this.setPosition(e, t, n) : this.getPosition(e);
  }
  getPosition(e = {}) {
    if (e.relative) {
      const n = this.getParent();
      if (n != null && n.isNode()) {
        const i = this.getPosition(), r = n.getPosition();
        return {
          x: i.x - r.x,
          y: i.y - r.y
        };
      }
    }
    const t = this.store.get("position");
    return t ? Object.assign({}, t) : { x: 0, y: 0 };
  }
  setPosition(e, t, n = {}) {
    let i, r, o;
    if (typeof e == "object" ? (i = e.x, r = e.y, o = t || {}) : (i = e, r = t, o = n || {}), o.relative) {
      const a = this.getParent();
      if (a != null && a.isNode()) {
        const l = a.getPosition();
        i += l.x, r += l.y;
      }
    }
    if (o.deep) {
      const a = this.getPosition();
      this.translate(i - a.x, r - a.y, o);
    } else
      this.store.set("position", { x: i, y: r }, o);
    return this;
  }
  translate(e = 0, t = 0, n = {}) {
    if (e === 0 && t === 0)
      return this;
    n.translateBy = n.translateBy || this.id;
    const i = this.getPosition();
    if (n.restrict != null && n.translateBy === this.id) {
      const o = this.getBBox({ deep: !0 }), a = n.restrict, l = i.x - o.x, c = i.y - o.y, u = Math.max(a.x + l, Math.min(a.x + a.width + l - o.width, i.x + e)), f = Math.max(a.y + c, Math.min(a.y + a.height + c - o.height, i.y + t));
      e = u - i.x, t = f - i.y;
    }
    const r = {
      x: i.x + e,
      y: i.y + t
    };
    return n.tx = e, n.ty = t, n.transition ? (typeof n.transition != "object" && (n.transition = {}), this.transition("position", r, Object.assign(Object.assign({}, n.transition), { interp: Kn.object })), this.eachChild((o) => {
      var a;
      ((a = n.exclude) === null || a === void 0 ? void 0 : a.includes(o)) || o.translate(e, t, n);
    })) : (this.startBatch("translate", n), this.store.set("position", r, n), this.eachChild((o) => {
      var a;
      ((a = n.exclude) === null || a === void 0 ? void 0 : a.includes(o)) || o.translate(e, t, n);
    }), this.stopBatch("translate", n)), this;
  }
  angle(e, t) {
    return e == null ? this.getAngle() : this.rotate(e, t);
  }
  getAngle() {
    return this.store.get("angle", 0);
  }
  rotate(e, t = {}) {
    const n = this.getAngle();
    if (t.center) {
      const i = this.getSize(), r = this.getPosition(), o = this.getBBox().getCenter();
      o.rotate(n - e, t.center);
      const a = o.x - i.width / 2 - r.x, l = o.y - i.height / 2 - r.y;
      this.startBatch("rotate", { angle: e, options: t }), this.setPosition(r.x + a, r.y + l, t), this.rotate(e, Object.assign(Object.assign({}, t), { center: null })), this.stopBatch("rotate");
    } else
      this.store.set("angle", t.absolute ? e : (n + e) % 360, t);
    return this;
  }
  // #endregion
  // #region common
  getBBox(e = {}) {
    if (e.deep) {
      const t = this.getDescendants({ deep: !0, breadthFirst: !0 });
      return t.push(this), te.getCellsBBox(t);
    }
    return R.fromPositionAndSize(this.getPosition(), this.getSize());
  }
  getConnectionPoint(e, t) {
    const n = this.getBBox(), i = n.getCenter(), r = e.getTerminal(t);
    if (r == null)
      return i;
    const o = r.port;
    if (!o || !this.hasPort(o))
      return i;
    const a = this.getPort(o);
    if (!a || !a.group)
      return i;
    const c = this.getPortsPosition(a.group)[o].position, u = S.create(c).translate(n.getOrigin()), f = this.getAngle();
    return f && u.rotate(-f, i), u;
  }
  /**
   * Sets cell's size and position based on the children bbox and given padding.
   */
  fit(e = {}) {
    const n = (this.getChildren() || []).filter((c) => c.isNode());
    if (n.length === 0)
      return this;
    this.startBatch("fit-embeds", e), e.deep && n.forEach((c) => c.fit(e));
    let { x: i, y: r, width: o, height: a } = te.getCellsBBox(n);
    const l = us(e.padding);
    return i -= l.left, r -= l.top, o += l.left + l.right, a += l.bottom + l.top, this.store.set({
      position: { x: i, y: r },
      size: { width: o, height: a }
    }, e), this.stopBatch("fit-embeds"), this;
  }
  // #endregion
  // #region ports
  get portContainerMarkup() {
    return this.getPortContainerMarkup();
  }
  set portContainerMarkup(e) {
    this.setPortContainerMarkup(e);
  }
  getDefaultPortContainerMarkup() {
    return this.store.get("defaultPortContainerMarkup") || ge.getPortContainerMarkup();
  }
  getPortContainerMarkup() {
    return this.store.get("portContainerMarkup") || this.getDefaultPortContainerMarkup();
  }
  setPortContainerMarkup(e, t = {}) {
    return this.store.set("portContainerMarkup", ge.clone(e), t), this;
  }
  get portMarkup() {
    return this.getPortMarkup();
  }
  set portMarkup(e) {
    this.setPortMarkup(e);
  }
  getDefaultPortMarkup() {
    return this.store.get("defaultPortMarkup") || ge.getPortMarkup();
  }
  getPortMarkup() {
    return this.store.get("portMarkup") || this.getDefaultPortMarkup();
  }
  setPortMarkup(e, t = {}) {
    return this.store.set("portMarkup", ge.clone(e), t), this;
  }
  get portLabelMarkup() {
    return this.getPortLabelMarkup();
  }
  set portLabelMarkup(e) {
    this.setPortLabelMarkup(e);
  }
  getDefaultPortLabelMarkup() {
    return this.store.get("defaultPortLabelMarkup") || ge.getPortLabelMarkup();
  }
  getPortLabelMarkup() {
    return this.store.get("portLabelMarkup") || this.getDefaultPortLabelMarkup();
  }
  setPortLabelMarkup(e, t = {}) {
    return this.store.set("portLabelMarkup", ge.clone(e), t), this;
  }
  get ports() {
    const e = this.store.get("ports", { items: [] });
    return e.items == null && (e.items = []), e;
  }
  getPorts() {
    return Ce(this.ports.items);
  }
  getPortsByGroup(e) {
    return this.getPorts().filter((t) => t.group === e);
  }
  getPort(e) {
    return Ce(this.ports.items.find((t) => t.id && t.id === e));
  }
  getPortAt(e) {
    return this.ports.items[e] || null;
  }
  hasPorts() {
    return this.ports.items.length > 0;
  }
  hasPort(e) {
    return this.getPortIndex(e) !== -1;
  }
  getPortIndex(e) {
    const t = typeof e == "string" ? e : e.id;
    return t != null ? this.ports.items.findIndex((n) => n.id === t) : -1;
  }
  getPortsPosition(e) {
    const t = this.getSize();
    return this.port.getPortsLayoutByGroup(e, new R(0, 0, t.width, t.height)).reduce((i, r) => {
      const o = r.portLayout;
      return i[r.portId] = {
        position: Object.assign({}, o.position),
        angle: o.angle || 0
      }, i;
    }, {});
  }
  getPortProp(e, t) {
    return this.getPropByPath(this.prefixPortPath(e, t));
  }
  setPortProp(e, t, n, i) {
    if (typeof t == "string" || Array.isArray(t)) {
      const a = this.prefixPortPath(e, t), l = n;
      return this.setPropByPath(a, l, i);
    }
    const r = this.prefixPortPath(e), o = t;
    return this.setPropByPath(r, o, n);
  }
  removePortProp(e, t, n) {
    return typeof t == "string" || Array.isArray(t) ? this.removePropByPath(this.prefixPortPath(e, t), n) : this.removePropByPath(this.prefixPortPath(e), t);
  }
  portProp(e, t, n, i) {
    return t == null ? this.getPortProp(e) : typeof t == "string" || Array.isArray(t) ? arguments.length === 2 ? this.getPortProp(e, t) : n == null ? this.removePortProp(e, t, i) : this.setPortProp(e, t, n, i) : this.setPortProp(e, t, n);
  }
  prefixPortPath(e, t) {
    const n = this.getPortIndex(e);
    if (n === -1)
      throw new Error('Unable to find port with id: "'.concat(e, '"'));
    return t == null || t === "" ? ["ports", "items", "".concat(n)] : Array.isArray(t) ? ["ports", "items", "".concat(n), ...t] : "ports/items/".concat(n, "/").concat(t);
  }
  addPort(e, t) {
    const n = [...this.ports.items];
    return n.push(e), this.setPropByPath("ports/items", n, t), this;
  }
  addPorts(e, t) {
    return this.setPropByPath("ports/items", [...this.ports.items, ...e], t), this;
  }
  insertPort(e, t, n) {
    const i = [...this.ports.items];
    return i.splice(e, 0, t), this.setPropByPath("ports/items", i, n), this;
  }
  removePort(e, t = {}) {
    return this.removePortAt(this.getPortIndex(e), t);
  }
  removePortAt(e, t = {}) {
    if (e >= 0) {
      const n = [...this.ports.items];
      n.splice(e, 1), t.rewrite = !0, this.setPropByPath("ports/items", n, t);
    }
    return this;
  }
  removePorts(e, t) {
    let n;
    if (Array.isArray(e)) {
      if (n = t || {}, e.length) {
        n.rewrite = !0;
        const r = [...this.ports.items].filter((o) => !e.some((a) => {
          const l = typeof a == "string" ? a : a.id;
          return o.id === l;
        }));
        this.setPropByPath("ports/items", r, n);
      }
    } else
      n = e || {}, n.rewrite = !0, this.setPropByPath("ports/items", [], n);
    return this;
  }
  getParsedPorts() {
    return this.port.getPorts();
  }
  getParsedGroups() {
    return this.port.groups;
  }
  getPortsLayoutByGroup(e, t) {
    return this.port.getPortsLayoutByGroup(e, t);
  }
  initPorts() {
    this.updatePortData(), this.on("change:ports", () => {
      this.processRemovedPort(), this.updatePortData();
    });
  }
  processRemovedPort() {
    const e = this.ports, t = {};
    e.items.forEach((o) => {
      o.id && (t[o.id] = !0);
    });
    const n = {};
    (this.store.getPrevious("ports") || {
      items: []
    }).items.forEach((o) => {
      o.id && !t[o.id] && (n[o.id] = !0);
    });
    const r = this.model;
    r && !iu(n) && (r.getConnectedEdges(this, { incoming: !0 }).forEach((l) => {
      const c = l.getTargetPortId();
      c && n[c] && l.remove();
    }), r.getConnectedEdges(this, { outgoing: !0 }).forEach((l) => {
      const c = l.getSourcePortId();
      c && n[c] && l.remove();
    }));
  }
  validatePorts() {
    const e = {}, t = [];
    return this.ports.items.forEach((n) => {
      typeof n != "object" && t.push("Invalid port ".concat(n, ".")), n.id == null && (n.id = this.generatePortId()), e[n.id] && t.push("Duplicitied port id."), e[n.id] = !0;
    }), t;
  }
  generatePortId() {
    return ao();
  }
  updatePortData() {
    const e = this.validatePorts();
    if (e.length > 0)
      throw this.store.set("ports", this.store.getPrevious("ports")), new Error(e.join(" "));
    const t = this.port ? this.port.getPorts() : null;
    this.port = new p3(this.ports);
    const n = this.port.getPorts(), i = t ? n.filter((o) => t.find((a) => a.id === o.id) ? null : o) : [...n], r = t ? t.filter((o) => n.find((a) => a.id === o.id) ? null : o) : [];
    i.length > 0 && this.notify("ports:added", { added: i, cell: this, node: this }), r.length > 0 && this.notify("ports:removed", { removed: r, cell: this, node: this });
  }
};
Re.defaults = {
  angle: 0,
  position: { x: 0, y: 0 },
  size: { width: 1, height: 1 }
};
(function(s) {
  s.toStringTag = "X6.".concat(s.name);
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof s)
      return !0;
    const n = t[Symbol.toStringTag], i = t;
    return (n == null || n === s.toStringTag) && typeof i.isNode == "function" && typeof i.isEdge == "function" && typeof i.prop == "function" && typeof i.attr == "function" && typeof i.size == "function" && typeof i.position == "function";
  }
  s.isNode = e;
})(Re || (Re = {}));
(function(s) {
  s.config({
    propHooks(e) {
      var { ports: t } = e, n = qo(e, ["ports"]);
      return t && (n.ports = Array.isArray(t) ? { items: t } : t), n;
    }
  });
})(Re || (Re = {}));
(function(s) {
  s.registry = _e.create({
    type: "node",
    process(e, t) {
      if (si.exist(e, !0))
        throw new Error("Node with name '".concat(e, "' was registered by anthor Edge"));
      if (typeof t == "function")
        return t.config({ shape: e }), t;
      let n = s;
      const { inherit: i } = t, r = qo(t, ["inherit"]);
      if (i)
        if (typeof i == "string") {
          const a = this.get(i);
          a == null ? this.onNotFound(i, "inherited") : n = a;
        } else
          n = i;
      r.constructorName == null && (r.constructorName = e);
      const o = n.define.call(n, r);
      return o.config({ shape: e }), o;
    }
  }), si.setNodeRegistry(s.registry);
})(Re || (Re = {}));
(function(s) {
  let e = 0;
  function t(r) {
    return r ? Ul(r) : (e += 1, "CustomNode".concat(e));
  }
  function n(r) {
    const { constructorName: o, overwrite: a } = r, l = qo(r, ["constructorName", "overwrite"]), c = Vl(t(o || l.shape), this);
    return c.config(l), l.shape && s.registry.register(l.shape, c, a), c;
  }
  s.define = n;
  function i(r) {
    const o = r.shape || "rect", a = s.registry.get(o);
    return a ? new a(r) : s.registry.onNotFound(o);
  }
  s.create = i;
})(Re || (Re = {}));
var Go = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
let Ee = class vg extends te {
  get [Symbol.toStringTag]() {
    return vg.toStringTag;
  }
  constructor(e = {}) {
    super(e);
  }
  preprocess(e, t) {
    const { source: n, sourceCell: i, sourcePort: r, sourcePoint: o, target: a, targetCell: l, targetPort: c, targetPoint: u } = e, d = Go(e, ["source", "sourceCell", "sourcePort", "sourcePoint", "target", "targetCell", "targetPort", "targetPoint"]), g = (p) => typeof p == "string" || typeof p == "number";
    if (n != null)
      if (te.isCell(n))
        d.source = { cell: n.id };
      else if (g(n))
        d.source = { cell: n };
      else if (S.isPoint(n))
        d.source = n.toJSON();
      else if (Array.isArray(n))
        d.source = { x: n[0], y: n[1] };
      else {
        const p = n.cell;
        te.isCell(p) ? d.source = Object.assign(Object.assign({}, n), { cell: p.id }) : d.source = n;
      }
    if (i != null || r != null) {
      let p = d.source;
      if (i != null) {
        const m = g(i) ? i : i.id;
        p ? p.cell = m : p = d.source = { cell: m };
      }
      r != null && p && (p.port = r);
    } else
      o != null && (d.source = S.create(o).toJSON());
    if (a != null)
      if (te.isCell(a))
        d.target = { cell: a.id };
      else if (g(a))
        d.target = { cell: a };
      else if (S.isPoint(a))
        d.target = a.toJSON();
      else if (Array.isArray(a))
        d.target = { x: a[0], y: a[1] };
      else {
        const p = a.cell;
        te.isCell(p) ? d.target = Object.assign(Object.assign({}, a), { cell: p.id }) : d.target = a;
      }
    if (l != null || c != null) {
      let p = d.target;
      if (l != null) {
        const m = g(l) ? l : l.id;
        p ? p.cell = m : p = d.target = { cell: m };
      }
      c != null && p && (p.port = c);
    } else
      u != null && (d.target = S.create(u).toJSON());
    return super.preprocess(d, t);
  }
  setup() {
    super.setup(), this.on("change:labels", (e) => this.onLabelsChanged(e)), this.on("change:vertices", (e) => this.onVertexsChanged(e));
  }
  isEdge() {
    return !0;
  }
  // #region terminal
  disconnect(e = {}) {
    return this.store.set({
      source: { x: 0, y: 0 },
      target: { x: 0, y: 0 }
    }, e), this;
  }
  get source() {
    return this.getSource();
  }
  set source(e) {
    this.setSource(e);
  }
  getSource() {
    return this.getTerminal("source");
  }
  getSourceCellId() {
    return this.source.cell;
  }
  getSourcePortId() {
    return this.source.port;
  }
  setSource(e, t, n = {}) {
    return this.setTerminal("source", e, t, n);
  }
  get target() {
    return this.getTarget();
  }
  set target(e) {
    this.setTarget(e);
  }
  getTarget() {
    return this.getTerminal("target");
  }
  getTargetCellId() {
    return this.target.cell;
  }
  getTargetPortId() {
    return this.target.port;
  }
  setTarget(e, t, n = {}) {
    return this.setTerminal("target", e, t, n);
  }
  getTerminal(e) {
    return Object.assign({}, this.store.get(e));
  }
  setTerminal(e, t, n, i = {}) {
    if (te.isCell(t))
      return this.store.set(e, Te({}, n, { cell: t.id }), i), this;
    const r = t;
    return S.isPoint(t) || r.x != null && r.y != null ? (this.store.set(e, Te({}, n, { x: r.x, y: r.y }), i), this) : (this.store.set(e, Ce(t), i), this);
  }
  getSourcePoint() {
    return this.getTerminalPoint("source");
  }
  getTargetPoint() {
    return this.getTerminalPoint("target");
  }
  getTerminalPoint(e) {
    const t = this[e];
    if (S.isPointLike(t))
      return S.create(t);
    const n = this.getTerminalCell(e);
    return n ? n.getConnectionPoint(this, e) : new S();
  }
  getSourceCell() {
    return this.getTerminalCell("source");
  }
  getTargetCell() {
    return this.getTerminalCell("target");
  }
  getTerminalCell(e) {
    if (this.model) {
      const t = e === "source" ? this.getSourceCellId() : this.getTargetCellId();
      if (t)
        return this.model.getCell(t);
    }
    return null;
  }
  getSourceNode() {
    return this.getTerminalNode("source");
  }
  getTargetNode() {
    return this.getTerminalNode("target");
  }
  getTerminalNode(e) {
    let t = this;
    const n = {};
    for (; t && t.isEdge(); ) {
      if (n[t.id])
        return null;
      n[t.id] = !0, t = t.getTerminalCell(e);
    }
    return t && t.isNode() ? t : null;
  }
  // #endregion
  // #region router
  get router() {
    return this.getRouter();
  }
  set router(e) {
    e == null ? this.removeRouter() : this.setRouter(e);
  }
  getRouter() {
    return this.store.get("router");
  }
  setRouter(e, t, n) {
    return typeof e == "object" ? this.store.set("router", e, t) : this.store.set("router", { name: e, args: t }, n), this;
  }
  removeRouter(e = {}) {
    return this.store.remove("router", e), this;
  }
  // #endregion
  // #region connector
  get connector() {
    return this.getConnector();
  }
  set connector(e) {
    e == null ? this.removeConnector() : this.setConnector(e);
  }
  getConnector() {
    return this.store.get("connector");
  }
  setConnector(e, t, n) {
    return typeof e == "object" ? this.store.set("connector", e, t) : this.store.set("connector", { name: e, args: t }, n), this;
  }
  removeConnector(e = {}) {
    return this.store.remove("connector", e);
  }
  // #endregion
  // #region labels
  getDefaultLabel() {
    const e = this.constructor, t = this.store.get("defaultLabel") || e.defaultLabel || {};
    return Ce(t);
  }
  get labels() {
    return this.getLabels();
  }
  set labels(e) {
    this.setLabels(e);
  }
  getLabels() {
    return [...this.store.get("labels", [])].map((e) => this.parseLabel(e));
  }
  setLabels(e, t = {}) {
    return this.store.set("labels", Array.isArray(e) ? e : [e], t), this;
  }
  insertLabel(e, t, n = {}) {
    const i = this.getLabels(), r = i.length;
    let o = t != null && Number.isFinite(t) ? t : r;
    return o < 0 && (o = r + o + 1), i.splice(o, 0, this.parseLabel(e)), this.setLabels(i, n);
  }
  appendLabel(e, t = {}) {
    return this.insertLabel(e, -1, t);
  }
  getLabelAt(e) {
    const t = this.getLabels();
    return e != null && Number.isFinite(e) ? this.parseLabel(t[e]) : null;
  }
  setLabelAt(e, t, n = {}) {
    if (e != null && Number.isFinite(e)) {
      const i = this.getLabels();
      i[e] = this.parseLabel(t), this.setLabels(i, n);
    }
    return this;
  }
  removeLabelAt(e, t = {}) {
    const n = this.getLabels(), i = e != null && Number.isFinite(e) ? e : -1, r = n.splice(i, 1);
    return this.setLabels(n, t), r.length ? r[0] : null;
  }
  parseLabel(e) {
    return typeof e == "string" ? this.constructor.parseStringLabel(e) : e;
  }
  onLabelsChanged({ previous: e, current: t }) {
    const n = e && t ? t.filter((r) => e.find((o) => r === o || nn(r, o)) ? null : r) : t ? [...t] : [], i = e && t ? e.filter((r) => t.find((o) => r === o || nn(r, o)) ? null : r) : e ? [...e] : [];
    n.length > 0 && this.notify("labels:added", { added: n, cell: this, edge: this }), i.length > 0 && this.notify("labels:removed", { removed: i, cell: this, edge: this });
  }
  // #endregion
  // #region vertices
  get vertices() {
    return this.getVertices();
  }
  set vertices(e) {
    this.setVertices(e);
  }
  getVertices() {
    return [...this.store.get("vertices", [])];
  }
  setVertices(e, t = {}) {
    const n = Array.isArray(e) ? e : [e];
    return this.store.set("vertices", n.map((i) => S.toJSON(i)), t), this;
  }
  insertVertex(e, t, n = {}) {
    const i = this.getVertices(), r = i.length;
    let o = t != null && Number.isFinite(t) ? t : r;
    return o < 0 && (o = r + o + 1), i.splice(o, 0, S.toJSON(e)), this.setVertices(i, n);
  }
  appendVertex(e, t = {}) {
    return this.insertVertex(e, -1, t);
  }
  getVertexAt(e) {
    return e != null && Number.isFinite(e) ? this.getVertices()[e] : null;
  }
  setVertexAt(e, t, n = {}) {
    if (e != null && Number.isFinite(e)) {
      const i = this.getVertices();
      i[e] = t, this.setVertices(i, n);
    }
    return this;
  }
  removeVertexAt(e, t = {}) {
    const n = this.getVertices(), i = e != null && Number.isFinite(e) ? e : -1;
    return n.splice(i, 1), this.setVertices(n, t);
  }
  onVertexsChanged({ previous: e, current: t }) {
    const n = e && t ? t.filter((r) => e.find((o) => S.equals(r, o)) ? null : r) : t ? [...t] : [], i = e && t ? e.filter((r) => t.find((o) => S.equals(r, o)) ? null : r) : e ? [...e] : [];
    n.length > 0 && this.notify("vertexs:added", { added: n, cell: this, edge: this }), i.length > 0 && this.notify("vertexs:removed", { removed: i, cell: this, edge: this });
  }
  // #endregion
  // #region markup
  getDefaultMarkup() {
    return this.store.get("defaultMarkup") || ge.getEdgeMarkup();
  }
  getMarkup() {
    return super.getMarkup() || this.getDefaultMarkup();
  }
  // #endregion
  // #region transform
  /**
   * Translate the edge vertices (and source and target if they are points)
   * by `tx` pixels in the x-axis and `ty` pixels in the y-axis.
   */
  translate(e, t, n = {}) {
    return n.translateBy = n.translateBy || this.id, n.tx = e, n.ty = t, this.applyToPoints((i) => ({
      x: (i.x || 0) + e,
      y: (i.y || 0) + t
    }), n);
  }
  /**
   * Scales the edge's points (vertices) relative to the given origin.
   */
  scale(e, t, n, i = {}) {
    return this.applyToPoints((r) => S.create(r).scale(e, t, n).toJSON(), i);
  }
  applyToPoints(e, t = {}) {
    const n = {}, i = this.getSource(), r = this.getTarget();
    S.isPointLike(i) && (n.source = e(i)), S.isPointLike(r) && (n.target = e(r));
    const o = this.getVertices();
    return o.length > 0 && (n.vertices = o.map(e)), this.store.set(n, t), this;
  }
  // #endregion
  // #region common
  getBBox() {
    return this.getPolyline().bbox();
  }
  getConnectionPoint() {
    return this.getPolyline().pointAt(0.5);
  }
  getPolyline() {
    const e = [
      this.getSourcePoint(),
      ...this.getVertices().map((t) => S.create(t)),
      this.getTargetPoint()
    ];
    return new ke(e);
  }
  updateParent(e) {
    let t = null;
    const n = this.getSourceCell(), i = this.getTargetCell(), r = this.getParent();
    return n && i && (n === i || n.isDescendantOf(i) ? t = i : i.isDescendantOf(n) ? t = n : t = te.getCommonAncestor(n, i)), r && t && t.id !== r.id && r.unembed(this, e), t && (!r || r.id !== t.id) && t.embed(this, e), t;
  }
  hasLoop(e = {}) {
    const t = this.getSource(), n = this.getTarget(), i = t.cell, r = n.cell;
    if (!i || !r)
      return !1;
    let o = i === r;
    if (!o && e.deep && this._model) {
      const a = this.getSourceCell(), l = this.getTargetCell();
      a && l && (o = a.isAncestorOf(l, e) || l.isAncestorOf(a, e));
    }
    return o;
  }
  getFragmentAncestor() {
    const e = [this, this.getSourceNode(), this.getTargetNode()].filter((t) => t != null);
    return this.getCommonAncestor(...e);
  }
  isFragmentDescendantOf(e) {
    const t = this.getFragmentAncestor();
    return !!t && (t.id === e.id || t.isDescendantOf(e));
  }
};
Ee.defaults = {};
(function(s) {
  function e(t, n) {
    const i = t, r = n;
    return i.cell === r.cell ? i.port === r.port || i.port == null && r.port == null : !1;
  }
  s.equalTerminals = e;
})(Ee || (Ee = {}));
(function(s) {
  s.defaultLabel = {
    markup: [
      {
        tagName: "rect",
        selector: "body"
      },
      {
        tagName: "text",
        selector: "label"
      }
    ],
    attrs: {
      text: {
        fill: "#000",
        fontSize: 14,
        textAnchor: "middle",
        textVerticalAnchor: "middle",
        pointerEvents: "none"
      },
      rect: {
        ref: "label",
        fill: "#fff",
        rx: 3,
        ry: 3,
        refWidth: 1,
        refHeight: 1,
        refX: 0,
        refY: 0
      }
    },
    position: {
      distance: 0.5
    }
  };
  function e(t) {
    return {
      attrs: { label: { text: t } }
    };
  }
  s.parseStringLabel = e;
})(Ee || (Ee = {}));
(function(s) {
  s.toStringTag = "X6.".concat(s.name);
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof s)
      return !0;
    const n = t[Symbol.toStringTag], i = t;
    return (n == null || n === s.toStringTag) && typeof i.isNode == "function" && typeof i.isEdge == "function" && typeof i.prop == "function" && typeof i.attr == "function" && typeof i.disconnect == "function" && typeof i.getSource == "function" && typeof i.getTarget == "function";
  }
  s.isEdge = e;
})(Ee || (Ee = {}));
(function(s) {
  s.registry = _e.create({
    type: "edge",
    process(e, t) {
      if (si.exist(e, !1))
        throw new Error("Edge with name '".concat(e, "' was registered by anthor Node"));
      if (typeof t == "function")
        return t.config({ shape: e }), t;
      let n = s;
      const { inherit: i = "edge" } = t, r = Go(t, ["inherit"]);
      if (typeof i == "string") {
        const a = this.get(i || "edge");
        a == null && i ? this.onNotFound(i, "inherited") : n = a;
      } else
        n = i;
      r.constructorName == null && (r.constructorName = e);
      const o = n.define.call(n, r);
      return o.config({ shape: e }), o;
    }
  }), si.setEdgeRegistry(s.registry);
})(Ee || (Ee = {}));
(function(s) {
  let e = 0;
  function t(r) {
    return r ? Ul(r) : (e += 1, "CustomEdge".concat(e));
  }
  function n(r) {
    const { constructorName: o, overwrite: a } = r, l = Go(r, ["constructorName", "overwrite"]), c = Vl(t(o || l.shape), this);
    return c.config(l), l.shape && s.registry.register(l.shape, c, a), c;
  }
  s.define = n;
  function i(r) {
    const o = r.shape || "edge", a = s.registry.get(o);
    return a ? new a(r) : s.registry.onNotFound(o);
  }
  s.create = i;
})(Ee || (Ee = {}));
(function(s) {
  const e = "basic.edge";
  s.config({
    shape: e,
    propHooks(t) {
      const { label: n, vertices: i } = t, r = Go(t, ["label", "vertices"]);
      if (n) {
        r.labels == null && (r.labels = []);
        const o = typeof n == "string" ? s.parseStringLabel(n) : n;
        r.labels.push(o);
      }
      return i && Array.isArray(i) && (r.vertices = i.map((o) => S.create(o).toJSON())), r;
    }
  }), s.registry.register(e, s);
})(Ee || (Ee = {}));
var m3 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class al extends ft {
  constructor(e, t = {}) {
    super(), this.length = 0, this.comparator = t.comparator || "zIndex", this.clean(), e && this.reset(e, { silent: !0 });
  }
  toJSON() {
    return this.cells.map((e) => e.toJSON());
  }
  add(e, t, n) {
    let i, r;
    typeof t == "number" ? (i = t, r = Object.assign({ merge: !1 }, n)) : (i = this.length, r = Object.assign({ merge: !1 }, t)), i > this.length && (i = this.length), i < 0 && (i += this.length + 1);
    const o = Array.isArray(e) ? e : [e], a = this.comparator && typeof t != "number" && r.sort !== !1, l = this.comparator || null;
    let c = !1;
    const u = [], f = [];
    return o.forEach((d) => {
      const g = this.get(d);
      g ? r.merge && !d.isSameStore(g) && (g.setProp(d.getProp(), n), f.push(g), a && !c && (l == null || typeof l == "function" ? c = g.hasChanged() : typeof l == "string" ? c = g.hasChanged(l) : c = l.some((p) => g.hasChanged(p)))) : (u.push(d), this.reference(d));
    }), u.length && (a && (c = !0), this.cells.splice(i, 0, ...u), this.length = this.cells.length), c && this.sort({ silent: !0 }), r.silent || (u.forEach((d, g) => {
      const p = {
        cell: d,
        index: i + g,
        options: r
      };
      this.trigger("added", p), r.dryrun || d.notify("added", Object.assign({}, p));
    }), c && this.trigger("sorted"), (u.length || f.length) && this.trigger("updated", {
      added: u,
      merged: f,
      removed: [],
      options: r
    })), this;
  }
  remove(e, t = {}) {
    const n = Array.isArray(e) ? e : [e], i = this.removeCells(n, t);
    return !t.silent && i.length > 0 && this.trigger("updated", {
      options: t,
      removed: i,
      added: [],
      merged: []
    }), Array.isArray(e) ? i : i[0];
  }
  removeCells(e, t) {
    const n = [];
    for (let i = 0; i < e.length; i += 1) {
      const r = this.get(e[i]);
      if (r == null)
        continue;
      const o = this.cells.indexOf(r);
      this.cells.splice(o, 1), this.length -= 1, delete this.map[r.id], n.push(r), this.unreference(r), t.dryrun || r.remove(), t.silent || (this.trigger("removed", { cell: r, index: o, options: t }), t.dryrun || r.notify("removed", { cell: r, index: o, options: t }));
    }
    return n;
  }
  reset(e, t = {}) {
    const n = this.cells.slice();
    if (n.forEach((i) => this.unreference(i)), this.clean(), this.add(e, Object.assign({ silent: !0 }, t)), !t.silent) {
      const i = this.cells.slice();
      this.trigger("reseted", {
        options: t,
        previous: n,
        current: i
      });
      const r = [], o = [];
      i.forEach((a) => {
        n.some((c) => c.id === a.id) || r.push(a);
      }), n.forEach((a) => {
        i.some((c) => c.id === a.id) || o.push(a);
      }), this.trigger("updated", { options: t, added: r, removed: o, merged: [] });
    }
    return this;
  }
  push(e, t) {
    return this.add(e, this.length, t);
  }
  pop(e) {
    const t = this.at(this.length - 1);
    return this.remove(t, e);
  }
  unshift(e, t) {
    return this.add(e, 0, t);
  }
  shift(e) {
    const t = this.at(0);
    return this.remove(t, e);
  }
  get(e) {
    if (e == null)
      return null;
    const t = typeof e == "string" || typeof e == "number" ? e : e.id;
    return this.map[t] || null;
  }
  has(e) {
    return this.get(e) != null;
  }
  at(e) {
    return e < 0 && (e += this.length), this.cells[e] || null;
  }
  first() {
    return this.at(0);
  }
  last() {
    return this.at(-1);
  }
  indexOf(e) {
    return this.cells.indexOf(e);
  }
  toArray() {
    return this.cells.slice();
  }
  sort(e = {}) {
    return this.comparator != null && (this.cells = up(this.cells, this.comparator), e.silent || this.trigger("sorted")), this;
  }
  clone() {
    const e = this.constructor;
    return new e(this.cells.slice(), {
      comparator: this.comparator
    });
  }
  reference(e) {
    this.map[e.id] = e, e.on("*", this.notifyCellEvent, this);
  }
  unreference(e) {
    e.off("*", this.notifyCellEvent, this), delete this.map[e.id];
  }
  notifyCellEvent(e, t) {
    const n = t.cell;
    this.trigger("cell:".concat(e), t), n && (n.isNode() ? this.trigger("node:".concat(e), Object.assign(Object.assign({}, t), { node: n })) : n.isEdge() && this.trigger("edge:".concat(e), Object.assign(Object.assign({}, t), { edge: n })));
  }
  clean() {
    this.length = 0, this.cells = [], this.map = {};
  }
  dispose() {
    this.reset([]);
  }
}
m3([
  al.dispose()
], al.prototype, "dispose", null);
var w3 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class Tt extends ft {
  get [Symbol.toStringTag]() {
    return Tt.toStringTag;
  }
  constructor(e = []) {
    super(), this.batches = {}, this.addings = /* @__PURE__ */ new WeakMap(), this.nodes = {}, this.edges = {}, this.outgoings = {}, this.incomings = {}, this.collection = new al(e), this.setup();
  }
  notify(e, t) {
    this.trigger(e, t);
    const n = this.graph;
    return n && (e === "sorted" || e === "reseted" || e === "updated" ? n.trigger("model:".concat(e), t) : n.trigger(e, t)), this;
  }
  setup() {
    const e = this.collection;
    e.on("sorted", () => this.notify("sorted", null)), e.on("updated", (t) => this.notify("updated", t)), e.on("cell:change:zIndex", () => this.sortOnChangeZ()), e.on("added", ({ cell: t }) => {
      this.onCellAdded(t);
    }), e.on("removed", (t) => {
      const n = t.cell;
      this.onCellRemoved(n, t.options), this.notify("cell:removed", t), n.isNode() ? this.notify("node:removed", Object.assign(Object.assign({}, t), { node: n })) : n.isEdge() && this.notify("edge:removed", Object.assign(Object.assign({}, t), { edge: n }));
    }), e.on("reseted", (t) => {
      this.onReset(t.current), this.notify("reseted", t);
    }), e.on("edge:change:source", ({ edge: t }) => this.onEdgeTerminalChanged(t, "source")), e.on("edge:change:target", ({ edge: t }) => {
      this.onEdgeTerminalChanged(t, "target");
    });
  }
  sortOnChangeZ() {
    this.collection.sort();
  }
  onCellAdded(e) {
    const t = e.id;
    e.isEdge() ? (e.updateParent(), this.edges[t] = !0, this.onEdgeTerminalChanged(e, "source"), this.onEdgeTerminalChanged(e, "target")) : this.nodes[t] = !0;
  }
  onCellRemoved(e, t) {
    const n = e.id;
    if (e.isEdge()) {
      delete this.edges[n];
      const i = e.getSource(), r = e.getTarget();
      if (i && i.cell) {
        const o = this.outgoings[i.cell], a = o ? o.indexOf(n) : -1;
        a >= 0 && (o.splice(a, 1), o.length === 0 && delete this.outgoings[i.cell]);
      }
      if (r && r.cell) {
        const o = this.incomings[r.cell], a = o ? o.indexOf(n) : -1;
        a >= 0 && (o.splice(a, 1), o.length === 0 && delete this.incomings[r.cell]);
      }
    } else
      delete this.nodes[n];
    t.clear || (t.disconnectEdges ? this.disconnectConnectedEdges(e, t) : this.removeConnectedEdges(e, t)), e.model === this && (e.model = null);
  }
  onReset(e) {
    this.nodes = {}, this.edges = {}, this.outgoings = {}, this.incomings = {}, e.forEach((t) => this.onCellAdded(t));
  }
  onEdgeTerminalChanged(e, t) {
    const n = t === "source" ? this.outgoings : this.incomings, i = e.previous(t);
    if (i && i.cell) {
      const o = te.isCell(i.cell) ? i.cell.id : i.cell, a = n[o], l = a ? a.indexOf(e.id) : -1;
      l >= 0 && (a.splice(l, 1), a.length === 0 && delete n[o]);
    }
    const r = e.getTerminal(t);
    if (r && r.cell) {
      const o = te.isCell(r.cell) ? r.cell.id : r.cell, a = n[o] || [];
      a.indexOf(e.id) === -1 && a.push(e.id), n[o] = a;
    }
  }
  prepareCell(e, t) {
    return !e.model && (!t || !t.dryrun) && (e.model = this), e.zIndex == null && e.setZIndex(this.getMaxZIndex() + 1, { silent: !0 }), e;
  }
  resetCells(e, t = {}) {
    return e.map((n) => this.prepareCell(n, Object.assign(Object.assign({}, t), { dryrun: !0 }))), this.collection.reset(e, t), e.map((n) => this.prepareCell(n, { options: t })), this;
  }
  clear(e = {}) {
    const t = this.getCells();
    if (t.length === 0)
      return this;
    const n = Object.assign(Object.assign({}, e), { clear: !0 });
    return this.batchUpdate("clear", () => {
      const i = t.sort((r, o) => {
        const a = r.isEdge() ? 1 : 2, l = o.isEdge() ? 1 : 2;
        return a - l;
      });
      for (; i.length > 0; ) {
        const r = i.shift();
        r && r.remove(n);
      }
    }, n), this;
  }
  addNode(e, t = {}) {
    const n = Re.isNode(e) ? e : this.createNode(e);
    return this.addCell(n, t), n;
  }
  updateNode(e, t = {}) {
    const n = this.createNode(e), i = n.getProp();
    return n.dispose(), this.updateCell(i, t);
  }
  createNode(e) {
    return Re.create(e);
  }
  addEdge(e, t = {}) {
    const n = Ee.isEdge(e) ? e : this.createEdge(e);
    return this.addCell(n, t), n;
  }
  createEdge(e) {
    return Ee.create(e);
  }
  updateEdge(e, t = {}) {
    const n = this.createEdge(e), i = n.getProp();
    return n.dispose(), this.updateCell(i, t);
  }
  addCell(e, t = {}) {
    return Array.isArray(e) ? this.addCells(e, t) : (!this.collection.has(e) && !this.addings.has(e) && (this.addings.set(e, !0), this.collection.add(this.prepareCell(e, t), t), e.eachChild((n) => this.addCell(n, t)), this.addings.delete(e)), this);
  }
  addCells(e, t = {}) {
    const n = e.length;
    if (n === 0)
      return this;
    const i = Object.assign(Object.assign({}, t), { position: n - 1, maxPosition: n - 1 });
    return this.startBatch("add", Object.assign(Object.assign({}, i), { cells: e })), e.forEach((r) => {
      this.addCell(r, i), i.position -= 1;
    }), this.stopBatch("add", Object.assign(Object.assign({}, i), { cells: e })), this;
  }
  updateCell(e, t = {}) {
    const n = e.id && this.getCell(e.id);
    return n ? this.batchUpdate("update", () => (Object.entries(e).forEach(([i, r]) => n.setProp(i, r, t)), !0), e) : !1;
  }
  removeCell(e, t = {}) {
    const n = typeof e == "string" ? this.getCell(e) : e;
    return n && this.has(n) ? this.collection.remove(n, t) : null;
  }
  updateCellId(e, t) {
    if (e.id === t)
      return;
    this.startBatch("update", { id: t }), e.prop("id", t);
    const n = e.clone({ keepId: !0 });
    return this.addCell(n), this.getConnectedEdges(e).forEach((r) => {
      const o = r.getSourceCell(), a = r.getTargetCell();
      o === e && r.setSource(Object.assign(Object.assign({}, r.getSource()), { cell: t })), a === e && r.setTarget(Object.assign(Object.assign({}, r.getTarget()), { cell: t }));
    }), this.removeCell(e), this.stopBatch("update", { id: t }), n;
  }
  removeCells(e, t = {}) {
    return e.length ? this.batchUpdate("remove", () => e.map((n) => this.removeCell(n, t))) : [];
  }
  removeConnectedEdges(e, t = {}) {
    const n = this.getConnectedEdges(e);
    return n.forEach((i) => {
      i.remove(t);
    }), n;
  }
  disconnectConnectedEdges(e, t = {}) {
    const n = typeof e == "string" ? e : e.id;
    this.getConnectedEdges(e).forEach((i) => {
      const r = i.getSourceCellId(), o = i.getTargetCellId();
      r === n && i.setSource({ x: 0, y: 0 }, t), o === n && i.setTarget({ x: 0, y: 0 }, t);
    });
  }
  has(e) {
    return this.collection.has(e);
  }
  total() {
    return this.collection.length;
  }
  indexOf(e) {
    return this.collection.indexOf(e);
  }
  /**
   * Returns a cell from the graph by its id.
   */
  getCell(e) {
    return this.collection.get(e);
  }
  /**
   * Returns all the nodes and edges in the graph.
   */
  getCells() {
    return this.collection.toArray();
  }
  /**
   * Returns the first cell (node or edge) in the graph. The first cell is
   * defined as the cell with the lowest `zIndex`.
   */
  getFirstCell() {
    return this.collection.first();
  }
  /**
   * Returns the last cell (node or edge) in the graph. The last cell is
   * defined as the cell with the highest `zIndex`.
   */
  getLastCell() {
    return this.collection.last();
  }
  /**
   * Returns the lowest `zIndex` value in the graph.
   */
  getMinZIndex() {
    const e = this.collection.first();
    return e && e.getZIndex() || 0;
  }
  /**
   * Returns the highest `zIndex` value in the graph.
   */
  getMaxZIndex() {
    const e = this.collection.last();
    return e && e.getZIndex() || 0;
  }
  getCellsFromCache(e) {
    return e ? Object.keys(e).map((t) => this.getCell(t)).filter((t) => t != null) : [];
  }
  /**
   * Returns all the nodes in the graph.
   */
  getNodes() {
    return this.getCellsFromCache(this.nodes);
  }
  /**
   * Returns all the edges in the graph.
   */
  getEdges() {
    return this.getCellsFromCache(this.edges);
  }
  /**
   * Returns all outgoing edges for the node.
   */
  getOutgoingEdges(e) {
    const t = typeof e == "string" ? e : e.id, n = this.outgoings[t];
    return n ? n.map((i) => this.getCell(i)).filter((i) => i && i.isEdge()) : null;
  }
  /**
   * Returns all incoming edges for the node.
   */
  getIncomingEdges(e) {
    const t = typeof e == "string" ? e : e.id, n = this.incomings[t];
    return n ? n.map((i) => this.getCell(i)).filter((i) => i && i.isEdge()) : null;
  }
  /**
   * Returns edges connected with cell.
   */
  getConnectedEdges(e, t = {}) {
    const n = [], i = typeof e == "string" ? this.getCell(e) : e;
    if (i == null)
      return n;
    const r = {}, o = t.indirect;
    let a = t.incoming, l = t.outgoing;
    a == null && l == null && (a = l = !0);
    const c = (u, f) => {
      const d = f ? this.getOutgoingEdges(u) : this.getIncomingEdges(u);
      if (d != null && d.forEach((g) => {
        r[g.id] || (n.push(g), r[g.id] = !0, o && (a && c(g, !1), l && c(g, !0)));
      }), o && u.isEdge()) {
        const g = f ? u.getTargetCell() : u.getSourceCell();
        g && g.isEdge() && (r[g.id] || (n.push(g), c(g, f)));
      }
    };
    if (l && c(i, !0), a && c(i, !1), t.deep) {
      const u = i.getDescendants({ deep: !0 }), f = {};
      u.forEach((g) => {
        g.isNode() && (f[g.id] = !0);
      });
      const d = (g, p) => {
        const m = p ? this.getOutgoingEdges(g.id) : this.getIncomingEdges(g.id);
        m != null && m.forEach((w) => {
          if (!r[w.id]) {
            const v = w.getSourceCell(), y = w.getTargetCell();
            if (!t.enclosed && v && f[v.id] && y && f[y.id])
              return;
            n.push(w), r[w.id] = !0;
          }
        });
      };
      u.forEach((g) => {
        g.isEdge() || (l && d(g, !0), a && d(g, !1));
      });
    }
    return n;
  }
  isBoundary(e, t) {
    const n = typeof e == "string" ? this.getCell(e) : e, i = t ? this.getIncomingEdges(n) : this.getOutgoingEdges(n);
    return i == null || i.length === 0;
  }
  getBoundaryNodes(e) {
    const t = [];
    return Object.keys(this.nodes).forEach((n) => {
      if (this.isBoundary(n, e)) {
        const i = this.getCell(n);
        i && t.push(i);
      }
    }), t;
  }
  /**
   * Returns an array of all the roots of the graph.
   */
  getRoots() {
    return this.getBoundaryNodes(!0);
  }
  /**
   * Returns an array of all the leafs of the graph.
   */
  getLeafs() {
    return this.getBoundaryNodes(!1);
  }
  /**
   * Returns `true` if the node is a root node, i.e. there is no edges
   * coming to the node.
   */
  isRoot(e) {
    return this.isBoundary(e, !0);
  }
  /**
   * Returns `true` if the node is a leaf node, i.e. there is no edges
   * going out from the node.
   */
  isLeaf(e) {
    return this.isBoundary(e, !1);
  }
  /**
   * Returns all the neighbors of node in the graph. Neighbors are all
   * the nodes connected to node via either incoming or outgoing edge.
   */
  getNeighbors(e, t = {}) {
    let n = t.incoming, i = t.outgoing;
    n == null && i == null && (n = i = !0);
    const o = this.getConnectedEdges(e, t).reduce((a, l) => {
      const c = l.hasLoop(t), u = l.getSourceCell(), f = l.getTargetCell();
      return n && u && u.isNode() && !a[u.id] && (c || u !== e && (!t.deep || !u.isDescendantOf(e))) && (a[u.id] = u), i && f && f.isNode() && !a[f.id] && (c || f !== e && (!t.deep || !f.isDescendantOf(e))) && (a[f.id] = f), a;
    }, {});
    if (e.isEdge()) {
      if (n) {
        const a = e.getSourceCell();
        a && a.isNode() && !o[a.id] && (o[a.id] = a);
      }
      if (i) {
        const a = e.getTargetCell();
        a && a.isNode() && !o[a.id] && (o[a.id] = a);
      }
    }
    return Object.keys(o).map((a) => o[a]);
  }
  /**
   * Returns `true` if `cell2` is a neighbor of `cell1`.
   */
  isNeighbor(e, t, n = {}) {
    let i = n.incoming, r = n.outgoing;
    return i == null && r == null && (i = r = !0), this.getConnectedEdges(e, n).some((o) => {
      const a = o.getSourceCell(), l = o.getTargetCell();
      return !!(i && a && a.id === t.id || r && l && l.id === t.id);
    });
  }
  getSuccessors(e, t = {}) {
    const n = [];
    return this.search(e, (i, r) => {
      i !== e && this.matchDistance(r, t.distance) && n.push(i);
    }, Object.assign(Object.assign({}, t), { outgoing: !0 })), n;
  }
  /**
   * Returns `true` if `cell2` is a successor of `cell1`.
   */
  isSuccessor(e, t, n = {}) {
    let i = !1;
    return this.search(e, (r, o) => {
      if (r === t && r !== e && this.matchDistance(o, n.distance))
        return i = !0, !1;
    }, Object.assign(Object.assign({}, n), { outgoing: !0 })), i;
  }
  getPredecessors(e, t = {}) {
    const n = [];
    return this.search(e, (i, r) => {
      i !== e && this.matchDistance(r, t.distance) && n.push(i);
    }, Object.assign(Object.assign({}, t), { incoming: !0 })), n;
  }
  /**
   * Returns `true` if `cell2` is a predecessor of `cell1`.
   */
  isPredecessor(e, t, n = {}) {
    let i = !1;
    return this.search(e, (r, o) => {
      if (r === t && r !== e && this.matchDistance(o, n.distance))
        return i = !0, !1;
    }, Object.assign(Object.assign({}, n), { incoming: !0 })), i;
  }
  matchDistance(e, t) {
    return t == null ? !0 : typeof t == "function" ? t(e) : Array.isArray(t) && t.includes(e) ? !0 : e === t;
  }
  /**
   * Returns the common ancestor of the passed cells.
   */
  getCommonAncestor(...e) {
    const t = [];
    return e.forEach((n) => {
      n && (Array.isArray(n) ? t.push(...n) : t.push(n));
    }), te.getCommonAncestor(...t);
  }
  /**
   * Returns an array of cells that result from finding nodes/edges that
   * are connected to any of the cells in the cells array. This function
   * loops over cells and if the current cell is a edge, it collects its
   * source/target nodes; if it is an node, it collects its incoming and
   * outgoing edges if both the edge terminal (source/target) are in the
   * cells array.
   */
  getSubGraph(e, t = {}) {
    const n = [], i = {}, r = [], o = [], a = (l) => {
      i[l.id] || (n.push(l), i[l.id] = l, l.isEdge() && o.push(l), l.isNode() && r.push(l));
    };
    return e.forEach((l) => {
      a(l), t.deep && l.getDescendants({ deep: !0 }).forEach((u) => a(u));
    }), o.forEach((l) => {
      const c = l.getSourceCell(), u = l.getTargetCell();
      c && !i[c.id] && (n.push(c), i[c.id] = c, c.isNode() && r.push(c)), u && !i[u.id] && (n.push(u), i[u.id] = u, u.isNode() && r.push(u));
    }), r.forEach((l) => {
      this.getConnectedEdges(l, t).forEach((u) => {
        const f = u.getSourceCell(), d = u.getTargetCell();
        !i[u.id] && f && i[f.id] && d && i[d.id] && (n.push(u), i[u.id] = u);
      });
    }), n;
  }
  /**
   * Clones the whole subgraph (including all the connected links whose
   * source/target is in the subgraph). If `options.deep` is `true`, also
   * take into account all the embedded cells of all the subgraph cells.
   *
   * Returns a map of the form: { [original cell ID]: [clone] }.
   */
  cloneSubGraph(e, t = {}) {
    const n = this.getSubGraph(e, t);
    return this.cloneCells(n);
  }
  cloneCells(e) {
    return te.cloneCells(e);
  }
  getNodesFromPoint(e, t) {
    const n = typeof e == "number" ? { x: e, y: t || 0 } : e;
    return this.getNodes().filter((i) => i.getBBox().containsPoint(n));
  }
  getNodesInArea(e, t, n, i, r) {
    const o = typeof e == "number" ? new R(e, t, n, i) : R.create(e), a = typeof e == "number" ? r : t, l = a && a.strict;
    return this.getNodes().filter((c) => {
      const u = c.getBBox();
      return l ? o.containsRect(u) : o.isIntersectWithRect(u);
    });
  }
  getEdgesInArea(e, t, n, i, r) {
    const o = typeof e == "number" ? new R(e, t, n, i) : R.create(e), a = typeof e == "number" ? r : t, l = a && a.strict;
    return this.getEdges().filter((c) => {
      const u = c.getBBox();
      return u.width === 0 ? u.inflate(1, 0) : u.height === 0 && u.inflate(0, 1), l ? o.containsRect(u) : o.isIntersectWithRect(u);
    });
  }
  getNodesUnderNode(e, t = {}) {
    const n = e.getBBox();
    return (t.by == null || t.by === "bbox" ? this.getNodesInArea(n) : this.getNodesFromPoint(n[t.by])).filter((r) => e.id !== r.id && !r.isDescendantOf(e));
  }
  /**
   * Returns the bounding box that surrounds all cells in the graph.
   */
  getAllCellsBBox() {
    return this.getCellsBBox(this.getCells());
  }
  /**
   * Returns the bounding box that surrounds all the given cells.
   */
  getCellsBBox(e, t = {}) {
    return te.getCellsBBox(e, t);
  }
  // #region search
  search(e, t, n = {}) {
    n.breadthFirst ? this.breadthFirstSearch(e, t, n) : this.depthFirstSearch(e, t, n);
  }
  breadthFirstSearch(e, t, n = {}) {
    const i = [], r = {}, o = {};
    for (i.push(e), o[e.id] = 0; i.length > 0; ) {
      const a = i.shift();
      if (a == null || r[a.id] || (r[a.id] = !0, G(t, this, a, o[a.id]) === !1))
        continue;
      this.getNeighbors(a, n).forEach((c) => {
        o[c.id] = o[a.id] + 1, i.push(c);
      });
    }
  }
  depthFirstSearch(e, t, n = {}) {
    const i = [], r = {}, o = {};
    for (i.push(e), o[e.id] = 0; i.length > 0; ) {
      const a = i.pop();
      if (a == null || r[a.id] || (r[a.id] = !0, G(t, this, a, o[a.id]) === !1))
        continue;
      const l = this.getNeighbors(a, n), c = i.length;
      l.forEach((u) => {
        o[u.id] = o[a.id] + 1, i.splice(c, 0, u);
      });
    }
  }
  // #endregion
  // #region shortest path
  /** *
   * Returns an array of IDs of nodes on the shortest
   * path between source and target.
   */
  getShortestPath(e, t, n = {}) {
    const i = {};
    this.getEdges().forEach((c) => {
      const u = c.getSourceCellId(), f = c.getTargetCellId();
      u && f && (i[u] || (i[u] = []), i[f] || (i[f] = []), i[u].push(f), n.directed || i[f].push(u));
    });
    const r = typeof e == "string" ? e : e.id, o = nl.run(i, r, n.weight), a = [];
    let l = typeof t == "string" ? t : t.id;
    for (o[l] && a.push(l); l = o[l]; )
      a.unshift(l);
    return a;
  }
  // #endregion
  // #region transform
  /**
   * Translate all cells in the graph by `tx` and `ty` pixels.
   */
  translate(e, t, n) {
    return this.getCells().filter((i) => !i.hasParent()).forEach((i) => i.translate(e, t, n)), this;
  }
  resize(e, t, n) {
    return this.resizeCells(e, t, this.getCells(), n);
  }
  resizeCells(e, t, n, i = {}) {
    const r = this.getCellsBBox(n);
    if (r) {
      const o = Math.max(e / r.width, 0), a = Math.max(t / r.height, 0), l = r.getOrigin();
      n.forEach((c) => c.scale(o, a, l, i));
    }
    return this;
  }
  // #endregion
  // #region serialize/deserialize
  toJSON(e = {}) {
    return Tt.toJSON(this.getCells(), e);
  }
  parseJSON(e) {
    return Tt.fromJSON(e);
  }
  fromJSON(e, t = {}) {
    const n = this.parseJSON(e);
    return this.resetCells(n, t), this;
  }
  // #endregion
  // #region batch
  startBatch(e, t = {}) {
    return this.batches[e] = (this.batches[e] || 0) + 1, this.notify("batch:start", { name: e, data: t }), this;
  }
  stopBatch(e, t = {}) {
    return this.batches[e] = (this.batches[e] || 0) - 1, this.notify("batch:stop", { name: e, data: t }), this;
  }
  batchUpdate(e, t, n = {}) {
    this.startBatch(e, n);
    const i = t();
    return this.stopBatch(e, n), i;
  }
  hasActiveBatch(e = Object.keys(this.batches)) {
    return (Array.isArray(e) ? e : [e]).some((n) => this.batches[n] > 0);
  }
  // #endregion
  dispose() {
    this.collection.dispose();
  }
}
w3([
  Tt.dispose()
], Tt.prototype, "dispose", null);
(function(s) {
  s.toStringTag = "X6.".concat(s.name);
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof s)
      return !0;
    const n = t[Symbol.toStringTag], i = t;
    return (n == null || n === s.toStringTag) && typeof i.addNode == "function" && typeof i.addEdge == "function" && i.collection != null;
  }
  s.isModel = e;
})(Tt || (Tt = {}));
(function(s) {
  function e(n, i = {}) {
    return {
      cells: n.map((r) => r.toJSON(i))
    };
  }
  s.toJSON = e;
  function t(n) {
    const i = [];
    return Array.isArray(n) ? i.push(...n) : (n.cells && i.push(...n.cells), n.nodes && n.nodes.forEach((r) => {
      r.shape == null && (r.shape = "rect"), i.push(r);
    }), n.edges && n.edges.forEach((r) => {
      r.shape == null && (r.shape = "edge"), i.push(r);
    })), i.map((r) => {
      const o = r.shape;
      if (o) {
        if (Re.registry.exist(o))
          return Re.create(r);
        if (Ee.registry.exist(o))
          return Ee.create(r);
      }
      throw new Error("The `shape` should be specified when creating a node/edge instance");
    });
  }
  s.fromJSON = t;
})(Tt || (Tt = {}));
var y3 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
let In = class extends Re {
  get label() {
    return this.getLabel();
  }
  set label(e) {
    this.setLabel(e);
  }
  getLabel() {
    return this.getAttrByPath("text/text");
  }
  setLabel(e, t) {
    return e == null ? this.removeLabel() : this.setAttrByPath("text/text", e, t), this;
  }
  removeLabel() {
    return this.removeAttrByPath("text/text"), this;
  }
};
(function(s) {
  s.bodyAttr = {
    fill: "#ffffff",
    stroke: "#333333",
    strokeWidth: 2
  }, s.labelAttr = {
    fontSize: 14,
    fill: "#000000",
    refX: 0.5,
    refY: 0.5,
    textAnchor: "middle",
    textVerticalAnchor: "middle",
    fontFamily: "Arial, helvetica, sans-serif"
  }, s.config({
    attrs: { text: Object.assign({}, s.labelAttr) },
    propHooks(e) {
      const { label: t } = e, n = y3(e, ["label"]);
      return t && gi(n, "attrs/text/text", t), n;
    },
    visible: !0
  });
})(In || (In = {}));
var b3 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
function v3(s, e = "body") {
  return [
    {
      tagName: s,
      selector: e
    },
    {
      tagName: "text",
      selector: "label"
    }
  ];
}
function x3(s = "xlink:href") {
  return (t) => {
    const { imageUrl: n, imageWidth: i, imageHeight: r } = t, o = b3(t, ["imageUrl", "imageWidth", "imageHeight"]);
    if (n != null || i != null || r != null) {
      const a = () => {
        if (o.attrs) {
          const l = o.attrs.image;
          n != null && (l[s] = n), i != null && (l.width = i), r != null && (l.height = r), o.attrs.image = l;
        }
      };
      o.attrs ? (o.attrs.image == null && (o.attrs.image = {}), a()) : (o.attrs = {
        image: {}
      }, a());
    }
    return o;
  };
}
function wi(s, e, t = {}) {
  const n = {
    constructorName: s,
    markup: v3(s, t.selector),
    attrs: {
      [s]: Object.assign({}, In.bodyAttr)
    }
  };
  return (t.parent || In).define(Te(n, e, { shape: s }));
}
wi("rect", {
  attrs: {
    body: {
      refWidth: "100%",
      refHeight: "100%"
    }
  }
});
const C3 = Ee.define({
  shape: "edge",
  markup: [
    {
      tagName: "path",
      selector: "wrap",
      groupSelector: "lines",
      attrs: {
        fill: "none",
        cursor: "pointer",
        stroke: "transparent",
        strokeLinecap: "round"
      }
    },
    {
      tagName: "path",
      selector: "line",
      groupSelector: "lines",
      attrs: {
        fill: "none",
        pointerEvents: "none"
      }
    }
  ],
  attrs: {
    lines: {
      connection: !0,
      strokeLinejoin: "round"
    },
    wrap: {
      strokeWidth: 10
    },
    line: {
      stroke: "#333",
      strokeWidth: 2,
      targetMarker: "classic"
    }
  }
});
wi("ellipse", {
  attrs: {
    body: {
      refCx: "50%",
      refCy: "50%",
      refRx: "50%",
      refRy: "50%"
    }
  }
});
var E3 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
class ii extends In {
  get points() {
    return this.getPoints();
  }
  set points(e) {
    this.setPoints(e);
  }
  getPoints() {
    return this.getAttrByPath("body/refPoints");
  }
  setPoints(e, t) {
    return e == null ? this.removePoints() : this.setAttrByPath("body/refPoints", ii.pointsToString(e), t), this;
  }
  removePoints() {
    return this.removeAttrByPath("body/refPoints"), this;
  }
}
(function(s) {
  function e(t) {
    return typeof t == "string" ? t : t.map((n) => Array.isArray(n) ? n.join(",") : S.isPointLike(n) ? "".concat(n.x, ", ").concat(n.y) : "").join(" ");
  }
  s.pointsToString = e, s.config({
    propHooks(t) {
      const { points: n } = t, i = E3(t, ["points"]);
      if (n) {
        const r = e(n);
        r && gi(i, "attrs/body/refPoints", r);
      }
      return i;
    }
  });
})(ii || (ii = {}));
wi("polygon", {}, { parent: ii });
wi("polyline", {}, { parent: ii });
var S3 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
In.define({
  shape: "path",
  markup: [
    {
      tagName: "rect",
      selector: "bg"
    },
    {
      tagName: "path",
      selector: "body"
    },
    {
      tagName: "text",
      selector: "label"
    }
  ],
  attrs: {
    bg: {
      refWidth: "100%",
      refHeight: "100%",
      fill: "none",
      stroke: "none",
      pointerEvents: "all"
    },
    body: {
      fill: "none",
      stroke: "#000",
      strokeWidth: 2
    }
  },
  propHooks(s) {
    const { path: e } = s, t = S3(s, ["path"]);
    return e && gi(t, "attrs/body/refD", e), t;
  }
});
var A3 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
In.define({
  shape: "text-block",
  markup: [
    {
      tagName: "rect",
      selector: "body"
    },
    On.SUPPORT_FOREIGNOBJECT ? {
      tagName: "foreignObject",
      selector: "foreignObject",
      children: [
        {
          tagName: "div",
          ns: Fe.xhtml,
          selector: "label",
          style: {
            width: "100%",
            height: "100%",
            position: "static",
            backgroundColor: "transparent",
            textAlign: "center",
            margin: 0,
            padding: "0px 5px",
            boxSizing: "border-box",
            display: "flex",
            alignItems: "center",
            justifyContent: "center"
          }
        }
      ]
    } : {
      tagName: "text",
      selector: "label",
      attrs: {
        textAnchor: "middle"
      }
    }
  ],
  attrs: {
    body: Object.assign(Object.assign({}, In.bodyAttr), { refWidth: "100%", refHeight: "100%" }),
    foreignObject: {
      refWidth: "100%",
      refHeight: "100%"
    },
    label: {
      style: {
        fontSize: 14
      }
    }
  },
  propHooks(s) {
    const { text: e } = s, t = A3(s, ["text"]);
    return e && gi(t, "attrs/label/text", e), t;
  },
  attrHooks: {
    text: {
      set(s, { cell: e, view: t, refBBox: n, elem: i, attrs: r }) {
        if (i instanceof HTMLElement)
          i.textContent = s;
        else {
          const o = r.style || {}, a = { text: s, width: -5, height: "100%" }, l = Object.assign({ textVerticalAnchor: "middle" }, o), c = Ut.presets.textWrap;
          return G(c.set, this, a, {
            cell: e,
            view: t,
            elem: i,
            refBBox: n,
            attrs: l
          }), { fill: o.color || null };
        }
      },
      position(s, { refBBox: e, elem: t }) {
        if (t instanceof SVGElement)
          return e.getCenter();
      }
    }
  }
});
wi("image", {
  attrs: {
    image: {
      refWidth: "100%",
      refHeight: "100%"
    }
  },
  propHooks: x3()
}, {
  selector: "image"
});
wi("circle", {
  attrs: {
    body: {
      refCx: "50%",
      refCy: "50%",
      refR: "50%"
    }
  }
});
class It extends Pe {
  constructor() {
    super(...arguments), this.portsCache = {};
  }
  get [Symbol.toStringTag]() {
    return It.toStringTag;
  }
  getContainerClassName() {
    const e = [
      super.getContainerClassName(),
      this.prefixClassName("node")
    ];
    return this.can("nodeMovable") || e.push(this.prefixClassName("node-immovable")), e.join(" ");
  }
  updateClassName(e) {
    const t = e.target;
    if (t.hasAttribute("magnet")) {
      const n = this.prefixClassName("port-unconnectable");
      this.can("magnetConnectable") ? Et(t, n) : se(t, n);
    } else {
      const n = this.prefixClassName("node-immovable");
      this.can("nodeMovable") ? this.removeClass(n) : this.addClass(n);
    }
  }
  isNodeView() {
    return !0;
  }
  confirmUpdate(e, t = {}) {
    let n = e;
    return this.hasAction(n, "ports") && (this.removePorts(), this.cleanPortsCache()), this.hasAction(n, "render") ? (this.render(), n = this.removeAction(n, [
      "render",
      "update",
      "resize",
      "translate",
      "rotate",
      "ports",
      "tools"
    ])) : (n = this.handleAction(n, "resize", () => this.resize(), "update"), n = this.handleAction(
      n,
      "update",
      () => this.update(),
      // `update()` will render ports when useCSSSelectors are enabled
      "ports"
    ), n = this.handleAction(n, "translate", () => this.translate()), n = this.handleAction(n, "rotate", () => this.rotate()), n = this.handleAction(n, "ports", () => this.renderPorts()), n = this.handleAction(n, "tools", () => {
      this.getFlag("tools") === e ? this.renderTools() : this.updateTools(t);
    })), n;
  }
  update(e) {
    this.cleanCache(), this.removePorts();
    const t = this.cell, n = t.getSize(), i = t.getAttrs();
    this.updateAttrs(this.container, i, {
      attrs: e === i ? null : e,
      rootBBox: new R(0, 0, n.width, n.height),
      selectors: this.selectors
    }), this.renderPorts();
  }
  renderMarkup() {
    const e = this.cell.markup;
    if (e) {
      if (typeof e == "string")
        throw new TypeError("Not support string markup.");
      return this.renderJSONMarkup(e);
    }
    throw new TypeError("Invalid node markup.");
  }
  renderJSONMarkup(e) {
    const t = this.parseJSONMarkup(e, this.container);
    this.selectors = t.selectors, this.container.appendChild(t.fragment);
  }
  render() {
    return this.empty(), this.renderMarkup(), this.resize(), this.updateTransform(), this.renderTools(), this;
  }
  resize() {
    this.cell.getAngle() && this.rotate(), this.update();
  }
  translate() {
    this.updateTransform();
  }
  rotate() {
    this.updateTransform();
  }
  getTranslationString() {
    const e = this.cell.getPosition();
    return "translate(".concat(e.x, ",").concat(e.y, ")");
  }
  getRotationString() {
    const e = this.cell.getAngle();
    if (e) {
      const t = this.cell.getSize();
      return "rotate(".concat(e, ",").concat(t.width / 2, ",").concat(t.height / 2, ")");
    }
  }
  updateTransform() {
    let e = this.getTranslationString();
    const t = this.getRotationString();
    t && (e += " ".concat(t)), this.container.setAttribute("transform", e);
  }
  // #region ports
  findPortElem(e, t) {
    const n = e ? this.portsCache[e] : null;
    if (!n)
      return null;
    const i = n.portContentElement, r = n.portContentSelectors || {};
    return this.findOne(t, i, r);
  }
  cleanPortsCache() {
    this.portsCache = {};
  }
  removePorts() {
    Object.values(this.portsCache).forEach((e) => {
      Us(e.portElement);
    });
  }
  renderPorts() {
    const e = this.container, t = [];
    e.childNodes.forEach((o) => {
      t.push(o);
    });
    const n = this.cell.getParsedPorts(), i = mc(n, "zIndex"), r = "auto";
    i[r] && i[r].forEach((o) => {
      const a = this.getPortElement(o);
      e.append(a), t.push(a);
    }), Object.keys(i).forEach((o) => {
      if (o !== r) {
        const a = parseInt(o, 10);
        this.appendPorts(i[o], a, t);
      }
    }), this.updatePorts();
  }
  appendPorts(e, t, n) {
    const i = e.map((r) => this.getPortElement(r));
    n[t] || t < 0 ? Zl(n[Math.max(t, 0)], i) : mr(this.container, i);
  }
  getPortElement(e) {
    const t = this.portsCache[e.id];
    return t ? t.portElement : this.createPortElement(e);
  }
  createPortElement(e) {
    let t = ge.renderMarkup(this.cell.getPortContainerMarkup());
    const n = t.elem;
    if (n == null)
      throw new Error("Invalid port container markup.");
    t = ge.renderMarkup(this.getPortMarkup(e));
    const i = t.elem, r = t.selectors;
    if (i == null)
      throw new Error("Invalid port markup.");
    this.setAttrs({
      port: e.id,
      "port-group": e.group
    }, i);
    let o = "x6-port";
    e.group && (o += " x6-port-".concat(e.group)), se(n, o), se(n, "x6-port"), se(i, "x6-port-body"), n.appendChild(i);
    let a = r, l, c;
    if (this.existPortLabel(e)) {
      if (t = ge.renderMarkup(this.getPortLabelMarkup(e.label)), l = t.elem, c = t.selectors, l == null)
        throw new Error("Invalid port label markup.");
      if (r && c) {
        for (const f in c)
          if (r[f] && f !== this.rootSelector)
            throw new Error("Selectors within port must be unique.");
        a = Object.assign(Object.assign({}, r), c);
      }
      se(l, "x6-port-label"), n.appendChild(l);
    }
    return this.portsCache[e.id] = {
      portElement: n,
      portSelectors: a,
      portLabelElement: l,
      portLabelSelectors: c,
      portContentElement: i,
      portContentSelectors: r
    }, this.graph.options.onPortRendered && this.graph.options.onPortRendered({
      port: e,
      node: this.cell,
      container: n,
      selectors: a,
      labelContainer: l,
      labelSelectors: c,
      contentContainer: i,
      contentSelectors: r
    }), n;
  }
  updatePorts() {
    const e = this.cell.getParsedGroups(), t = Object.keys(e);
    t.length === 0 ? this.updatePortGroup() : t.forEach((n) => this.updatePortGroup(n));
  }
  updatePortGroup(e) {
    const t = R.fromSize(this.cell.getSize()), n = this.cell.getPortsLayoutByGroup(e, t);
    for (let i = 0, r = n.length; i < r; i += 1) {
      const o = n[i], a = o.portId, l = this.portsCache[a] || {}, c = o.portLayout;
      if (this.applyPortTransform(l.portElement, c), o.portAttrs != null) {
        const f = {
          selectors: l.portSelectors || {}
        };
        o.portSize && (f.rootBBox = R.fromSize(o.portSize)), this.updateAttrs(l.portElement, o.portAttrs, f);
      }
      const u = o.labelLayout;
      if (u && l.portLabelElement && (this.applyPortTransform(l.portLabelElement, u, -(c.angle || 0)), u.attrs)) {
        const f = {
          selectors: l.portLabelSelectors || {}
        };
        o.labelSize && (f.rootBBox = R.fromSize(o.labelSize)), this.updateAttrs(l.portLabelElement, u.attrs, f);
      }
    }
  }
  applyPortTransform(e, t, n = 0) {
    const i = t.angle, r = t.position, o = Ve().rotate(n).translate(r.x || 0, r.y || 0).rotate(i || 0);
    qs(e, o, { absolute: !0 });
  }
  getPortMarkup(e) {
    return e.markup || this.cell.portMarkup;
  }
  getPortLabelMarkup(e) {
    return e.markup || this.cell.portLabelMarkup;
  }
  existPortLabel(e) {
    return e.attrs && e.attrs.text;
  }
  getEventArgs(e, t, n) {
    const i = this, r = i.cell, o = r;
    return t == null || n == null ? { e, view: i, node: r, cell: o } : { e, x: t, y: n, view: i, node: r, cell: o };
  }
  getPortEventArgs(e, t, n) {
    const i = this, r = i.cell, o = r;
    return n ? {
      e,
      x: n.x,
      y: n.y,
      view: i,
      node: r,
      cell: o,
      port: t
    } : { e, view: i, node: r, cell: o, port: t };
  }
  notifyMouseDown(e, t, n) {
    super.onMouseDown(e, t, n), this.notify("node:mousedown", this.getEventArgs(e, t, n));
  }
  notifyMouseMove(e, t, n) {
    super.onMouseMove(e, t, n), this.notify("node:mousemove", this.getEventArgs(e, t, n));
  }
  notifyMouseUp(e, t, n) {
    super.onMouseUp(e, t, n), this.notify("node:mouseup", this.getEventArgs(e, t, n));
  }
  notifyPortEvent(e, t, n) {
    const i = this.findAttr("port", t.target);
    if (i) {
      const r = t.type;
      e === "node:port:mouseenter" ? t.type = "mouseenter" : e === "node:port:mouseleave" && (t.type = "mouseleave"), this.notify(e, this.getPortEventArgs(t, i, n)), t.type = r;
    }
  }
  onClick(e, t, n) {
    super.onClick(e, t, n), this.notify("node:click", this.getEventArgs(e, t, n)), this.notifyPortEvent("node:port:click", e, { x: t, y: n });
  }
  onDblClick(e, t, n) {
    super.onDblClick(e, t, n), this.notify("node:dblclick", this.getEventArgs(e, t, n)), this.notifyPortEvent("node:port:dblclick", e, { x: t, y: n });
  }
  onContextMenu(e, t, n) {
    super.onContextMenu(e, t, n), this.notify("node:contextmenu", this.getEventArgs(e, t, n)), this.notifyPortEvent("node:port:contextmenu", e, { x: t, y: n });
  }
  onMouseDown(e, t, n) {
    this.isPropagationStopped(e) || (this.notifyMouseDown(e, t, n), this.notifyPortEvent("node:port:mousedown", e, { x: t, y: n }), this.startNodeDragging(e, t, n));
  }
  onMouseMove(e, t, n) {
    const i = this.getEventData(e), r = i.action;
    if (r === "magnet")
      this.dragMagnet(e, t, n);
    else {
      if (r === "move") {
        const a = i.targetView || this;
        a.dragNode(e, t, n), a.notify("node:moving", {
          e,
          x: t,
          y: n,
          view: a,
          cell: a.cell,
          node: a.cell
        });
      }
      this.notifyMouseMove(e, t, n), this.notifyPortEvent("node:port:mousemove", e, { x: t, y: n });
    }
    this.setEventData(e, i);
  }
  onMouseUp(e, t, n) {
    const i = this.getEventData(e), r = i.action;
    r === "magnet" ? this.stopMagnetDragging(e, t, n) : (this.notifyMouseUp(e, t, n), this.notifyPortEvent("node:port:mouseup", e, { x: t, y: n }), r === "move" && (i.targetView || this).stopNodeDragging(e, t, n));
    const o = i.targetMagnet;
    o && this.onMagnetClick(e, o, t, n), this.checkMouseleave(e);
  }
  onMouseOver(e) {
    super.onMouseOver(e), this.notify("node:mouseover", this.getEventArgs(e)), this.notifyPortEvent("node:port:mouseenter", e), this.notifyPortEvent("node:port:mouseover", e);
  }
  onMouseOut(e) {
    super.onMouseOut(e), this.notify("node:mouseout", this.getEventArgs(e)), this.notifyPortEvent("node:port:mouseleave", e), this.notifyPortEvent("node:port:mouseout", e);
  }
  onMouseEnter(e) {
    this.updateClassName(e), super.onMouseEnter(e), this.notify("node:mouseenter", this.getEventArgs(e));
  }
  onMouseLeave(e) {
    super.onMouseLeave(e), this.notify("node:mouseleave", this.getEventArgs(e));
  }
  onMouseWheel(e, t, n, i) {
    super.onMouseWheel(e, t, n, i), this.notify("node:mousewheel", Object.assign({ delta: i }, this.getEventArgs(e, t, n)));
  }
  onMagnetClick(e, t, n, i) {
    const r = this.graph;
    r.view.getMouseMovedCount(e) > r.options.clickThreshold || this.notify("node:magnet:click", Object.assign({ magnet: t }, this.getEventArgs(e, n, i)));
  }
  onMagnetDblClick(e, t, n, i) {
    this.notify("node:magnet:dblclick", Object.assign({ magnet: t }, this.getEventArgs(e, n, i)));
  }
  onMagnetContextMenu(e, t, n, i) {
    this.notify("node:magnet:contextmenu", Object.assign({ magnet: t }, this.getEventArgs(e, n, i)));
  }
  onMagnetMouseDown(e, t, n, i) {
    this.startMagnetDragging(e, n, i);
  }
  onCustomEvent(e, t, n, i) {
    this.notify("node:customevent", Object.assign({ name: t }, this.getEventArgs(e, n, i))), super.onCustomEvent(e, t, n, i);
  }
  prepareEmbedding(e) {
    const t = this.graph, i = this.getEventData(e).cell || this.cell, r = t.findViewByCell(i), o = t.snapToGrid(e.clientX, e.clientY);
    this.notify("node:embed", {
      e,
      node: i,
      view: r,
      cell: i,
      x: o.x,
      y: o.y,
      currentParent: i.getParent()
    });
  }
  processEmbedding(e, t) {
    const n = t.cell || this.cell, i = t.graph || this.graph, r = i.options.embedding, o = r.findParent;
    let a = typeof o == "function" ? G(o, i, {
      view: this,
      node: this.cell
    }).filter((d) => te.isCell(d) && this.cell.id !== d.id && !d.isDescendantOf(this.cell)) : i.model.getNodesUnderNode(n, {
      by: o
    });
    if (r.frontOnly && a.length > 0) {
      const d = mc(a, "zIndex"), g = dp(Object.keys(d).map((p) => parseInt(p, 10)));
      g && (a = d[g]);
    }
    a = a.filter((d) => d.visible);
    let l = null;
    const c = t.candidateEmbedView, u = r.validate;
    for (let d = a.length - 1; d >= 0; d -= 1) {
      const g = a[d];
      if (c && c.cell.id === g.id) {
        l = c;
        break;
      } else {
        const p = g.findView(i);
        if (u && G(u, i, {
          child: this.cell,
          parent: p.cell,
          childView: this,
          parentView: p
        })) {
          l = p;
          break;
        }
      }
    }
    this.clearEmbedding(t), l && l.highlight(null, { type: "embedding" }), t.candidateEmbedView = l;
    const f = i.snapToGrid(e.clientX, e.clientY);
    this.notify("node:embedding", {
      e,
      cell: n,
      node: n,
      view: i.findViewByCell(n),
      x: f.x,
      y: f.y,
      currentParent: n.getParent(),
      candidateParent: l ? l.cell : null
    });
  }
  clearEmbedding(e) {
    const t = e.candidateEmbedView;
    t && (t.unhighlight(null, { type: "embedding" }), e.candidateEmbedView = null);
  }
  finalizeEmbedding(e, t) {
    this.graph.startBatch("embedding");
    const n = t.cell || this.cell, i = t.graph || this.graph, r = i.findViewByCell(n), o = n.getParent(), a = t.candidateEmbedView;
    if (a ? (a.unhighlight(null, { type: "embedding" }), t.candidateEmbedView = null, (o == null || o.id !== a.cell.id) && a.cell.insertChild(n, void 0, { ui: !0 })) : o && o.unembed(n, { ui: !0 }), i.model.getConnectedEdges(n, { deep: !0 }).forEach((l) => {
      l.updateParent({ ui: !0 });
    }), r && a) {
      const l = i.snapToGrid(e.clientX, e.clientY);
      r.notify("node:embedded", {
        e,
        cell: n,
        x: l.x,
        y: l.y,
        node: n,
        view: i.findViewByCell(n),
        previousParent: o,
        currentParent: n.getParent()
      });
    }
    this.graph.stopBatch("embedding");
  }
  getDelegatedView() {
    let e = this.cell, t = this;
    for (; t && !e.isEdge(); ) {
      if (!e.hasParent() || t.can("stopDelegateOnDragging"))
        return t;
      e = e.getParent(), t = this.graph.findViewByCell(e);
    }
    return null;
  }
  validateMagnet(e, t, n) {
    if (t.getAttribute("magnet") !== "passive") {
      const i = this.graph.options.connecting.validateMagnet;
      return i ? G(i, this.graph, {
        e: n,
        magnet: t,
        view: e,
        cell: e.cell
      }) : !0;
    }
    return !1;
  }
  startMagnetDragging(e, t, n) {
    if (!this.can("magnetConnectable"))
      return;
    e.stopPropagation();
    const i = e.currentTarget, r = this.graph;
    this.setEventData(e, {
      targetMagnet: i
    }), this.validateMagnet(this, i, e) ? (r.options.magnetThreshold <= 0 && this.startConnectting(e, i, t, n), this.setEventData(e, {
      action: "magnet"
    }), this.stopPropagation(e)) : this.onMouseDown(e, t, n), r.view.delegateDragEvents(e, this);
  }
  startConnectting(e, t, n, i) {
    this.graph.model.startBatch("add-edge");
    const r = this.createEdgeFromMagnet(t, n, i);
    r.setEventData(e, r.prepareArrowheadDragging("target", {
      x: n,
      y: i,
      isNewEdge: !0,
      fallbackAction: "remove"
    })), this.setEventData(e, { edgeView: r }), r.notifyMouseDown(e, n, i);
  }
  getDefaultEdge(e, t) {
    let n;
    const i = this.graph.options.connecting.createEdge;
    return i && (n = G(i, this.graph, {
      sourceMagnet: t,
      sourceView: e,
      sourceCell: e.cell
    })), n;
  }
  createEdgeFromMagnet(e, t, n) {
    const i = this.graph, r = i.model, o = this.getDefaultEdge(this, e);
    return o.setSource(Object.assign(Object.assign({}, o.getSource()), this.getEdgeTerminal(e, t, n, o, "source"))), o.setTarget(Object.assign(Object.assign({}, o.getTarget()), { x: t, y: n })), o.addTo(r, { async: !1, ui: !0 }), o.findView(i);
  }
  dragMagnet(e, t, n) {
    const i = this.getEventData(e), r = i.edgeView;
    if (r)
      r.onMouseMove(e, t, n), this.autoScrollGraph(e.clientX, e.clientY);
    else {
      const o = this.graph, a = o.options.magnetThreshold, l = this.getEventTarget(e), c = i.targetMagnet;
      if (a === "onleave") {
        if (c === l || c.contains(l))
          return;
      } else if (o.view.getMouseMovedCount(e) <= a)
        return;
      this.startConnectting(e, c, t, n);
    }
  }
  stopMagnetDragging(e, t, n) {
    const r = this.eventData(e).edgeView;
    r && (r.onMouseUp(e, t, n), this.graph.model.stopBatch("add-edge"));
  }
  notifyUnhandledMouseDown(e, t, n) {
    this.notify("node:unhandled:mousedown", {
      e,
      x: t,
      y: n,
      view: this,
      cell: this.cell,
      node: this.cell
    });
  }
  notifyNodeMove(e, t, n, i, r) {
    let o = [r];
    const a = this.graph.getPlugin("selection");
    if (a && a.isSelectionMovable()) {
      const l = a.getSelectedCells();
      l.includes(r) && (o = l.filter((c) => c.isNode()));
    }
    o.forEach((l) => {
      this.notify(e, {
        e: t,
        x: n,
        y: i,
        cell: l,
        node: l,
        view: l.findView(this.graph)
      });
    });
  }
  getRestrictArea(e) {
    const t = this.graph.options.translating.restrict, n = typeof t == "function" ? G(t, this.graph, e) : t;
    return typeof n == "number" ? this.graph.transform.getGraphArea().inflate(n) : n === !0 ? this.graph.transform.getGraphArea() : n || null;
  }
  startNodeDragging(e, t, n) {
    const i = this.getDelegatedView();
    if (i == null || !i.can("nodeMovable"))
      return this.notifyUnhandledMouseDown(e, t, n);
    this.setEventData(e, {
      targetView: i,
      action: "move"
    });
    const r = S.create(i.cell.getPosition());
    i.setEventData(e, {
      moving: !1,
      offset: r.diff(t, n),
      restrict: this.getRestrictArea(i)
    });
  }
  dragNode(e, t, n) {
    const i = this.cell, r = this.graph, o = r.getGridSize(), a = this.getEventData(e), l = a.offset, c = a.restrict;
    a.moving || (a.moving = !0, this.addClass("node-moving"), this.notifyNodeMove("node:move", e, t, n, this.cell)), this.autoScrollGraph(e.clientX, e.clientY);
    const u = le.snapToGrid(t + l.x, o), f = le.snapToGrid(n + l.y, o);
    i.setPosition(u, f, {
      restrict: c,
      deep: !0,
      ui: !0
    }), r.options.embedding.enabled && (a.embedding || (this.prepareEmbedding(e), a.embedding = !0), this.processEmbedding(e, a));
  }
  stopNodeDragging(e, t, n) {
    const i = this.getEventData(e);
    i.embedding && this.finalizeEmbedding(e, i), i.moving && (this.removeClass("node-moving"), this.notifyNodeMove("node:moved", e, t, n, this.cell)), i.moving = !1, i.embedding = !1;
  }
  // eslint-disable-next-line
  autoScrollGraph(e, t) {
    const n = this.graph.getPlugin("scroller");
    n && n.autoScroll(e, t);
  }
}
(function(s) {
  s.toStringTag = "X6.".concat(s.name);
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof s)
      return !0;
    const n = t[Symbol.toStringTag], i = t;
    return (n == null || n === s.toStringTag) && typeof i.isNodeView == "function" && typeof i.isEdgeView == "function" && typeof i.confirmUpdate == "function" && typeof i.update == "function" && typeof i.findPortElem == "function" && typeof i.resize == "function" && typeof i.rotate == "function" && typeof i.translate == "function";
  }
  s.isNodeView = e;
})(It || (It = {}));
It.config({
  isSvgElement: !0,
  priority: 0,
  bootstrap: ["render"],
  actions: {
    view: ["render"],
    markup: ["render"],
    attrs: ["update"],
    size: ["resize", "ports", "tools"],
    angle: ["rotate", "tools"],
    position: ["translate", "tools"],
    ports: ["ports"],
    tools: ["tools"]
  }
});
It.registry.register("node", It, !0);
var M3 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
class cn extends Pe {
  constructor() {
    super(...arguments), this.POINT_ROUNDING = 2, this.labelDestroyFn = {};
  }
  get [Symbol.toStringTag]() {
    return cn.toStringTag;
  }
  getContainerClassName() {
    return [super.getContainerClassName(), this.prefixClassName("edge")].join(" ");
  }
  get sourceBBox() {
    const e = this.sourceView;
    if (!e) {
      const n = this.cell.getSource();
      return new R(n.x, n.y);
    }
    const t = this.sourceMagnet;
    return e.isEdgeElement(t) ? new R(this.sourceAnchor.x, this.sourceAnchor.y) : e.getBBoxOfElement(t || e.container);
  }
  get targetBBox() {
    const e = this.targetView;
    if (!e) {
      const n = this.cell.getTarget();
      return new R(n.x, n.y);
    }
    const t = this.targetMagnet;
    return e.isEdgeElement(t) ? new R(this.targetAnchor.x, this.targetAnchor.y) : e.getBBoxOfElement(t || e.container);
  }
  isEdgeView() {
    return !0;
  }
  confirmUpdate(e, t = {}) {
    let n = e;
    if (this.hasAction(n, "source")) {
      if (!this.updateTerminalProperties("source"))
        return n;
      n = this.removeAction(n, "source");
    }
    if (this.hasAction(n, "target")) {
      if (!this.updateTerminalProperties("target"))
        return n;
      n = this.removeAction(n, "target");
    }
    return this.hasAction(n, "render") ? (this.render(), n = this.removeAction(n, ["render", "update", "labels", "tools"]), n) : (n = this.handleAction(n, "update", () => this.update(t)), n = this.handleAction(n, "labels", () => this.onLabelsChange(t)), n = this.handleAction(n, "tools", () => this.renderTools()), n);
  }
  // #region render
  render() {
    return this.empty(), this.renderMarkup(), this.labelContainer = null, this.renderLabels(), this.update(), this.renderTools(), this;
  }
  renderMarkup() {
    const e = this.cell.markup;
    if (e) {
      if (typeof e == "string")
        throw new TypeError("Not support string markup.");
      return this.renderJSONMarkup(e);
    }
    throw new TypeError("Invalid edge markup.");
  }
  renderJSONMarkup(e) {
    const t = this.parseJSONMarkup(e, this.container);
    this.selectors = t.selectors, this.container.append(t.fragment);
  }
  customizeLabels() {
    if (this.labelContainer) {
      const e = this.cell, t = e.labels;
      for (let n = 0, i = t.length; n < i; n += 1) {
        const r = t[n], o = this.labelCache[n], a = this.labelSelectors[n], l = this.graph.options.onEdgeLabelRendered;
        if (l) {
          const c = l({
            edge: e,
            label: r,
            container: o,
            selectors: a
          });
          c && (this.labelDestroyFn[n] = c);
        }
      }
    }
  }
  destroyCustomizeLabels() {
    const e = this.cell.labels;
    if (this.labelCache && this.labelSelectors && this.labelDestroyFn)
      for (let t = 0, n = e.length; t < n; t += 1) {
        const i = this.labelDestroyFn[t], r = this.labelCache[t], o = this.labelSelectors[t];
        i && r && o && i({
          edge: this.cell,
          label: e[t],
          container: r,
          selectors: o
        });
      }
    this.labelDestroyFn = {};
  }
  renderLabels() {
    const e = this.cell, t = e.getLabels(), n = t.length;
    let i = this.labelContainer;
    if (this.labelCache = {}, this.labelSelectors = {}, n <= 0)
      return i && i.parentNode && i.parentNode.removeChild(i), this;
    i ? this.empty(i) : (i = jt("g"), this.addClass(this.prefixClassName("edge-labels"), i), this.labelContainer = i);
    for (let r = 0, o = t.length; r < o; r += 1) {
      const a = t[r], l = this.normalizeLabelMarkup(this.parseLabelMarkup(a.markup));
      let c, u;
      if (l)
        c = l.node, u = l.selectors;
      else {
        const d = e.getDefaultLabel(), g = this.normalizeLabelMarkup(this.parseLabelMarkup(d.markup));
        c = g.node, u = g.selectors;
      }
      c.setAttribute("data-index", "".concat(r)), i.appendChild(c);
      const f = this.rootSelector;
      if (u[f])
        throw new Error("Ambiguous label root selector.");
      u[f] = c, this.labelCache[r] = c, this.labelSelectors[r] = u;
    }
    return i.parentNode == null && this.container.appendChild(i), this.updateLabels(), this.customizeLabels(), this;
  }
  onLabelsChange(e = {}) {
    this.destroyCustomizeLabels(), this.shouldRerenderLabels(e) ? this.renderLabels() : this.updateLabels(), this.updateLabelPositions();
  }
  shouldRerenderLabels(e = {}) {
    const t = this.cell.previous("labels");
    if (t == null)
      return !0;
    if ("propertyPathArray" in e && "propertyValue" in e) {
      const n = e.propertyPathArray || [], i = n.length;
      if (i > 1) {
        const r = n[1];
        if (t[r]) {
          if (i === 2)
            return typeof e.propertyValue == "object" && Ar(e.propertyValue, "markup");
          if (n[2] !== "markup")
            return !1;
        }
      }
    }
    return !0;
  }
  parseLabelMarkup(e) {
    return e ? typeof e == "string" ? this.parseLabelStringMarkup(e) : this.parseJSONMarkup(e) : null;
  }
  parseLabelStringMarkup(e) {
    const t = U.createVectors(e), n = document.createDocumentFragment();
    for (let i = 0, r = t.length; i < r; i += 1) {
      const o = t[i].node;
      n.appendChild(o);
    }
    return { fragment: n, selectors: {} };
  }
  normalizeLabelMarkup(e) {
    if (e == null)
      return;
    const t = e.fragment;
    if (!(t instanceof DocumentFragment) || !t.hasChildNodes())
      throw new Error("Invalid label markup.");
    let n;
    const i = t.childNodes;
    return i.length > 1 || i[0].nodeName.toUpperCase() !== "G" ? n = U.create("g").append(t) : n = U.create(i[0]), n.addClass(this.prefixClassName("edge-label")), {
      node: n.node,
      selectors: e.selectors
    };
  }
  updateLabels() {
    if (this.labelContainer) {
      const e = this.cell, t = e.labels, n = this.can("edgeLabelMovable"), i = e.getDefaultLabel();
      for (let r = 0, o = t.length; r < o; r += 1) {
        const a = this.labelCache[r], l = this.labelSelectors[r];
        a.setAttribute("cursor", n ? "move" : "default");
        const c = t[r], u = Te({}, i.attrs, c.attrs);
        this.updateAttrs(a, u, {
          selectors: l,
          rootBBox: c.size ? R.fromSize(c.size) : void 0
        });
      }
    }
  }
  renderTools() {
    const e = this.cell.getTools();
    return this.addTools(e), this;
  }
  // #endregion
  // #region updating
  update(e = {}) {
    this.cleanCache(), this.updateConnection(e);
    const t = this.cell.getAttrs(), n = M3(t, ["text"]);
    return n != null && this.updateAttrs(this.container, n, {
      selectors: this.selectors
    }), this.updateLabelPositions(), this.updateTools(e), this;
  }
  removeRedundantLinearVertices(e = {}) {
    const t = this.cell, n = t.getVertices(), i = [this.sourceAnchor, ...n, this.targetAnchor], r = i.length, o = new ke(i);
    o.simplify({ threshold: 0.01 });
    const a = o.points.map((c) => c.toJSON()), l = a.length;
    return r === l ? 0 : (t.setVertices(a.slice(1, l - 1), e), r - l);
  }
  getTerminalView(e) {
    switch (e) {
      case "source":
        return this.sourceView || null;
      case "target":
        return this.targetView || null;
      default:
        throw new Error("Unknown terminal type '".concat(e, "'"));
    }
  }
  getTerminalAnchor(e) {
    switch (e) {
      case "source":
        return S.create(this.sourceAnchor);
      case "target":
        return S.create(this.targetAnchor);
      default:
        throw new Error("Unknown terminal type '".concat(e, "'"));
    }
  }
  getTerminalConnectionPoint(e) {
    switch (e) {
      case "source":
        return S.create(this.sourcePoint);
      case "target":
        return S.create(this.targetPoint);
      default:
        throw new Error("Unknown terminal type '".concat(e, "'"));
    }
  }
  getTerminalMagnet(e, t = {}) {
    switch (e) {
      case "source": {
        if (t.raw)
          return this.sourceMagnet;
        const n = this.sourceView;
        return n ? this.sourceMagnet || n.container : null;
      }
      case "target": {
        if (t.raw)
          return this.targetMagnet;
        const n = this.targetView;
        return n ? this.targetMagnet || n.container : null;
      }
      default:
        throw new Error("Unknown terminal type '".concat(e, "'"));
    }
  }
  updateConnection(e = {}) {
    const t = this.cell;
    if (e.translateBy && t.isFragmentDescendantOf(e.translateBy)) {
      const n = e.tx || 0, i = e.ty || 0;
      this.routePoints = new ke(this.routePoints).translate(n, i).points, this.translateConnectionPoints(n, i), this.path.translate(n, i);
    } else {
      const n = t.getVertices(), i = this.findAnchors(n);
      this.sourceAnchor = i.source, this.targetAnchor = i.target, this.routePoints = this.findRoutePoints(n);
      const r = this.findConnectionPoints(this.routePoints, this.sourceAnchor, this.targetAnchor);
      this.sourcePoint = r.source, this.targetPoint = r.target;
      const o = this.findMarkerPoints(this.routePoints, this.sourcePoint, this.targetPoint);
      this.path = this.findPath(this.routePoints, o.source || this.sourcePoint, o.target || this.targetPoint);
    }
    this.cleanCache();
  }
  findAnchors(e) {
    const t = this.cell, n = t.source, i = t.target, r = e[0], o = e[e.length - 1];
    return i.priority && !n.priority ? this.findAnchorsOrdered("target", o, "source", r) : this.findAnchorsOrdered("source", r, "target", o);
  }
  findAnchorsOrdered(e, t, n, i) {
    let r, o;
    const a = this.cell, l = a[e], c = a[n], u = this.getTerminalView(e), f = this.getTerminalView(n), d = this.getTerminalMagnet(e), g = this.getTerminalMagnet(n);
    if (u) {
      let p;
      t ? p = S.create(t) : f ? p = g : p = S.create(c), r = this.getAnchor(l.anchor, u, d, p, e);
    } else
      r = S.create(l);
    if (f) {
      const p = S.create(i || r);
      o = this.getAnchor(c.anchor, f, g, p, n);
    } else
      o = S.isPointLike(c) ? S.create(c) : new S();
    return {
      [e]: r,
      [n]: o
    };
  }
  getAnchor(e, t, n, i, r) {
    const o = t.isEdgeElement(n), a = this.graph.options.connecting;
    let l = typeof e == "string" ? { name: e } : e;
    if (!l) {
      const f = o ? (r === "source" ? a.sourceEdgeAnchor : a.targetEdgeAnchor) || a.edgeAnchor : (r === "source" ? a.sourceAnchor : a.targetAnchor) || a.anchor;
      l = typeof f == "string" ? { name: f } : f;
    }
    if (!l)
      throw new Error("Anchor should be specified.");
    let c;
    const u = l.name;
    if (o) {
      const f = ti.registry.get(u);
      if (typeof f != "function")
        return ti.registry.onNotFound(u);
      c = G(f, this, t, n, i, l.args || {}, r);
    } else {
      const f = ei.registry.get(u);
      if (typeof f != "function")
        return ei.registry.onNotFound(u);
      c = G(f, this, t, n, i, l.args || {}, r);
    }
    return c ? c.round(this.POINT_ROUNDING) : new S();
  }
  findRoutePoints(e = []) {
    const t = this.graph.options.connecting.router || An.presets.normal, n = this.cell.getRouter() || t;
    let i;
    if (typeof n == "function")
      i = G(n, this, e, {}, this);
    else {
      const r = typeof n == "string" ? n : n.name, o = typeof n == "string" ? {} : n.args || {}, a = r ? An.registry.get(r) : An.presets.normal;
      if (typeof a != "function")
        return An.registry.onNotFound(r);
      i = G(a, this, e, o, this);
    }
    return i == null ? e.map((r) => S.create(r)) : i.map((r) => S.create(r));
  }
  findConnectionPoints(e, t, n) {
    const i = this.cell, r = this.graph.options.connecting, o = i.getSource(), a = i.getTarget(), l = this.sourceView, c = this.targetView, u = e[0], f = e[e.length - 1];
    let d;
    if (l && !l.isEdgeElement(this.sourceMagnet)) {
      const p = this.sourceMagnet || l.container, m = u || n, w = new $(m, t), v = o.connectionPoint || r.sourceConnectionPoint || r.connectionPoint;
      d = this.getConnectionPoint(v, l, p, w, "source");
    } else
      d = t;
    let g;
    if (c && !c.isEdgeElement(this.targetMagnet)) {
      const p = this.targetMagnet || c.container, m = a.connectionPoint || r.targetConnectionPoint || r.connectionPoint, w = f || t, v = new $(w, n);
      g = this.getConnectionPoint(m, c, p, v, "target");
    } else
      g = n;
    return {
      source: d,
      target: g
    };
  }
  getConnectionPoint(e, t, n, i, r) {
    const o = i.end;
    if (e == null)
      return o;
    const a = typeof e == "string" ? e : e.name, l = typeof e == "string" ? {} : e.args, c = ni.registry.get(a);
    if (typeof c != "function")
      return ni.registry.onNotFound(a);
    const u = G(c, this, i, t, n, l || {}, r);
    return u ? u.round(this.POINT_ROUNDING) : o;
  }
  findMarkerPoints(e, t, n) {
    const i = (f) => {
      const d = this.cell.getAttrs(), g = Object.keys(d);
      for (let p = 0, m = g.length; p < m; p += 1) {
        const w = d[g[p]];
        if (w["".concat(f, "Marker")] || w["".concat(f, "-marker")]) {
          const v = w.strokeWidth || w["stroke-width"];
          if (v)
            return parseFloat(v);
          break;
        }
      }
      return null;
    }, r = e[0], o = e[e.length - 1];
    let a, l;
    const c = i("source");
    c && (a = t.clone().move(r || n, -c));
    const u = i("target");
    return u && (l = n.clone().move(o || t, -u)), this.sourceMarkerPoint = a || t.clone(), this.targetMarkerPoint = l || n.clone(), {
      source: a,
      target: l
    };
  }
  findPath(e, t, n) {
    const i = this.cell.getConnector() || this.graph.options.connecting.connector;
    let r, o, a;
    if (typeof i == "string" ? r = i : (r = i.name, o = i.args), r) {
      const c = ss.registry.get(r);
      if (typeof c != "function")
        return ss.registry.onNotFound(r);
      a = c;
    } else
      a = ss.presets.normal;
    const l = G(a, this, t, n, e, Object.assign(Object.assign({}, o), { raw: !0 }), this);
    return typeof l == "string" ? F.parse(l) : l;
  }
  translateConnectionPoints(e, t) {
    this.sourcePoint.translate(e, t), this.targetPoint.translate(e, t), this.sourceAnchor.translate(e, t), this.targetAnchor.translate(e, t), this.sourceMarkerPoint.translate(e, t), this.targetMarkerPoint.translate(e, t);
  }
  updateLabelPositions() {
    if (this.labelContainer == null)
      return this;
    if (!this.path)
      return this;
    const t = this.cell, n = t.getLabels();
    if (n.length === 0)
      return this;
    const i = t.getDefaultLabel(), r = this.normalizeLabelPosition(i.position);
    for (let o = 0, a = n.length; o < a; o += 1) {
      const l = n[o], c = this.labelCache[o];
      if (!c)
        continue;
      const u = this.normalizeLabelPosition(l.position), f = Te({}, r, u), d = this.getLabelTransformationMatrix(f);
      c.setAttribute("transform", pi(d));
    }
    return this;
  }
  updateTerminalProperties(e) {
    const t = this.cell, n = this.graph, i = t[e], r = i && i.cell, o = "".concat(e, "View");
    if (!r)
      return this[o] = null, this.updateTerminalMagnet(e), !0;
    const a = n.getCellById(r);
    if (!a)
      throw new Error("Edge's ".concat(e, ' node with id "').concat(r, '" not exists'));
    const l = a.findView(n);
    return l ? (this[o] = l, this.updateTerminalMagnet(e), !0) : !1;
  }
  updateTerminalMagnet(e) {
    const t = "".concat(e, "Magnet"), n = this.getTerminalView(e);
    if (n) {
      let i = n.getMagnetFromEdgeTerminal(this.cell[e]);
      i === n.container && (i = null), this[t] = i;
    } else
      this[t] = null;
  }
  getLabelPositionAngle(e) {
    const t = this.cell.getLabelAt(e);
    return t && t.position && typeof t.position == "object" && t.position.angle || 0;
  }
  getLabelPositionArgs(e) {
    const t = this.cell.getLabelAt(e);
    if (t && t.position && typeof t.position == "object")
      return t.position.options;
  }
  getDefaultLabelPositionArgs() {
    const e = this.cell.getDefaultLabel();
    if (e && e.position && typeof e.position == "object")
      return e.position.options;
  }
  mergeLabelPositionArgs(e, t) {
    return e === null ? null : e === void 0 ? t === null ? null : t : Te({}, t, e);
  }
  // #endregion
  getConnection() {
    return this.path != null ? this.path.clone() : null;
  }
  getConnectionPathData() {
    if (this.path == null)
      return "";
    const e = this.cache.pathCache;
    return Ar(e, "data") || (e.data = this.path.serialize()), e.data || "";
  }
  getConnectionSubdivisions() {
    if (this.path == null)
      return null;
    const e = this.cache.pathCache;
    return Ar(e, "segmentSubdivisions") || (e.segmentSubdivisions = this.path.getSegmentSubdivisions()), e.segmentSubdivisions;
  }
  getConnectionLength() {
    if (this.path == null)
      return 0;
    const e = this.cache.pathCache;
    return Ar(e, "length") || (e.length = this.path.length({
      segmentSubdivisions: this.getConnectionSubdivisions()
    })), e.length;
  }
  getPointAtLength(e) {
    return this.path == null ? null : this.path.pointAtLength(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getPointAtRatio(e) {
    return this.path == null ? null : (ln(e) && (e = parseFloat(e) / 100), this.path.pointAt(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    }));
  }
  getTangentAtLength(e) {
    return this.path == null ? null : this.path.tangentAtLength(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getTangentAtRatio(e) {
    return this.path == null ? null : this.path.tangentAt(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getClosestPoint(e) {
    return this.path == null ? null : this.path.closestPoint(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getClosestPointLength(e) {
    return this.path == null ? null : this.path.closestPointLength(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getClosestPointRatio(e) {
    return this.path == null ? null : this.path.closestPointNormalizedLength(e, {
      segmentSubdivisions: this.getConnectionSubdivisions()
    });
  }
  getLabelPosition(e, t, n, i) {
    const r = { distance: 0 };
    let o = 0, a;
    typeof n == "number" ? (o = n, a = i) : a = n, a != null && (r.options = a);
    const l = a && a.absoluteOffset, c = !(a && a.absoluteDistance), u = a && a.absoluteDistance && a.reverseDistance, f = this.path, d = {
      segmentSubdivisions: this.getConnectionSubdivisions()
    }, g = new S(e, t), p = f.closestPointT(g, d), m = this.getConnectionLength() || 0;
    let w = f.lengthAtT(p, d);
    c && (w = m > 0 ? w / m : 0), u && (w = -1 * (m - w) || 1), r.distance = w;
    let v;
    l || (v = f.tangentAtT(p));
    let y;
    if (v)
      y = v.pointOffset(g);
    else {
      const b = f.pointAtT(p), x = g.diff(b);
      y = { x: x.x, y: x.y };
    }
    return r.offset = y, r.angle = o, r;
  }
  normalizeLabelPosition(e) {
    return typeof e == "number" ? { distance: e } : e;
  }
  getLabelTransformationMatrix(e) {
    const t = this.normalizeLabelPosition(e), n = t.options || {}, i = t.angle || 0, r = t.distance, o = r > 0 && r <= 1;
    let a = 0;
    const l = { x: 0, y: 0 }, c = t.offset;
    c && (typeof c == "number" ? a = c : (c.x != null && (l.x = c.x), c.y != null && (l.y = c.y)));
    const u = l.x !== 0 || l.y !== 0 || a === 0, f = n.keepGradient, d = n.ensureLegibility, g = this.path, p = { segmentSubdivisions: this.getConnectionSubdivisions() }, m = o ? r * this.getConnectionLength() : r, w = g.tangentAtLength(m, p);
    let v, y = i;
    if (w) {
      if (u)
        v = w.start, v.translate(l);
      else {
        const b = w.clone();
        b.rotate(-90, w.start), b.setLength(a), v = b.end;
      }
      f && (y = w.angle() + i, d && (y = ce.normalize((y + 90) % 180 - 90)));
    } else
      v = g.start, u && v.translate(l);
    return Ve().translate(v.x, v.y).rotate(y);
  }
  getVertexIndex(e, t) {
    const i = this.cell.getVertices(), r = this.getClosestPointLength(new S(e, t));
    let o = 0;
    if (r != null)
      for (const a = i.length; o < a; o += 1) {
        const l = i[o], c = this.getClosestPointLength(l);
        if (c != null && r < c)
          break;
      }
    return o;
  }
  getEventArgs(e, t, n) {
    const i = this, r = i.cell, o = r;
    return t == null || n == null ? { e, view: i, edge: r, cell: o } : { e, x: t, y: n, view: i, edge: r, cell: o };
  }
  notifyUnhandledMouseDown(e, t, n) {
    this.notify("edge:unhandled:mousedown", {
      e,
      x: t,
      y: n,
      view: this,
      cell: this.cell,
      edge: this.cell
    });
  }
  notifyMouseDown(e, t, n) {
    super.onMouseDown(e, t, n), this.notify("edge:mousedown", this.getEventArgs(e, t, n));
  }
  notifyMouseMove(e, t, n) {
    super.onMouseMove(e, t, n), this.notify("edge:mousemove", this.getEventArgs(e, t, n));
  }
  notifyMouseUp(e, t, n) {
    super.onMouseUp(e, t, n), this.notify("edge:mouseup", this.getEventArgs(e, t, n));
  }
  onClick(e, t, n) {
    super.onClick(e, t, n), this.notify("edge:click", this.getEventArgs(e, t, n));
  }
  onDblClick(e, t, n) {
    super.onDblClick(e, t, n), this.notify("edge:dblclick", this.getEventArgs(e, t, n));
  }
  onContextMenu(e, t, n) {
    super.onContextMenu(e, t, n), this.notify("edge:contextmenu", this.getEventArgs(e, t, n));
  }
  onMouseDown(e, t, n) {
    this.notifyMouseDown(e, t, n), this.startEdgeDragging(e, t, n);
  }
  onMouseMove(e, t, n) {
    const i = this.getEventData(e);
    switch (i.action) {
      case "drag-label": {
        this.dragLabel(e, t, n);
        break;
      }
      case "drag-arrowhead": {
        this.dragArrowhead(e, t, n);
        break;
      }
      case "drag-edge": {
        this.dragEdge(e, t, n);
        break;
      }
    }
    return this.notifyMouseMove(e, t, n), i;
  }
  onMouseUp(e, t, n) {
    const i = this.getEventData(e);
    switch (i.action) {
      case "drag-label": {
        this.stopLabelDragging(e, t, n);
        break;
      }
      case "drag-arrowhead": {
        this.stopArrowheadDragging(e, t, n);
        break;
      }
      case "drag-edge": {
        this.stopEdgeDragging(e, t, n);
        break;
      }
    }
    return this.notifyMouseUp(e, t, n), this.checkMouseleave(e), i;
  }
  onMouseOver(e) {
    super.onMouseOver(e), this.notify("edge:mouseover", this.getEventArgs(e));
  }
  onMouseOut(e) {
    super.onMouseOut(e), this.notify("edge:mouseout", this.getEventArgs(e));
  }
  onMouseEnter(e) {
    super.onMouseEnter(e), this.notify("edge:mouseenter", this.getEventArgs(e));
  }
  onMouseLeave(e) {
    super.onMouseLeave(e), this.notify("edge:mouseleave", this.getEventArgs(e));
  }
  onMouseWheel(e, t, n, i) {
    super.onMouseWheel(e, t, n, i), this.notify("edge:mousewheel", Object.assign({ delta: i }, this.getEventArgs(e, t, n)));
  }
  onCustomEvent(e, t, n, i) {
    if (uf(e.target, "edge-tool", this.container)) {
      if (e.stopPropagation(), this.can("useEdgeTools")) {
        if (t === "edge:remove") {
          this.cell.remove({ ui: !0 });
          return;
        }
        this.notify("edge:customevent", Object.assign({ name: t }, this.getEventArgs(e, n, i)));
      }
      this.notifyMouseDown(e, n, i);
    } else
      this.notify("edge:customevent", Object.assign({ name: t }, this.getEventArgs(e, n, i))), super.onCustomEvent(e, t, n, i);
  }
  onLabelMouseDown(e, t, n) {
    this.notifyMouseDown(e, t, n), this.startLabelDragging(e, t, n), this.getEventData(e).stopPropagation && e.stopPropagation();
  }
  // #region drag edge
  startEdgeDragging(e, t, n) {
    if (!this.can("edgeMovable")) {
      this.notifyUnhandledMouseDown(e, t, n);
      return;
    }
    this.setEventData(e, {
      x: t,
      y: n,
      moving: !1,
      action: "drag-edge"
    });
  }
  dragEdge(e, t, n) {
    const i = this.getEventData(e);
    i.moving || (i.moving = !0, this.addClass("edge-moving"), this.notify("edge:move", {
      e,
      x: t,
      y: n,
      view: this,
      cell: this.cell,
      edge: this.cell
    })), this.cell.translate(t - i.x, n - i.y, { ui: !0 }), this.setEventData(e, { x: t, y: n }), this.notify("edge:moving", {
      e,
      x: t,
      y: n,
      view: this,
      cell: this.cell,
      edge: this.cell
    });
  }
  stopEdgeDragging(e, t, n) {
    const i = this.getEventData(e);
    i.moving && (this.removeClass("edge-moving"), this.notify("edge:moved", {
      e,
      x: t,
      y: n,
      view: this,
      cell: this.cell,
      edge: this.cell
    })), i.moving = !1;
  }
  // #endregion
  // #region drag arrowhead
  prepareArrowheadDragging(e, t) {
    const n = this.getTerminalMagnet(e), i = {
      action: "drag-arrowhead",
      x: t.x,
      y: t.y,
      isNewEdge: t.isNewEdge === !0,
      terminalType: e,
      initialMagnet: n,
      initialTerminal: _a(this.cell[e]),
      fallbackAction: t.fallbackAction || "revert",
      getValidateConnectionArgs: this.createValidateConnectionArgs(e),
      options: t.options
    };
    return this.beforeArrowheadDragging(i), i;
  }
  createValidateConnectionArgs(e) {
    const t = [];
    t[4] = e, t[5] = this;
    let n, i = 0, r = 0;
    e === "source" ? (i = 2, n = "target") : (r = 2, n = "source");
    const o = this.cell[n], a = o.cell;
    if (a) {
      let l;
      const c = t[i] = this.graph.findViewByCell(a);
      c && (l = c.getMagnetFromEdgeTerminal(o), l === c.container && (l = void 0)), t[i + 1] = l;
    }
    return (l, c) => (t[r] = l, t[r + 1] = l.container === c ? void 0 : c, t);
  }
  beforeArrowheadDragging(e) {
    e.zIndex = this.cell.zIndex, this.cell.toFront();
    const t = this.container.style;
    e.pointerEvents = t.pointerEvents, t.pointerEvents = "none", this.graph.options.connecting.highlight && this.highlightAvailableMagnets(e);
  }
  afterArrowheadDragging(e) {
    e.zIndex != null && (this.cell.setZIndex(e.zIndex, { ui: !0 }), e.zIndex = null);
    const t = this.container;
    t.style.pointerEvents = e.pointerEvents || "", this.graph.options.connecting.highlight && this.unhighlightAvailableMagnets(e);
  }
  validateConnection(e, t, n, i, r, o, a) {
    const l = this.graph.options.connecting, c = l.allowLoop, u = l.allowNode, f = l.allowEdge, d = l.allowPort, g = l.allowMulti, p = l.validateConnection, m = o ? o.cell : null, w = r === "target" ? n : e, v = r === "target" ? i : t;
    let y = !0;
    const b = (x) => {
      const C = r === "source" ? a ? a.port : null : m ? m.getSourcePortId() : null, A = r === "target" ? a ? a.port : null : m ? m.getTargetPortId() : null;
      return G(x, this.graph, {
        edge: m,
        edgeView: o,
        sourceView: e,
        targetView: n,
        sourcePort: C,
        targetPort: A,
        sourceMagnet: t,
        targetMagnet: i,
        sourceCell: e ? e.cell : null,
        targetCell: n ? n.cell : null,
        type: r
      });
    };
    if (c != null && (typeof c == "boolean" ? !c && e === n && (y = !1) : y = b(c)), y && d != null && (typeof d == "boolean" ? !d && v && (y = !1) : y = b(d)), y && f != null && (typeof f == "boolean" ? !f && cn.isEdgeView(w) && (y = !1) : y = b(f)), y && u != null && v == null && (typeof u == "boolean" ? !u && It.isNodeView(w) && (y = !1) : y = b(u)), y && g != null && o) {
      const x = o.cell, C = r === "source" ? a : x.getSource(), A = r === "target" ? a : x.getTarget(), P = a ? this.graph.getCellById(a.cell) : null;
      if (C && A && C.cell && A.cell && P)
        if (typeof g == "function")
          y = b(g);
        else {
          const O = this.graph.model.getConnectedEdges(P, {
            outgoing: r === "source",
            incoming: r === "target"
          });
          O.length && (g === "withPort" ? O.some((D) => {
            const L = D.getSource(), B = D.getTarget();
            return L && B && L.cell === C.cell && B.cell === A.cell && L.port != null && L.port === C.port && B.port != null && B.port === A.port;
          }) && (y = !1) : g || O.some((D) => {
            const L = D.getSource(), B = D.getTarget();
            return L && B && L.cell === C.cell && B.cell === A.cell;
          }) && (y = !1));
        }
    }
    return y && p != null && (y = b(p)), y;
  }
  allowConnectToBlank(e) {
    const t = this.graph, i = t.options.connecting.allowBlank;
    if (typeof i != "function")
      return !!i;
    const r = t.findViewByCell(e), o = e.getSourceCell(), a = e.getTargetCell(), l = t.findViewByCell(o), c = t.findViewByCell(a);
    return G(i, t, {
      edge: e,
      edgeView: r,
      sourceCell: o,
      targetCell: a,
      sourceView: l,
      targetView: c,
      sourcePort: e.getSourcePortId(),
      targetPort: e.getTargetPortId(),
      sourceMagnet: r.sourceMagnet,
      targetMagnet: r.targetMagnet
    });
  }
  validateEdge(e, t, n) {
    const i = this.graph;
    if (!this.allowConnectToBlank(e)) {
      const o = e.getSourceCellId(), a = e.getTargetCellId();
      if (!(o && a))
        return !1;
    }
    const r = i.options.connecting.validateEdge;
    return r ? G(r, i, {
      edge: e,
      type: t,
      previous: n
    }) : !0;
  }
  arrowheadDragging(e, t, n, i) {
    i.x = t, i.y = n, i.currentTarget !== e && (i.currentMagnet && i.currentView && i.currentView.unhighlight(i.currentMagnet, {
      type: "magnetAdsorbed"
    }), i.currentView = this.graph.findViewByElem(e), i.currentView ? (i.currentMagnet = i.currentView.findMagnet(e), i.currentMagnet && this.validateConnection(...i.getValidateConnectionArgs(i.currentView, i.currentMagnet), i.currentView.getEdgeTerminal(i.currentMagnet, t, n, this.cell, i.terminalType)) ? i.currentView.highlight(i.currentMagnet, {
      type: "magnetAdsorbed"
    }) : i.currentMagnet = null) : i.currentMagnet = null), i.currentTarget = e, this.cell.prop(i.terminalType, { x: t, y: n }, Object.assign(Object.assign({}, i.options), { ui: !0 }));
  }
  arrowheadDragged(e, t, n) {
    const i = e.currentView, r = e.currentMagnet;
    if (!r || !i)
      return;
    i.unhighlight(r, { type: "magnetAdsorbed" });
    const o = e.terminalType, a = i.getEdgeTerminal(r, t, n, this.cell, o);
    this.cell.setTerminal(o, a, { ui: !0 });
  }
  snapArrowhead(e, t, n) {
    const i = this.graph, { snap: r, allowEdge: o } = i.options.connecting, a = typeof r == "object" && r.radius || 50, l = typeof r == "object" && r.anchor || "center", c = i.renderer.findViewsInArea({
      x: e - a,
      y: t - a,
      width: 2 * a,
      height: 2 * a
    }, { nodeOnly: !0 });
    if (o) {
      const x = i.renderer.findEdgeViewsFromPoint({ x: e, y: t }, a).filter((C) => C !== this);
      c.push(...x);
    }
    const u = n.closestView || null, f = n.closestMagnet || null;
    n.closestView = null, n.closestMagnet = null;
    let d, g = Number.MAX_SAFE_INTEGER;
    const p = new S(e, t);
    c.forEach((x) => {
      if (x.container.getAttribute("magnet") !== "false") {
        if (x.isNodeView())
          d = l === "center" ? x.cell.getBBox().getCenter().distance(p) : x.cell.getBBox().getNearestPointToPoint(p).distance(p);
        else if (x.isEdgeView()) {
          const C = x.getClosestPoint(p);
          C ? d = C.distance(p) : d = Number.MAX_SAFE_INTEGER;
        }
        d < a && d < g && (f === x.container || this.validateConnection(...n.getValidateConnectionArgs(x, null), x.getEdgeTerminal(x.container, e, t, this.cell, n.terminalType))) && (g = d, n.closestView = x, n.closestMagnet = x.container);
      }
      x.container.querySelectorAll("[magnet]").forEach((C) => {
        if (C.getAttribute("magnet") !== "false") {
          const A = x.getBBoxOfElement(C);
          d = p.distance(A.getCenter()), d < a && d < g && (f === C || this.validateConnection(...n.getValidateConnectionArgs(x, C), x.getEdgeTerminal(C, e, t, this.cell, n.terminalType))) && (g = d, n.closestView = x, n.closestMagnet = C);
        }
      });
    });
    let m;
    const w = n.terminalType, v = n.closestView, y = n.closestMagnet, b = f !== y;
    if (u && b && u.unhighlight(f, {
      type: "magnetAdsorbed"
    }), v) {
      if (!b)
        return;
      v.highlight(y, {
        type: "magnetAdsorbed"
      }), m = v.getEdgeTerminal(y, e, t, this.cell, w);
    } else
      m = { x: e, y: t };
    this.cell.setTerminal(w, m, {}, Object.assign(Object.assign({}, n.options), { ui: !0 }));
  }
  snapArrowheadEnd(e) {
    const t = e.closestView, n = e.closestMagnet;
    t && n && (t.unhighlight(n, {
      type: "magnetAdsorbed"
    }), e.currentMagnet = t.findMagnet(n)), e.closestView = null, e.closestMagnet = null;
  }
  finishEmbedding(e) {
    this.graph.options.embedding.enabled && this.cell.updateParent() && (e.zIndex = null);
  }
  fallbackConnection(e) {
    switch (e.fallbackAction) {
      case "remove":
        this.cell.remove({ ui: !0 });
        break;
      case "revert":
      default:
        this.cell.prop(e.terminalType, e.initialTerminal, {
          ui: !0
        });
        break;
    }
  }
  notifyConnectionEvent(e, t) {
    const n = e.terminalType, i = e.initialTerminal, r = this.cell[n];
    if (r && !Ee.equalTerminals(i, r)) {
      const a = this.graph, l = i, c = l.cell ? a.getCellById(l.cell) : null, u = l.port, f = c ? a.findViewByCell(c) : null, d = c || e.isNewEdge ? null : S.create(i).toJSON(), g = r, p = g.cell ? a.getCellById(g.cell) : null, m = g.port, w = p ? a.findViewByCell(p) : null, v = p ? null : S.create(r).toJSON();
      this.notify("edge:connected", {
        e: t,
        previousCell: c,
        previousPort: u,
        previousView: f,
        previousPoint: d,
        currentCell: p,
        currentView: w,
        currentPort: m,
        currentPoint: v,
        previousMagnet: e.initialMagnet,
        currentMagnet: e.currentMagnet,
        edge: this.cell,
        view: this,
        type: n,
        isNew: e.isNewEdge
      });
    }
  }
  highlightAvailableMagnets(e) {
    const t = this.graph, n = t.model.getCells();
    e.marked = {};
    for (let i = 0, r = n.length; i < r; i += 1) {
      const o = t.findViewByCell(n[i]);
      if (!o || o.cell.id === this.cell.id)
        continue;
      const a = Array.prototype.slice.call(o.container.querySelectorAll("[magnet]"));
      o.container.getAttribute("magnet") !== "false" && a.push(o.container);
      const l = a.filter((c) => this.validateConnection(...e.getValidateConnectionArgs(o, c), o.getEdgeTerminal(c, e.x, e.y, this.cell, e.terminalType)));
      if (l.length > 0) {
        for (let c = 0, u = l.length; c < u; c += 1)
          o.highlight(l[c], { type: "magnetAvailable" });
        o.highlight(null, { type: "nodeAvailable" }), e.marked[o.cell.id] = l;
      }
    }
  }
  unhighlightAvailableMagnets(e) {
    const t = e.marked || {};
    Object.keys(t).forEach((n) => {
      const i = this.graph.findViewByCell(n);
      i && (t[n].forEach((o) => {
        i.unhighlight(o, { type: "magnetAvailable" });
      }), i.unhighlight(null, { type: "nodeAvailable" }));
    }), e.marked = null;
  }
  startArrowheadDragging(e, t, n) {
    if (!this.can("arrowheadMovable")) {
      this.notifyUnhandledMouseDown(e, t, n);
      return;
    }
    const r = e.target.getAttribute("data-terminal"), o = this.prepareArrowheadDragging(r, { x: t, y: n });
    this.setEventData(e, o);
  }
  dragArrowhead(e, t, n) {
    const i = this.getEventData(e);
    this.graph.options.connecting.snap ? this.snapArrowhead(t, n, i) : this.arrowheadDragging(this.getEventTarget(e), t, n, i);
  }
  stopArrowheadDragging(e, t, n) {
    const i = this.graph, r = this.getEventData(e);
    i.options.connecting.snap ? this.snapArrowheadEnd(r) : this.arrowheadDragged(r, t, n), this.validateEdge(this.cell, r.terminalType, r.initialTerminal) ? (this.finishEmbedding(r), this.notifyConnectionEvent(r, e)) : this.fallbackConnection(r), this.afterArrowheadDragging(r);
  }
  // #endregion
  // #region drag lable
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  startLabelDragging(e, t, n) {
    if (this.can("edgeLabelMovable")) {
      const i = e.currentTarget, r = parseInt(i.getAttribute("data-index"), 10), o = this.getLabelPositionAngle(r), a = this.getLabelPositionArgs(r), l = this.getDefaultLabelPositionArgs(), c = this.mergeLabelPositionArgs(a, l);
      this.setEventData(e, {
        index: r,
        positionAngle: o,
        positionArgs: c,
        stopPropagation: !0,
        action: "drag-label"
      });
    } else
      this.setEventData(e, { stopPropagation: !0 });
    this.graph.view.delegateDragEvents(e, this);
  }
  dragLabel(e, t, n) {
    const i = this.getEventData(e), r = this.cell.getLabelAt(i.index), o = Te({}, r, {
      position: this.getLabelPosition(t, n, i.positionAngle, i.positionArgs)
    });
    this.cell.setLabelAt(i.index, o);
  }
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  stopLabelDragging(e, t, n) {
  }
}
(function(s) {
  s.toStringTag = "X6.".concat(s.name);
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof s)
      return !0;
    const n = t[Symbol.toStringTag], i = t;
    return (n == null || n === s.toStringTag) && typeof i.isNodeView == "function" && typeof i.isEdgeView == "function" && typeof i.confirmUpdate == "function" && typeof i.update == "function" && typeof i.getConnection == "function";
  }
  s.isEdgeView = e;
})(cn || (cn = {}));
cn.config({
  isSvgElement: !0,
  priority: 1,
  bootstrap: ["render", "source", "target"],
  actions: {
    view: ["render"],
    markup: ["render"],
    attrs: ["update"],
    source: ["source", "update"],
    target: ["target", "update"],
    router: ["update"],
    connector: ["update"],
    labels: ["labels"],
    defaultLabel: ["labels"],
    tools: ["tools"],
    vertices: ["vertices", "update"]
  }
});
cn.registry.register("edge", cn, !0);
var k3 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class qt extends pe {
  /** Graph's `this.container` is from outer, should not dispose */
  get disposeContainer() {
    return !1;
  }
  get options() {
    return this.graph.options;
  }
  constructor(e) {
    super(), this.graph = e;
    const { selectors: t, fragment: n } = ge.parseJSONMarkup(qt.markup);
    this.background = t.background, this.grid = t.grid, this.svg = t.svg, this.defs = t.defs, this.viewport = t.viewport, this.primer = t.primer, this.stage = t.stage, this.decorator = t.decorator, this.overlay = t.overlay, this.container = this.options.container, this.restore = qt.snapshoot(this.container), se(this.container, this.prefixClassName("graph")), mr(this.container, n), this.delegateEvents();
  }
  delegateEvents() {
    const e = this.constructor;
    return super.delegateEvents(e.events), this;
  }
  /**
   * Guard the specified event. If the event is not interesting, it
   * returns `true`, otherwise returns `false`.
   */
  guard(e, t) {
    return e.type === "mousedown" && e.button === 2 || this.options.guard && this.options.guard(e, t) ? !0 : e.data && e.data.guarded !== void 0 ? e.data.guarded : !(t && t.cell && te.isCell(t.cell) || this.svg === e.target || this.container === e.target || this.svg.contains(e.target));
  }
  findView(e) {
    return this.graph.findViewByElem(e);
  }
  onDblClick(e) {
    this.options.preventDefaultDblClick && e.preventDefault();
    const t = this.normalizeEvent(e), n = this.findView(t.target);
    if (this.guard(t, n))
      return;
    const i = this.graph.snapToGrid(t.clientX, t.clientY);
    n ? n.onDblClick(t, i.x, i.y) : this.graph.trigger("blank:dblclick", {
      e: t,
      x: i.x,
      y: i.y
    });
  }
  onClick(e) {
    if (this.getMouseMovedCount(e) <= this.options.clickThreshold) {
      const t = this.normalizeEvent(e), n = this.findView(t.target);
      if (this.guard(t, n))
        return;
      const i = this.graph.snapToGrid(t.clientX, t.clientY);
      n ? n.onClick(t, i.x, i.y) : this.graph.trigger("blank:click", {
        e: t,
        x: i.x,
        y: i.y
      });
    }
  }
  isPreventDefaultContextMenu(e) {
    let t = this.options.preventDefaultContextMenu;
    return typeof t == "function" && (t = G(t, this.graph, { view: e })), t;
  }
  onContextMenu(e) {
    const t = this.normalizeEvent(e), n = this.findView(t.target);
    if (this.isPreventDefaultContextMenu(n) && e.preventDefault(), this.guard(t, n))
      return;
    const i = this.graph.snapToGrid(t.clientX, t.clientY);
    n ? n.onContextMenu(t, i.x, i.y) : this.graph.trigger("blank:contextmenu", {
      e: t,
      x: i.x,
      y: i.y
    });
  }
  delegateDragEvents(e, t) {
    e.data == null && (e.data = {}), this.setEventData(e, {
      currentView: t || null,
      mouseMovedCount: 0,
      startPosition: {
        x: e.clientX,
        y: e.clientY
      }
    });
    const n = this.constructor;
    this.delegateDocumentEvents(n.documentEvents, e.data), this.undelegateEvents();
  }
  getMouseMovedCount(e) {
    return this.getEventData(e).mouseMovedCount || 0;
  }
  onMouseDown(e) {
    const t = this.normalizeEvent(e), n = this.findView(t.target);
    if (this.guard(t, n))
      return;
    this.options.preventDefaultMouseDown && e.preventDefault();
    const i = this.graph.snapToGrid(t.clientX, t.clientY);
    n ? n.onMouseDown(t, i.x, i.y) : (this.options.preventDefaultBlankAction && ["touchstart"].includes(t.type) && e.preventDefault(), this.graph.trigger("blank:mousedown", {
      e: t,
      x: i.x,
      y: i.y
    })), this.delegateDragEvents(t, n);
  }
  onMouseMove(e) {
    const t = this.getEventData(e), n = t.startPosition;
    if (n && n.x === e.clientX && n.y === e.clientY || (t.mouseMovedCount == null && (t.mouseMovedCount = 0), t.mouseMovedCount += 1, t.mouseMovedCount <= this.options.moveThreshold))
      return;
    const r = this.normalizeEvent(e), o = this.graph.snapToGrid(r.clientX, r.clientY), a = t.currentView;
    a ? a.onMouseMove(r, o.x, o.y) : this.graph.trigger("blank:mousemove", {
      e: r,
      x: o.x,
      y: o.y
    }), this.setEventData(r, t);
  }
  onMouseUp(e) {
    this.undelegateDocumentEvents();
    const t = this.normalizeEvent(e), n = this.graph.snapToGrid(t.clientX, t.clientY), r = this.getEventData(e).currentView;
    if (r ? r.onMouseUp(t, n.x, n.y) : this.graph.trigger("blank:mouseup", {
      e: t,
      x: n.x,
      y: n.y
    }), !e.isPropagationStopped()) {
      const o = new zt(e, {
        type: "click",
        data: e.data
      });
      this.onClick(o);
    }
    e.stopImmediatePropagation(), this.delegateEvents();
  }
  onMouseOver(e) {
    const t = this.normalizeEvent(e), n = this.findView(t.target);
    if (!this.guard(t, n))
      if (n)
        n.onMouseOver(t);
      else {
        if (this.container === t.target)
          return;
        this.graph.trigger("blank:mouseover", { e: t });
      }
  }
  onMouseOut(e) {
    const t = this.normalizeEvent(e), n = this.findView(t.target);
    if (!this.guard(t, n))
      if (n)
        n.onMouseOut(t);
      else {
        if (this.container === t.target)
          return;
        this.graph.trigger("blank:mouseout", { e: t });
      }
  }
  onMouseEnter(e) {
    const t = this.normalizeEvent(e), n = this.findView(t.target);
    if (this.guard(t, n))
      return;
    const i = this.graph.findViewByElem(t.relatedTarget);
    if (n) {
      if (i === n)
        return;
      n.onMouseEnter(t);
    } else {
      if (i)
        return;
      this.graph.trigger("graph:mouseenter", { e: t });
    }
  }
  onMouseLeave(e) {
    const t = this.normalizeEvent(e), n = this.findView(t.target);
    if (this.guard(t, n))
      return;
    const i = this.graph.findViewByElem(t.relatedTarget);
    if (n) {
      if (i === n)
        return;
      n.onMouseLeave(t);
    } else {
      if (i)
        return;
      this.graph.trigger("graph:mouseleave", { e: t });
    }
  }
  onMouseWheel(e) {
    const t = this.normalizeEvent(e), n = this.findView(t.target);
    if (this.guard(t, n))
      return;
    const i = t.originalEvent, r = this.graph.snapToGrid(i.clientX, i.clientY), o = Math.max(-1, Math.min(1, i.wheelDelta || -i.detail));
    n ? n.onMouseWheel(t, r.x, r.y, o) : this.graph.trigger("blank:mousewheel", {
      e: t,
      delta: o,
      x: r.x,
      y: r.y
    });
  }
  onCustomEvent(e) {
    const t = e.currentTarget, n = t.getAttribute("event") || t.getAttribute("data-event");
    if (n) {
      const i = this.findView(t);
      if (i) {
        const r = this.normalizeEvent(e);
        if (this.guard(r, i))
          return;
        const o = this.graph.snapToGrid(r.clientX, r.clientY);
        i.onCustomEvent(r, n, o.x, o.y);
      }
    }
  }
  handleMagnetEvent(e, t) {
    const n = e.currentTarget, i = n.getAttribute("magnet");
    if (i && i.toLowerCase() !== "false") {
      const r = this.findView(n);
      if (r) {
        const o = this.normalizeEvent(e);
        if (this.guard(o, r))
          return;
        const a = this.graph.snapToGrid(o.clientX, o.clientY);
        G(t, this.graph, r, o, n, a.x, a.y);
      }
    }
  }
  onMagnetMouseDown(e) {
    this.handleMagnetEvent(e, (t, n, i, r, o) => {
      t.onMagnetMouseDown(n, i, r, o);
    });
  }
  onMagnetDblClick(e) {
    this.handleMagnetEvent(e, (t, n, i, r, o) => {
      t.onMagnetDblClick(n, i, r, o);
    });
  }
  onMagnetContextMenu(e) {
    const t = this.findView(e.target);
    this.isPreventDefaultContextMenu(t) && e.preventDefault(), this.handleMagnetEvent(e, (n, i, r, o, a) => {
      n.onMagnetContextMenu(i, r, o, a);
    });
  }
  onLabelMouseDown(e) {
    const t = e.currentTarget, n = this.findView(t);
    if (n) {
      const i = this.normalizeEvent(e);
      if (this.guard(i, n))
        return;
      const r = this.graph.snapToGrid(i.clientX, i.clientY);
      n.onLabelMouseDown(i, r.x, r.y);
    }
  }
  onImageDragStart() {
    return !1;
  }
  dispose() {
    this.undelegateEvents(), this.undelegateDocumentEvents(), this.restore(), this.restore = () => {
    };
  }
}
k3([
  pe.dispose()
], qt.prototype, "dispose", null);
(function(s) {
  const e = "".concat(Nt.prefixCls, "-graph");
  s.markup = [
    {
      ns: Fe.xhtml,
      tagName: "div",
      selector: "background",
      className: "".concat(e, "-background")
    },
    {
      ns: Fe.xhtml,
      tagName: "div",
      selector: "grid",
      className: "".concat(e, "-grid")
    },
    {
      ns: Fe.svg,
      tagName: "svg",
      selector: "svg",
      className: "".concat(e, "-svg"),
      attrs: {
        width: "100%",
        height: "100%",
        "xmlns:xlink": Fe.xlink
      },
      children: [
        {
          tagName: "defs",
          selector: "defs"
        },
        {
          tagName: "g",
          selector: "viewport",
          className: "".concat(e, "-svg-viewport"),
          children: [
            {
              tagName: "g",
              selector: "primer",
              className: "".concat(e, "-svg-primer")
            },
            {
              tagName: "g",
              selector: "stage",
              className: "".concat(e, "-svg-stage")
            },
            {
              tagName: "g",
              selector: "decorator",
              className: "".concat(e, "-svg-decorator")
            },
            {
              tagName: "g",
              selector: "overlay",
              className: "".concat(e, "-svg-overlay")
            }
          ]
        }
      ]
    }
  ];
  function t(n) {
    const i = n.cloneNode();
    return n.childNodes.forEach((r) => i.appendChild(r)), () => {
      for (pr(n); n.attributes.length > 0; )
        n.removeAttribute(n.attributes[0].name);
      for (let r = 0, o = i.attributes.length; r < o; r += 1) {
        const a = i.attributes[r];
        n.setAttribute(a.name, a.value);
      }
      i.childNodes.forEach((r) => n.appendChild(r));
    };
  }
  s.snapshoot = t;
})(qt || (qt = {}));
(function(s) {
  const e = Nt.prefixCls;
  s.events = {
    dblclick: "onDblClick",
    contextmenu: "onContextMenu",
    touchstart: "onMouseDown",
    mousedown: "onMouseDown",
    mouseover: "onMouseOver",
    mouseout: "onMouseOut",
    mouseenter: "onMouseEnter",
    mouseleave: "onMouseLeave",
    mousewheel: "onMouseWheel",
    DOMMouseScroll: "onMouseWheel",
    ["mouseenter  .".concat(e, "-cell")]: "onMouseEnter",
    ["mouseleave  .".concat(e, "-cell")]: "onMouseLeave",
    ["mouseenter  .".concat(e, "-cell-tools")]: "onMouseEnter",
    ["mouseleave  .".concat(e, "-cell-tools")]: "onMouseLeave",
    ["mousedown   .".concat(e, "-cell [event]")]: "onCustomEvent",
    ["touchstart  .".concat(e, "-cell [event]")]: "onCustomEvent",
    ["mousedown   .".concat(e, "-cell [data-event]")]: "onCustomEvent",
    ["touchstart  .".concat(e, "-cell [data-event]")]: "onCustomEvent",
    ["dblclick    .".concat(e, "-cell [magnet]")]: "onMagnetDblClick",
    ["contextmenu .".concat(e, "-cell [magnet]")]: "onMagnetContextMenu",
    ["mousedown   .".concat(e, "-cell [magnet]")]: "onMagnetMouseDown",
    ["touchstart  .".concat(e, "-cell [magnet]")]: "onMagnetMouseDown",
    ["dblclick    .".concat(e, "-cell [data-magnet]")]: "onMagnetDblClick",
    ["contextmenu .".concat(e, "-cell [data-magnet]")]: "onMagnetContextMenu",
    ["mousedown   .".concat(e, "-cell [data-magnet]")]: "onMagnetMouseDown",
    ["touchstart  .".concat(e, "-cell [data-magnet]")]: "onMagnetMouseDown",
    ["dragstart   .".concat(e, "-cell image")]: "onImageDragStart",
    ["mousedown   .".concat(e, "-edge .").concat(e, "-edge-label")]: "onLabelMouseDown",
    ["touchstart  .".concat(e, "-edge .").concat(e, "-edge-label")]: "onLabelMouseDown"
  }, s.documentEvents = {
    mousemove: "onMouseMove",
    touchmove: "onMouseMove",
    mouseup: "onMouseUp",
    touchend: "onMouseUp",
    touchcancel: "onMouseUp"
  };
})(qt || (qt = {}));
const P3 = ".x6-graph {\n  position: relative;\n  overflow: hidden;\n  outline: none;\n  touch-action: none;\n}\n.x6-graph-background,\n.x6-graph-grid,\n.x6-graph-svg {\n  position: absolute;\n  top: 0;\n  right: 0;\n  bottom: 0;\n  left: 0;\n}\n.x6-graph-background-stage,\n.x6-graph-grid-stage,\n.x6-graph-svg-stage {\n  user-select: none;\n}\n.x6-graph.x6-graph-pannable {\n  cursor: grab;\n  cursor: -moz-grab;\n  cursor: -webkit-grab;\n}\n.x6-graph.x6-graph-panning {\n  cursor: grabbing;\n  cursor: -moz-grabbing;\n  cursor: -webkit-grabbing;\n  user-select: none;\n}\n.x6-node {\n  cursor: move;\n  /* stylelint-disable-next-line */\n}\n.x6-node.x6-node-immovable {\n  cursor: default;\n}\n.x6-node * {\n  -webkit-user-drag: none;\n}\n.x6-node .scalable * {\n  vector-effect: non-scaling-stroke;\n}\n.x6-node [magnet='true'] {\n  cursor: crosshair;\n  transition: opacity 0.3s;\n}\n.x6-node [magnet='true']:hover {\n  opacity: 0.7;\n}\n.x6-node foreignObject {\n  display: block;\n  overflow: visible;\n  background-color: transparent;\n}\n.x6-node foreignObject > body {\n  position: static;\n  width: 100%;\n  height: 100%;\n  margin: 0;\n  padding: 0;\n  overflow: visible;\n  background-color: transparent;\n}\n.x6-edge .source-marker,\n.x6-edge .target-marker {\n  vector-effect: non-scaling-stroke;\n}\n.x6-edge .connection {\n  stroke-linejoin: round;\n  fill: none;\n}\n.x6-edge .connection-wrap {\n  cursor: move;\n  opacity: 0;\n  fill: none;\n  stroke: #000;\n  stroke-width: 15;\n  stroke-linecap: round;\n  stroke-linejoin: round;\n}\n.x6-edge .connection-wrap:hover {\n  opacity: 0.4;\n  stroke-opacity: 0.4;\n}\n.x6-edge .vertices {\n  cursor: move;\n  opacity: 0;\n}\n.x6-edge .vertices .vertex {\n  fill: #1abc9c;\n}\n.x6-edge .vertices .vertex :hover {\n  fill: #34495e;\n  stroke: none;\n}\n.x6-edge .vertices .vertex-remove {\n  cursor: pointer;\n  fill: #fff;\n}\n.x6-edge .vertices .vertex-remove-area {\n  cursor: pointer;\n  opacity: 0.1;\n}\n.x6-edge .vertices .vertex-group:hover .vertex-remove-area {\n  opacity: 1;\n}\n.x6-edge .arrowheads {\n  cursor: move;\n  opacity: 0;\n}\n.x6-edge .arrowheads .arrowhead {\n  fill: #1abc9c;\n}\n.x6-edge .arrowheads .arrowhead :hover {\n  fill: #f39c12;\n  stroke: none;\n}\n.x6-edge .tools {\n  cursor: pointer;\n  opacity: 0;\n}\n.x6-edge .tools .tool-options {\n  display: none;\n}\n.x6-edge .tools .tool-remove circle {\n  fill: #f00;\n}\n.x6-edge .tools .tool-remove path {\n  fill: #fff;\n}\n.x6-edge:hover .vertices,\n.x6-edge:hover .arrowheads,\n.x6-edge:hover .tools {\n  opacity: 1;\n}\n.x6-highlight-opacity {\n  opacity: 0.3;\n}\n.x6-cell-tool-editor {\n  position: relative;\n  display: inline-block;\n  min-height: 1em;\n  margin: 0;\n  padding: 0;\n  line-height: 1;\n  white-space: normal;\n  text-align: center;\n  vertical-align: top;\n  overflow-wrap: normal;\n  outline: none;\n  transform-origin: 0 0;\n  -webkit-user-drag: none;\n}\n.x6-edge-tool-editor {\n  border: 1px solid #275fc5;\n  border-radius: 2px;\n}\n";
class He extends an {
  get options() {
    return this.graph.options;
  }
  get model() {
    return this.graph.model;
  }
  get view() {
    return this.graph.view;
  }
  constructor(e) {
    super(), this.graph = e, this.init();
  }
  init() {
  }
}
var _3 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class ll extends He {
  init() {
    Rb("core", P3);
  }
  dispose() {
    Bb("core");
  }
}
_3([
  ll.dispose()
], ll.prototype, "dispose", null);
var O3 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
}, rr;
(function(s) {
  function e(t) {
    const { grid: n, panning: i, mousewheel: r, embedding: o } = t, a = O3(
      t,
      ["grid", "panning", "mousewheel", "embedding"]
    ), l = t.container;
    if (l != null)
      a.width == null && (a.width = l.clientWidth), a.height == null && (a.height = l.clientHeight);
    else
      throw new Error("Ensure the container of the graph is specified and valid");
    const c = Te({}, s.defaults, a), u = { size: 10, visible: !1 };
    return typeof n == "number" ? c.grid = { size: n, visible: !1 } : typeof n == "boolean" ? c.grid = Object.assign(Object.assign({}, u), { visible: n }) : c.grid = Object.assign(Object.assign({}, u), n), [
      "panning",
      "mousewheel",
      "embedding"
    ].forEach((d) => {
      const g = t[d];
      typeof g == "boolean" ? c[d].enabled = g : c[d] = Object.assign(Object.assign({}, c[d]), g);
    }), c;
  }
  s.get = e;
})(rr || (rr = {}));
(function(s) {
  s.defaults = {
    x: 0,
    y: 0,
    scaling: {
      min: 0.01,
      max: 16
    },
    grid: {
      size: 10,
      visible: !1
    },
    background: !1,
    panning: {
      enabled: !1,
      eventTypes: ["leftMouseDown"]
    },
    mousewheel: {
      enabled: !1,
      factor: 1.2,
      zoomAtMousePosition: !0
    },
    highlighting: {
      default: {
        name: "stroke",
        args: {
          padding: 3
        }
      },
      nodeAvailable: {
        name: "className",
        args: {
          className: Nt.prefix("available-node")
        }
      },
      magnetAvailable: {
        name: "className",
        args: {
          className: Nt.prefix("available-magnet")
        }
      }
    },
    connecting: {
      snap: !1,
      allowLoop: !0,
      allowNode: !0,
      allowEdge: !1,
      allowPort: !0,
      allowBlank: !0,
      allowMulti: !0,
      highlight: !1,
      anchor: "center",
      edgeAnchor: "ratio",
      connectionPoint: "boundary",
      router: "normal",
      connector: "normal",
      validateConnection({ type: e, sourceView: t, targetView: n }) {
        return (e === "target" ? n : t) != null;
      },
      createEdge() {
        return new C3();
      }
    },
    translating: {
      restrict: !1
    },
    embedding: {
      enabled: !1,
      findParent: "bbox",
      frontOnly: !0,
      validate: () => !0
    },
    moveThreshold: 0,
    clickThreshold: 0,
    magnetThreshold: 0,
    preventDefaultDblClick: !0,
    preventDefaultMouseDown: !1,
    preventDefaultContextMenu: !0,
    preventDefaultBlankAction: !0,
    interacting: {
      edgeLabelMovable: !1
    },
    async: !0,
    virtual: !1,
    guard: () => !1
  };
})(rr || (rr = {}));
var T3 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
}, L3 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
class sc extends He {
  get elem() {
    return this.view.grid;
  }
  get grid() {
    return this.options.grid;
  }
  init() {
    this.startListening(), this.draw(this.grid);
  }
  startListening() {
    this.graph.on("scale", this.update, this), this.graph.on("translate", this.update, this);
  }
  stopListening() {
    this.graph.off("scale", this.update, this), this.graph.off("translate", this.update, this);
  }
  setVisible(e) {
    this.grid.visible !== e && (this.grid.visible = e, this.update());
  }
  getGridSize() {
    return this.grid.size;
  }
  setGridSize(e) {
    this.grid.size = Math.max(e, 1), this.update();
  }
  show() {
    this.setVisible(!0), this.update();
  }
  hide() {
    this.setVisible(!1), this.update();
  }
  clear() {
    this.elem.style.backgroundImage = "";
  }
  draw(e) {
    this.clear(), this.instance = null, Object.assign(this.grid, e), this.patterns = this.resolveGrid(e), this.update();
  }
  update(e = {}) {
    const t = this.grid.size;
    if (t <= 1 || !this.grid.visible)
      return this.clear();
    const n = this.graph.matrix(), i = this.getInstance(), r = Array.isArray(e) ? e : [e];
    this.patterns.forEach((l, c) => {
      const u = "pattern_".concat(c), f = n.a || 1, d = n.d || 1, { update: g, markup: p } = l, m = L3(l, ["update", "markup"]), w = Object.assign(Object.assign(Object.assign({}, m), r[c]), {
        sx: f,
        sy: d,
        ox: n.e || 0,
        oy: n.f || 0,
        width: t * f,
        height: t * d
      });
      i.has(u) || i.add(u, U.create("pattern", { id: u, patternUnits: "userSpaceOnUse" }, U.createVectors(p)).node);
      const v = i.get(u);
      typeof g == "function" && g(v.childNodes[0], w);
      let y = w.ox % w.width;
      y < 0 && (y += w.width);
      let b = w.oy % w.height;
      b < 0 && (b += w.height), ue(v, {
        x: y,
        y: b,
        width: w.width,
        height: w.height
      });
    });
    const o = new XMLSerializer().serializeToString(i.root), a = "url(data:image/svg+xml;base64,".concat(btoa(o), ")");
    this.elem.style.backgroundImage = a;
  }
  getInstance() {
    return this.instance || (this.instance = new Sn()), this.instance;
  }
  resolveGrid(e) {
    if (!e)
      return [];
    const t = e.type;
    if (t == null)
      return [
        Object.assign(Object.assign({}, Sn.presets.dot), e.args)
      ];
    const n = Sn.registry.get(t);
    if (n) {
      let i = e.args || [];
      return Array.isArray(i) || (i = [i]), Array.isArray(n) ? n.map((r, o) => Object.assign(Object.assign({}, r), i[o])) : [Object.assign(Object.assign({}, n), i[0])];
    }
    return Sn.registry.onNotFound(t);
  }
  dispose() {
    this.stopListening(), this.clear();
  }
}
T3([
  He.dispose()
], sc.prototype, "dispose", null);
class xg extends He {
  get container() {
    return this.graph.view.container;
  }
  get viewport() {
    return this.graph.view.viewport;
  }
  get stage() {
    return this.graph.view.stage;
  }
  init() {
    this.resize();
  }
  /**
   * Returns the current transformation matrix of the graph.
   */
  getMatrix() {
    const e = this.viewport.getAttribute("transform");
    return e !== this.viewportTransformString && (this.viewportMatrix = this.viewport.getCTM(), this.viewportTransformString = e), Ve(this.viewportMatrix);
  }
  /**
   * Sets new transformation with the given `matrix`
   */
  setMatrix(e) {
    const t = Ve(e), n = pi(t);
    this.viewport.setAttribute("transform", n), this.viewportMatrix = t, this.viewportTransformString = n;
  }
  resize(e, t) {
    let n = e === void 0 ? this.options.width : e, i = t === void 0 ? this.options.height : t;
    this.options.width = n, this.options.height = i, typeof n == "number" && (n = Math.round(n)), typeof i == "number" && (i = Math.round(i)), this.container.style.width = n == null ? "" : "".concat(n, "px"), this.container.style.height = i == null ? "" : "".concat(i, "px");
    const r = this.getComputedSize();
    return this.graph.trigger("resize", Object.assign({}, r)), this;
  }
  getComputedSize() {
    let e = this.options.width, t = this.options.height;
    return wc(e) || (e = this.container.clientWidth), wc(t) || (t = this.container.clientHeight), { width: e, height: t };
  }
  getScale() {
    return Pb(this.getMatrix());
  }
  scale(e, t = e, n = 0, i = 0) {
    if (e = this.clampScale(e), t = this.clampScale(t), n || i) {
      const o = this.getTranslation(), a = o.tx - n * (e - 1), l = o.ty - i * (t - 1);
      (a !== o.tx || l !== o.ty) && this.translate(a, l);
    }
    const r = this.getMatrix();
    return r.a = e, r.d = t, this.setMatrix(r), this.graph.trigger("scale", { sx: e, sy: t, ox: n, oy: i }), this;
  }
  clampScale(e) {
    const t = this.graph.options.scaling;
    return Ct(e, t.min || 0.01, t.max || 16);
  }
  getZoom() {
    return this.getScale().sx;
  }
  zoom(e, t) {
    t = t || {};
    let n = e, i = e;
    const r = this.getScale(), o = this.getComputedSize();
    let a = o.width / 2, l = o.height / 2;
    if (t.absolute || (n += r.sx, i += r.sy), t.scaleGrid && (n = Math.round(n / t.scaleGrid) * t.scaleGrid, i = Math.round(i / t.scaleGrid) * t.scaleGrid), t.maxScale && (n = Math.min(t.maxScale, n), i = Math.min(t.maxScale, i)), t.minScale && (n = Math.max(t.minScale, n), i = Math.max(t.minScale, i)), t.center && (a = t.center.x, l = t.center.y), n = this.clampScale(n), i = this.clampScale(i), a || l) {
      const c = this.getTranslation(), u = a - (a - c.tx) * (n / r.sx), f = l - (l - c.ty) * (i / r.sy);
      (u !== c.tx || f !== c.ty) && this.translate(u, f);
    }
    return this.scale(n, i), this;
  }
  getRotation() {
    return _b(this.getMatrix());
  }
  rotate(e, t, n) {
    if (t == null || n == null) {
      const r = re.getBBox(this.stage);
      t = r.width / 2, n = r.height / 2;
    }
    const i = this.getMatrix().translate(t, n).rotate(e).translate(-t, -n);
    return this.setMatrix(i), this;
  }
  getTranslation() {
    return Ob(this.getMatrix());
  }
  translate(e, t) {
    const n = this.getMatrix();
    n.e = e || 0, n.f = t || 0, this.setMatrix(n);
    const i = this.getTranslation();
    return this.options.x = i.tx, this.options.y = i.ty, this.graph.trigger("translate", Object.assign({}, i)), this;
  }
  setOrigin(e, t) {
    return this.translate(e || 0, t || 0);
  }
  fitToContent(e, t, n, i) {
    if (typeof e == "object") {
      const b = e;
      e = b.gridWidth || 1, t = b.gridHeight || 1, n = b.padding || 0, i = b;
    } else
      e = e || 1, t = t || 1, n = n || 0, i == null && (i = {});
    const r = us(n), o = i.border || 0, a = i.contentArea ? R.create(i.contentArea) : this.getContentArea(i);
    o > 0 && a.inflate(o);
    const l = this.getScale(), c = this.getTranslation(), u = l.sx, f = l.sy;
    a.x *= u, a.y *= f, a.width *= u, a.height *= f;
    let d = Math.max(Math.ceil((a.width + a.x) / e), 1) * e, g = Math.max(Math.ceil((a.height + a.y) / t), 1) * t, p = 0, m = 0;
    (i.allowNewOrigin === "negative" && a.x < 0 || i.allowNewOrigin === "positive" && a.x >= 0 || i.allowNewOrigin === "any") && (p = Math.ceil(-a.x / e) * e, p += r.left, d += p), (i.allowNewOrigin === "negative" && a.y < 0 || i.allowNewOrigin === "positive" && a.y >= 0 || i.allowNewOrigin === "any") && (m = Math.ceil(-a.y / t) * t, m += r.top, g += m), d += r.right, g += r.bottom, d = Math.max(d, i.minWidth || 0), g = Math.max(g, i.minHeight || 0), d = Math.min(d, i.maxWidth || Number.MAX_SAFE_INTEGER), g = Math.min(g, i.maxHeight || Number.MAX_SAFE_INTEGER);
    const w = this.getComputedSize(), v = d !== w.width || g !== w.height;
    return (p !== c.tx || m !== c.ty) && this.translate(p, m), v && this.resize(d, g), new R(-p / u, -m / f, d / u, g / f);
  }
  scaleContentToFit(e = {}) {
    this.scaleContentToFitImpl(e);
  }
  scaleContentToFitImpl(e = {}, t = !0) {
    let n, i;
    if (e.contentArea) {
      const v = e.contentArea;
      n = this.graph.localToGraph(v), i = S.create(v);
    } else
      n = this.getContentBBox(e), i = this.graph.graphToLocal(n);
    if (!n.width || !n.height)
      return;
    const r = us(e.padding), o = e.minScale || 0, a = e.maxScale || Number.MAX_SAFE_INTEGER, l = e.minScaleX || o, c = e.maxScaleX || a, u = e.minScaleY || o, f = e.maxScaleY || a;
    let d;
    if (e.viewportArea)
      d = e.viewportArea;
    else {
      const v = this.getComputedSize(), y = this.getTranslation();
      d = {
        x: y.tx,
        y: y.ty,
        width: v.width,
        height: v.height
      };
    }
    d = R.create(d).moveAndExpand({
      x: r.left,
      y: r.top,
      width: -r.left - r.right,
      height: -r.top - r.bottom
    });
    const g = this.getScale();
    let p = d.width / n.width * g.sx, m = d.height / n.height * g.sy;
    e.preserveAspectRatio !== !1 && (p = m = Math.min(p, m));
    const w = e.scaleGrid;
    if (w && (p = w * Math.floor(p / w), m = w * Math.floor(m / w)), p = Ct(p, l, c), m = Ct(m, u, f), this.scale(p, m), t) {
      const v = this.options, y = d.x - i.x * p - v.x, b = d.y - i.y * m - v.y;
      this.translate(y, b);
    }
  }
  getContentArea(e = {}) {
    return e.useCellGeometry !== !1 ? this.model.getAllCellsBBox() || new R() : re.getBBox(this.stage);
  }
  getContentBBox(e = {}) {
    return this.graph.localToGraph(this.getContentArea(e));
  }
  getGraphArea() {
    const e = R.fromSize(this.getComputedSize());
    return this.graph.graphToLocal(e);
  }
  zoomToRect(e, t = {}) {
    const n = R.create(e), i = this.graph;
    t.contentArea = n, t.viewportArea == null && (t.viewportArea = {
      x: i.options.x,
      y: i.options.y,
      width: this.options.width,
      height: this.options.height
    }), this.scaleContentToFitImpl(t, !1);
    const r = n.getCenter();
    return this.centerPoint(r.x, r.y), this;
  }
  zoomToFit(e = {}) {
    return this.zoomToRect(this.getContentArea(e), e);
  }
  centerPoint(e, t) {
    const n = this.getComputedSize(), i = this.getScale(), r = this.getTranslation(), o = n.width / 2, a = n.height / 2;
    e = typeof e == "number" ? e : o, t = typeof t == "number" ? t : a, e = o - e * i.sx, t = a - t * i.sy, (r.tx !== e || r.ty !== t) && this.translate(e, t);
  }
  centerContent(e) {
    const n = this.graph.getContentArea(e).getCenter();
    this.centerPoint(n.x, n.y);
  }
  centerCell(e) {
    return this.positionCell(e, "center");
  }
  positionPoint(e, t, n) {
    const i = this.getComputedSize();
    t = Ot(t, Math.max(0, i.width)), t < 0 && (t = i.width + t), n = Ot(n, Math.max(0, i.height)), n < 0 && (n = i.height + n);
    const r = this.getTranslation(), o = this.getScale(), a = t - e.x * o.sx, l = n - e.y * o.sy;
    (r.tx !== a || r.ty !== l) && this.translate(a, l);
  }
  positionRect(e, t) {
    const n = R.create(e);
    switch (t) {
      case "center":
        return this.positionPoint(n.getCenter(), "50%", "50%");
      case "top":
        return this.positionPoint(n.getTopCenter(), "50%", 0);
      case "top-right":
        return this.positionPoint(n.getTopRight(), "100%", 0);
      case "right":
        return this.positionPoint(n.getRightMiddle(), "100%", "50%");
      case "bottom-right":
        return this.positionPoint(n.getBottomRight(), "100%", "100%");
      case "bottom":
        return this.positionPoint(n.getBottomCenter(), "50%", "100%");
      case "bottom-left":
        return this.positionPoint(n.getBottomLeft(), 0, "100%");
      case "left":
        return this.positionPoint(n.getLeftMiddle(), 0, "50%");
      case "top-left":
        return this.positionPoint(n.getTopLeft(), 0, 0);
      default:
        return this;
    }
  }
  positionCell(e, t) {
    const n = e.getBBox();
    return this.positionRect(n, t);
  }
  positionContent(e, t) {
    const n = this.graph.getContentArea(t);
    return this.positionRect(n, e);
  }
}
var D3 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class ic extends He {
  get elem() {
    return this.view.background;
  }
  init() {
    this.startListening(), this.options.background && this.draw(this.options.background);
  }
  startListening() {
    this.graph.on("scale", this.update, this), this.graph.on("translate", this.update, this);
  }
  stopListening() {
    this.graph.off("scale", this.update, this), this.graph.off("translate", this.update, this);
  }
  updateBackgroundImage(e = {}) {
    let t = e.size || "auto auto", n = e.position || "center";
    const i = this.graph.transform.getScale(), r = this.graph.translate();
    if (typeof n == "object") {
      const o = r.tx + i.sx * (n.x || 0), a = r.ty + i.sy * (n.y || 0);
      n = "".concat(o, "px ").concat(a, "px");
    }
    typeof t == "object" && (t = R.fromSize(t).scale(i.sx, i.sy), t = "".concat(t.width, "px ").concat(t.height, "px")), this.elem.style.backgroundSize = t, this.elem.style.backgroundPosition = n;
  }
  drawBackgroundImage(e, t = {}) {
    if (!(e instanceof HTMLImageElement)) {
      this.elem.style.backgroundImage = "";
      return;
    }
    const n = this.optionsCache;
    if (n && n.image !== t.image)
      return;
    let i;
    const r = t.opacity, o = t.size;
    let a = t.repeat || "no-repeat";
    const l = er.registry.get(a);
    if (typeof l == "function") {
      const u = t.quality || 1;
      e.width *= u, e.height *= u;
      const f = l(e, t);
      if (!(f instanceof HTMLCanvasElement))
        throw new Error("Background pattern must return an HTML Canvas instance");
      i = f.toDataURL("image/png"), t.repeat && a !== t.repeat ? a = t.repeat : a = "repeat", typeof o == "object" ? (o.width *= f.width / e.width, o.height *= f.height / e.height) : o === void 0 && (t.size = {
        width: f.width / u,
        height: f.height / u
      });
    } else
      i = e.src, o === void 0 && (t.size = {
        width: e.width,
        height: e.height
      });
    n != null && typeof t.size == "object" && t.image === n.image && t.repeat === n.repeat && t.quality === n.quality && (n.size = _a(t.size));
    const c = this.elem.style;
    c.backgroundImage = "url(".concat(i, ")"), c.backgroundRepeat = a, c.opacity = r == null || r >= 1 ? "" : "".concat(r), this.updateBackgroundImage(t);
  }
  updateBackgroundColor(e) {
    this.elem.style.backgroundColor = e || "";
  }
  updateBackgroundOptions(e) {
    this.graph.options.background = e;
  }
  update() {
    this.optionsCache && this.updateBackgroundImage(this.optionsCache);
  }
  draw(e) {
    const t = e || {};
    if (this.updateBackgroundOptions(e), this.updateBackgroundColor(t.color), t.image) {
      this.optionsCache = _a(t);
      const n = document.createElement("img");
      n.onload = () => this.drawBackgroundImage(n, e), n.setAttribute("crossorigin", "anonymous"), n.src = t.image;
    } else
      this.drawBackgroundImage(null), this.optionsCache = null;
  }
  clear() {
    this.draw();
  }
  dispose() {
    this.clear(), this.stopListening();
  }
}
D3([
  He.dispose()
], ic.prototype, "dispose", null);
var N3 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class rc extends He {
  get widgetOptions() {
    return this.options.panning;
  }
  get pannable() {
    return this.widgetOptions && this.widgetOptions.enabled === !0;
  }
  init() {
    this.onRightMouseDown = this.onRightMouseDown.bind(this), this.onSpaceKeyDown = this.onSpaceKeyDown.bind(this), this.onSpaceKeyUp = this.onSpaceKeyUp.bind(this), this.startListening(), this.updateClassName();
  }
  startListening() {
    this.graph.on("blank:mousedown", this.onMouseDown, this), this.graph.on("node:unhandled:mousedown", this.onMouseDown, this), this.graph.on("edge:unhandled:mousedown", this.onMouseDown, this), Ue.on(this.graph.container, "mousedown", this.onRightMouseDown), Ue.on(document.body, {
      keydown: this.onSpaceKeyDown,
      keyup: this.onSpaceKeyUp
    }), this.mousewheelHandle = new Af(this.graph.container, this.onMouseWheel.bind(this), this.allowMouseWheel.bind(this)), this.mousewheelHandle.enable();
  }
  stopListening() {
    this.graph.off("blank:mousedown", this.onMouseDown, this), this.graph.off("node:unhandled:mousedown", this.onMouseDown, this), this.graph.off("edge:unhandled:mousedown", this.onMouseDown, this), Ue.off(this.graph.container, "mousedown", this.onRightMouseDown), Ue.off(document.body, {
      keydown: this.onSpaceKeyDown,
      keyup: this.onSpaceKeyUp
    }), this.mousewheelHandle && this.mousewheelHandle.disable();
  }
  allowPanning(e, t) {
    return e.spaceKey = this.isSpaceKeyPressed, this.pannable && Gs.isMatch(e, this.widgetOptions.modifiers, t);
  }
  startPanning(e) {
    const t = this.view.normalizeEvent(e);
    this.clientX = t.clientX, this.clientY = t.clientY, this.panning = !0, this.updateClassName(), Ue.on(document.body, {
      "mousemove.panning touchmove.panning": this.pan.bind(this),
      "mouseup.panning touchend.panning": this.stopPanning.bind(this),
      "mouseleave.panning": this.stopPanning.bind(this)
    }), Ue.on(window, "mouseup.panning", this.stopPanning.bind(this));
  }
  pan(e) {
    const t = this.view.normalizeEvent(e), n = t.clientX - this.clientX, i = t.clientY - this.clientY;
    this.clientX = t.clientX, this.clientY = t.clientY, this.graph.translateBy(n, i);
  }
  // eslint-disable-next-line
  stopPanning(e) {
    this.panning = !1, this.updateClassName(), Ue.off(document.body, ".panning"), Ue.off(window, ".panning");
  }
  updateClassName() {
    const e = this.view.container, t = this.view.prefixClassName("graph-panning"), n = this.view.prefixClassName("graph-pannable");
    this.pannable ? this.panning ? (se(e, t), Et(e, n)) : (Et(e, t), se(e, n)) : (Et(e, t), Et(e, n));
  }
  onMouseDown({ e }) {
    if (!this.allowBlankMouseDown(e))
      return;
    const t = this.graph.getPlugin("selection"), n = t && t.allowRubberband(e, !0);
    (this.allowPanning(e, !0) || this.allowPanning(e) && !n) && this.startPanning(e);
  }
  onRightMouseDown(e) {
    const t = this.widgetOptions.eventTypes;
    t != null && t.includes("rightMouseDown") && e.button === 2 && this.allowPanning(e, !0) && this.startPanning(e);
  }
  onMouseWheel(e, t, n) {
    this.graph.translateBy(-t, -n);
  }
  onSpaceKeyDown(e) {
    e.which === 32 && (this.isSpaceKeyPressed = !0);
  }
  onSpaceKeyUp(e) {
    e.which === 32 && (this.isSpaceKeyPressed = !1);
  }
  allowBlankMouseDown(e) {
    const t = this.widgetOptions.eventTypes;
    return (t == null ? void 0 : t.includes("leftMouseDown")) && e.button === 0 || (t == null ? void 0 : t.includes("mouseWheelDown")) && e.button === 1;
  }
  allowMouseWheel(e) {
    var t;
    return this.pannable && !e.ctrlKey && ((t = this.widgetOptions.eventTypes) === null || t === void 0 ? void 0 : t.includes("mouseWheel"));
  }
  autoPanning(e, t) {
    const i = this.graph.getGraphArea();
    let r = 0, o = 0;
    e <= i.left + 10 && (r = -10), t <= i.top + 10 && (o = -10), e >= i.right - 10 && (r = 10), t >= i.bottom - 10 && (o = 10), (r !== 0 || o !== 0) && this.graph.translateBy(-r, -o);
  }
  enablePanning() {
    this.pannable || (this.widgetOptions.enabled = !0, this.updateClassName());
  }
  disablePanning() {
    this.pannable && (this.widgetOptions.enabled = !1, this.updateClassName());
  }
  dispose() {
    this.stopListening();
  }
}
N3([
  He.dispose()
], rc.prototype, "dispose", null);
var I3 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class oc extends He {
  constructor() {
    super(...arguments), this.cumulatedFactor = 1;
  }
  get widgetOptions() {
    return this.options.mousewheel;
  }
  init() {
    this.container = this.graph.container, this.target = this.widgetOptions.global ? document : this.container, this.mousewheelHandle = new Af(this.target, this.onMouseWheel.bind(this), this.allowMouseWheel.bind(this)), this.widgetOptions.enabled && this.enable(!0);
  }
  get disabled() {
    return this.widgetOptions.enabled !== !0;
  }
  enable(e) {
    (this.disabled || e) && (this.widgetOptions.enabled = !0, this.mousewheelHandle.enable());
  }
  disable() {
    this.disabled || (this.widgetOptions.enabled = !1, this.mousewheelHandle.disable());
  }
  allowMouseWheel(e) {
    const t = this.widgetOptions.guard;
    return (t == null || t(e)) && Gs.isMatch(e, this.widgetOptions.modifiers);
  }
  onMouseWheel(e) {
    const t = this.widgetOptions.guard;
    if ((t == null || t(e)) && Gs.isMatch(e, this.widgetOptions.modifiers)) {
      const n = this.widgetOptions.factor || 1.2;
      this.currentScale == null && (this.startPos = { x: e.clientX, y: e.clientY }, this.currentScale = this.graph.transform.getScale().sx), e.deltaY < 0 ? this.currentScale < 0.15 ? this.cumulatedFactor = (this.currentScale + 0.01) / this.currentScale : (this.cumulatedFactor = Math.round(this.currentScale * n * 20) / 20 / this.currentScale, this.cumulatedFactor === 1 && (this.cumulatedFactor = 1.05)) : this.currentScale <= 0.15 ? this.cumulatedFactor = (this.currentScale - 0.01) / this.currentScale : (this.cumulatedFactor = Math.round(this.currentScale * (1 / n) * 20) / 20 / this.currentScale, this.cumulatedFactor === 1 && (this.cumulatedFactor = 0.95)), this.cumulatedFactor = Math.max(0.01, Math.min(this.currentScale * this.cumulatedFactor, 160) / this.currentScale);
      const r = this.currentScale;
      let o = this.graph.transform.clampScale(r * this.cumulatedFactor);
      const a = this.widgetOptions.minScale || Number.MIN_SAFE_INTEGER, l = this.widgetOptions.maxScale || Number.MAX_SAFE_INTEGER;
      if (o = Ct(o, a, l), o !== r)
        if (this.widgetOptions.zoomAtMousePosition) {
          const u = !!this.graph.getPlugin("scroller") ? this.graph.clientToLocal(this.startPos) : this.graph.clientToGraph(this.startPos);
          this.graph.zoom(o, {
            absolute: !0,
            center: u.clone()
          });
        } else
          this.graph.zoom(o, { absolute: !0 });
      this.currentScale = null, this.cumulatedFactor = 1;
    }
  }
  dispose() {
    this.disable();
  }
}
I3([
  an.dispose()
], oc.prototype, "dispose", null);
var j3 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class Cg extends He {
  init() {
    this.resetRenderArea = fp(this.resetRenderArea, 200, {
      leading: !0
    }), this.resetRenderArea(), this.startListening();
  }
  startListening() {
    this.graph.on("translate", this.resetRenderArea, this), this.graph.on("scale", this.resetRenderArea, this), this.graph.on("resize", this.resetRenderArea, this);
  }
  stopListening() {
    this.graph.off("translate", this.resetRenderArea, this), this.graph.off("scale", this.resetRenderArea, this), this.graph.off("resize", this.resetRenderArea, this);
  }
  enableVirtualRender() {
    this.options.virtual = !0, this.resetRenderArea();
  }
  disableVirtualRender() {
    this.options.virtual = !1, this.graph.renderer.setRenderArea(void 0);
  }
  resetRenderArea() {
    if (this.options.virtual) {
      const e = this.graph.getGraphArea();
      this.graph.renderer.setRenderArea(e);
    }
  }
  dispose() {
    this.stopListening();
  }
}
j3([
  He.dispose()
], Cg.prototype, "dispose", null);
class R3 {
  constructor() {
    this.isFlushing = !1, this.isFlushPending = !1, this.scheduleId = 0, this.queue = [], this.frameInterval = 33, this.initialTime = Date.now();
  }
  queueJob(e) {
    if (e.priority & Qt.PRIOR)
      e.cb();
    else {
      const t = this.findInsertionIndex(e);
      t >= 0 && this.queue.splice(t, 0, e);
    }
  }
  queueFlush() {
    !this.isFlushing && !this.isFlushPending && (this.isFlushPending = !0, this.scheduleJob());
  }
  queueFlushSync() {
    !this.isFlushing && !this.isFlushPending && (this.isFlushPending = !0, this.flushJobsSync());
  }
  clearJobs() {
    this.queue.length = 0, this.isFlushing = !1, this.isFlushPending = !1, this.cancelScheduleJob();
  }
  flushJobs() {
    this.isFlushPending = !1, this.isFlushing = !0;
    const e = this.getCurrentTime();
    let t;
    for (; (t = this.queue.shift()) && (t.cb(), !(this.getCurrentTime() - e >= this.frameInterval)); )
      ;
    this.isFlushing = !1, this.queue.length && this.queueFlush();
  }
  flushJobsSync() {
    this.isFlushPending = !1, this.isFlushing = !0;
    let e;
    for (; e = this.queue.shift(); )
      try {
        e.cb();
      } catch (t) {
        console.log(t);
      }
    this.isFlushing = !1;
  }
  findInsertionIndex(e) {
    let t = 0, n = this.queue.length, i = n - 1;
    const r = e.priority;
    for (; t <= i; ) {
      const o = (i - t >> 1) + t;
      r <= this.queue[o].priority ? t = o + 1 : (n = o, i = o - 1);
    }
    return n;
  }
  scheduleJob() {
    "requestIdleCallback" in window ? (this.scheduleId && this.cancelScheduleJob(), this.scheduleId = window.requestIdleCallback(this.flushJobs.bind(this), {
      timeout: 100
    })) : (this.scheduleId && this.cancelScheduleJob(), this.scheduleId = window.setTimeout(this.flushJobs.bind(this)));
  }
  cancelScheduleJob() {
    "cancelIdleCallback" in window ? (this.scheduleId && window.cancelIdleCallback(this.scheduleId), this.scheduleId = 0) : (this.scheduleId && clearTimeout(this.scheduleId), this.scheduleId = 0);
  }
  getCurrentTime() {
    return typeof performance == "object" && typeof performance.now == "function" ? performance.now() : Date.now() - this.initialTime;
  }
}
var Qt;
(function(s) {
  s[s.Update = 2] = "Update", s[s.RenderEdge = 4] = "RenderEdge", s[s.RenderNode = 8] = "RenderNode", s[s.PRIOR = 1048576] = "PRIOR";
})(Qt || (Qt = {}));
var B3 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class De extends an {
  get model() {
    return this.graph.model;
  }
  get container() {
    return this.graph.view.stage;
  }
  constructor(e) {
    super(), this.views = {}, this.willRemoveViews = {}, this.queue = new R3(), this.graph = e, this.init();
  }
  init() {
    this.startListening(), this.renderViews(this.model.getCells());
  }
  startListening() {
    this.model.on("reseted", this.onModelReseted, this), this.model.on("cell:added", this.onCellAdded, this), this.model.on("cell:removed", this.onCellRemoved, this), this.model.on("cell:change:zIndex", this.onCellZIndexChanged, this), this.model.on("cell:change:visible", this.onCellVisibleChanged, this);
  }
  stopListening() {
    this.model.off("reseted", this.onModelReseted, this), this.model.off("cell:added", this.onCellAdded, this), this.model.off("cell:removed", this.onCellRemoved, this), this.model.off("cell:change:zIndex", this.onCellZIndexChanged, this), this.model.off("cell:change:visible", this.onCellVisibleChanged, this);
  }
  onModelReseted({ options: e }) {
    this.queue.clearJobs(), this.removeZPivots(), this.resetViews();
    const t = this.model.getCells();
    this.renderViews(t, Object.assign(Object.assign({}, e), { queue: t.map((n) => n.id) }));
  }
  onCellAdded({ cell: e, options: t }) {
    this.renderViews([e], t);
  }
  onCellRemoved({ cell: e }) {
    this.removeViews([e]);
  }
  onCellZIndexChanged({ cell: e, options: t }) {
    const n = this.views[e.id];
    n && this.requestViewUpdate(n.view, De.FLAG_INSERT, t, Qt.Update, !0);
  }
  onCellVisibleChanged({ cell: e, current: t }) {
    this.toggleVisible(e, !!t);
  }
  requestViewUpdate(e, t, n = {}, i = Qt.Update, r = !0) {
    const o = e.cell.id, a = this.views[o];
    if (!a)
      return;
    a.flag = t, a.options = n, (e.hasAction(t, ["translate", "resize", "rotate"]) || n.async === !1) && (i = Qt.PRIOR, r = !1), this.queue.queueJob({
      id: o,
      priority: i,
      cb: () => {
        this.renderViewInArea(e, t, n);
        const u = n.queue;
        if (u) {
          const f = u.indexOf(e.cell.id);
          f >= 0 && u.splice(f, 1), u.length === 0 && this.graph.trigger("render:done");
        }
      }
    }), this.getEffectedEdges(e).forEach((u) => {
      this.requestViewUpdate(u.view, u.flag, n, i, !1);
    }), r && this.flush();
  }
  setRenderArea(e) {
    this.renderArea = e, this.flushWaitingViews();
  }
  isViewMounted(e) {
    if (e == null)
      return !1;
    const t = this.views[e.cell.id];
    return t ? t.state === De.ViewState.MOUNTED : !1;
  }
  renderViews(e, t = {}) {
    e.sort((n, i) => n.isNode() && i.isEdge() ? -1 : 0), e.forEach((n) => {
      const i = n.id, r = this.views;
      let o = 0, a = r[i];
      if (a)
        o = De.FLAG_INSERT;
      else {
        const l = this.createCellView(n);
        l && (l.graph = this.graph, o = De.FLAG_INSERT | l.getBootstrapFlag(), a = {
          view: l,
          flag: o,
          options: t,
          state: De.ViewState.CREATED
        }, this.views[i] = a);
      }
      a && this.requestViewUpdate(a.view, o, t, this.getRenderPriority(a.view), !1);
    }), this.flush();
  }
  renderViewInArea(e, t, n = {}) {
    const i = e.cell, r = i.id, o = this.views[r];
    if (!o)
      return;
    let a = 0;
    this.isUpdatable(e) ? (a = this.updateView(e, t, n), o.flag = a) : o.state === De.ViewState.MOUNTED ? (a = this.updateView(e, t, n), o.flag = a) : o.state = De.ViewState.WAITING, a && i.isEdge() && !(a & e.getFlag(["source", "target"])) && this.queue.queueJob({
      id: r,
      priority: Qt.RenderEdge,
      cb: () => {
        this.updateView(e, t, n);
      }
    });
  }
  removeViews(e) {
    e.forEach((t) => {
      const n = t.id, i = this.views[n];
      i && (this.willRemoveViews[n] = i, delete this.views[n], this.queue.queueJob({
        id: n,
        priority: this.getRenderPriority(i.view),
        cb: () => {
          this.removeView(i.view);
        }
      }));
    }), this.flush();
  }
  flush() {
    this.graph.options.async ? this.queue.queueFlush() : this.queue.queueFlushSync();
  }
  flushWaitingViews() {
    Object.values(this.views).forEach((e) => {
      if (e && e.state === De.ViewState.WAITING) {
        const { view: t, flag: n, options: i } = e;
        this.requestViewUpdate(t, n, i, this.getRenderPriority(t), !1);
      }
    }), this.flush();
  }
  updateView(e, t, n = {}) {
    if (e == null)
      return 0;
    if (Pe.isCellView(e)) {
      if (t & De.FLAG_REMOVE)
        return this.removeView(e.cell), 0;
      t & De.FLAG_INSERT && (this.insertView(e), t ^= De.FLAG_INSERT);
    }
    return t ? e.confirmUpdate(t, n) : 0;
  }
  insertView(e) {
    const t = this.views[e.cell.id];
    if (t) {
      const n = e.cell.getZIndex(), i = this.addZPivot(n);
      this.container.insertBefore(e.container, i), e.cell.isVisible() || this.toggleVisible(e.cell, !1), t.state = De.ViewState.MOUNTED, this.graph.trigger("view:mounted", { view: e });
    }
  }
  resetViews() {
    this.willRemoveViews = Object.assign(Object.assign({}, this.views), this.willRemoveViews), Object.values(this.willRemoveViews).forEach((e) => {
      e && this.removeView(e.view);
    }), this.views = {}, this.willRemoveViews = {};
  }
  removeView(e) {
    const t = e.cell, n = this.willRemoveViews[t.id];
    n && e && (n.view.remove(), delete this.willRemoveViews[t.id], this.graph.trigger("view:unmounted", { view: e }));
  }
  toggleVisible(e, t) {
    const n = this.model.getConnectedEdges(e);
    for (let r = 0, o = n.length; r < o; r += 1) {
      const a = n[r];
      if (t) {
        const l = a.getSourceCell(), c = a.getTargetCell();
        if (l && !l.isVisible() || c && !c.isVisible())
          continue;
        this.toggleVisible(a, !0);
      } else
        this.toggleVisible(a, !1);
    }
    const i = this.views[e.id];
    i && wr(i.view.container, {
      display: t ? "unset" : "none"
    });
  }
  addZPivot(e = 0) {
    this.zPivots == null && (this.zPivots = {});
    const t = this.zPivots;
    let n = t[e];
    if (n)
      return n;
    n = t[e] = document.createComment("z-index:".concat(e + 1));
    let i = -1 / 0;
    for (const o in t) {
      const a = +o;
      a < e && a > i && (i = a, e - 1);
    }
    const r = this.container;
    if (i !== -1 / 0) {
      const o = t[i];
      r.insertBefore(n, o.nextSibling);
    } else
      r.insertBefore(n, r.firstChild);
    return n;
  }
  removeZPivots() {
    this.zPivots && Object.values(this.zPivots).forEach((e) => {
      e && e.parentNode && e.parentNode.removeChild(e);
    }), this.zPivots = {};
  }
  createCellView(e) {
    const t = { graph: this.graph }, n = this.graph.options.createCellView;
    if (n) {
      const r = G(n, this.graph, e);
      if (r)
        return new r(e, t);
      if (r === null)
        return null;
    }
    const i = e.view;
    if (i != null && typeof i == "string") {
      const r = Pe.registry.get(i);
      return r ? new r(e, t) : Pe.registry.onNotFound(i);
    }
    return e.isNode() ? new It(e, t) : e.isEdge() ? new cn(e, t) : null;
  }
  getEffectedEdges(e) {
    const t = [], n = e.cell, i = this.model.getConnectedEdges(n);
    for (let r = 0, o = i.length; r < o; r += 1) {
      const a = i[r], l = this.views[a.id];
      if (!l)
        continue;
      const c = l.view;
      if (!this.isViewMounted(c))
        continue;
      const u = ["update"];
      a.getTargetCell() === n && u.push("target"), a.getSourceCell() === n && u.push("source"), t.push({
        id: a.id,
        view: c,
        flag: c.getFlag(u)
      });
    }
    return t;
  }
  isUpdatable(e) {
    if (e.isNodeView())
      return this.renderArea ? this.renderArea.isIntersectWithRect(e.cell.getBBox()) : !0;
    if (e.isEdgeView()) {
      const t = e.cell, n = t.getSourceCell(), i = t.getTargetCell();
      if (this.renderArea && n && i)
        return this.renderArea.isIntersectWithRect(n.getBBox()) || this.renderArea.isIntersectWithRect(i.getBBox());
    }
    return !0;
  }
  getRenderPriority(e) {
    return e.cell.isNode() ? Qt.RenderNode : Qt.RenderEdge;
  }
  dispose() {
    this.stopListening(), Object.keys(this.views).forEach((e) => {
      this.views[e].view.dispose();
    }), this.views = {};
  }
}
B3([
  an.dispose()
], De.prototype, "dispose", null);
(function(s) {
  s.FLAG_INSERT = 1 << 30, s.FLAG_REMOVE = 1 << 29, s.FLAG_RENDER = (1 << 26) - 1;
})(De || (De = {}));
(function(s) {
  (function(e) {
    e[e.CREATED = 0] = "CREATED", e[e.MOUNTED = 1] = "MOUNTED", e[e.WAITING = 2] = "WAITING";
  })(s.ViewState || (s.ViewState = {}));
})(De || (De = {}));
var $3 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class ac extends He {
  constructor() {
    super(...arguments), this.schedule = new De(this.graph);
  }
  requestViewUpdate(e, t, n = {}) {
    this.schedule.requestViewUpdate(e, t, n);
  }
  isViewMounted(e) {
    return this.schedule.isViewMounted(e);
  }
  setRenderArea(e) {
    this.schedule.setRenderArea(e);
  }
  findViewByElem(e) {
    if (e == null)
      return null;
    const t = this.options.container, n = typeof e == "string" ? t.querySelector(e) : e instanceof Element ? e : e[0];
    if (n) {
      const i = this.graph.view.findAttr("data-cell-id", n);
      if (i) {
        const r = this.schedule.views;
        if (r[i])
          return r[i].view;
      }
    }
    return null;
  }
  findViewByCell(e) {
    if (e == null)
      return null;
    const t = te.isCell(e) ? e.id : e, n = this.schedule.views;
    return n[t] ? n[t].view : null;
  }
  findViewsFromPoint(e) {
    const t = { x: e.x, y: e.y };
    return this.model.getCells().map((n) => this.findViewByCell(n)).filter((n) => n != null ? re.getBBox(n.container, {
      target: this.view.stage
    }).containsPoint(t) : !1);
  }
  findEdgeViewsFromPoint(e, t = 5) {
    return this.model.getEdges().map((n) => this.findViewByCell(n)).filter((n) => {
      if (n != null) {
        const i = n.getClosestPoint(e);
        if (i)
          return i.distance(e) <= t;
      }
      return !1;
    });
  }
  findViewsInArea(e, t = {}) {
    const n = R.create(e);
    return this.model.getCells().map((i) => this.findViewByCell(i)).filter((i) => {
      if (i) {
        if (t.nodeOnly && !i.isNodeView())
          return !1;
        const r = re.getBBox(i.container, {
          target: this.view.stage
        });
        return r.width === 0 ? r.inflate(1, 0) : r.height === 0 && r.inflate(0, 1), t.strict ? n.containsRect(r) : n.isIntersectWithRect(r);
      }
      return !1;
    });
  }
  dispose() {
    this.schedule.dispose();
  }
}
$3([
  He.dispose()
], ac.prototype, "dispose", null);
var Bh = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
class Eg extends He {
  get cid() {
    return this.graph.view.cid;
  }
  get svg() {
    return this.view.svg;
  }
  get defs() {
    return this.view.defs;
  }
  isDefined(e) {
    return this.svg.getElementById(e) != null;
  }
  filter(e) {
    let t = e.id;
    const n = e.name;
    if (t || (t = "filter-".concat(n, "-").concat(this.cid, "-").concat(ya(JSON.stringify(e)))), !this.isDefined(t)) {
      const i = Ys.registry.get(n);
      if (i == null)
        return Ys.registry.onNotFound(n);
      const r = i(e.args || {}), o = Object.assign(Object.assign({ x: -1, y: -1, width: 3, height: 3, filterUnits: "objectBoundingBox" }, e.attrs), { id: t });
      U.create(ge.sanitize(r), o).appendTo(this.defs);
    }
    return t;
  }
  gradient(e) {
    let t = e.id;
    const n = e.type;
    if (t || (t = "gradient-".concat(n, "-").concat(this.cid, "-").concat(ya(JSON.stringify(e)))), !this.isDefined(t)) {
      const r = e.stops.map((l) => {
        const c = l.opacity != null && Number.isFinite(l.opacity) ? l.opacity : 1;
        return '<stop offset="'.concat(l.offset, '" stop-color="').concat(l.color, '" stop-opacity="').concat(c, '"/>');
      }), o = "<".concat(n, ">").concat(r.join(""), "</").concat(n, ">"), a = Object.assign({ id: t }, e.attrs);
      U.create(o, a).appendTo(this.defs);
    }
    return t;
  }
  marker(e) {
    const { id: t, refX: n, refY: i, markerUnits: r, markerOrient: o, tagName: a, children: l } = e, c = Bh(e, ["id", "refX", "refY", "markerUnits", "markerOrient", "tagName", "children"]);
    let u = t;
    if (u || (u = "marker-".concat(this.cid, "-").concat(ya(JSON.stringify(e)))), !this.isDefined(u)) {
      a !== "path" && delete c.d;
      const f = U.create("marker", {
        refX: n,
        refY: i,
        id: u,
        overflow: "visible",
        orient: o != null ? o : "auto",
        markerUnits: r || "userSpaceOnUse"
      }, l ? l.map((d) => {
        var { tagName: g } = d, p = Bh(d, ["tagName"]);
        return U.create("".concat(g) || "path", Xi(Object.assign(Object.assign({}, c), p)));
      }) : [U.create(a || "path", Xi(c))]);
      this.defs.appendChild(f.node);
    }
    return u;
  }
  remove(e) {
    const t = this.svg.getElementById(e);
    t && t.parentNode && t.parentNode.removeChild(t);
  }
}
class Sg extends He {
  getClientMatrix() {
    return Ve(this.view.stage.getScreenCTM());
  }
  /**
   * Returns coordinates of the graph viewport, relative to the window.
   */
  getClientOffset() {
    const e = this.view.svg.getBoundingClientRect();
    return new S(e.left, e.top);
  }
  /**
   * Returns coordinates of the graph viewport, relative to the document.
   */
  getPageOffset() {
    return this.getClientOffset().translate(window.scrollX, window.scrollY);
  }
  snapToGrid(e, t) {
    return (typeof e == "number" ? this.clientToLocalPoint(e, t) : this.clientToLocalPoint(e.x, e.y)).snapToGrid(this.graph.getGridSize());
  }
  localToGraphPoint(e, t) {
    const n = S.create(e, t);
    return re.transformPoint(n, this.graph.matrix());
  }
  localToClientPoint(e, t) {
    const n = S.create(e, t);
    return re.transformPoint(n, this.getClientMatrix());
  }
  localToPagePoint(e, t) {
    return (typeof e == "number" ? this.localToGraphPoint(e, t) : this.localToGraphPoint(e)).translate(this.getPageOffset());
  }
  localToGraphRect(e, t, n, i) {
    const r = R.create(e, t, n, i);
    return re.transformRectangle(r, this.graph.matrix());
  }
  localToClientRect(e, t, n, i) {
    const r = R.create(e, t, n, i);
    return re.transformRectangle(r, this.getClientMatrix());
  }
  localToPageRect(e, t, n, i) {
    return (typeof e == "number" ? this.localToGraphRect(e, t, n, i) : this.localToGraphRect(e)).translate(this.getPageOffset());
  }
  graphToLocalPoint(e, t) {
    const n = S.create(e, t);
    return re.transformPoint(n, this.graph.matrix().inverse());
  }
  clientToLocalPoint(e, t) {
    const n = S.create(e, t);
    return re.transformPoint(n, this.getClientMatrix().inverse());
  }
  clientToGraphPoint(e, t) {
    const n = S.create(e, t);
    return re.transformPoint(n, this.graph.matrix().multiply(this.getClientMatrix().inverse()));
  }
  pageToLocalPoint(e, t) {
    const i = S.create(e, t).diff(this.getPageOffset());
    return this.graphToLocalPoint(i);
  }
  graphToLocalRect(e, t, n, i) {
    const r = R.create(e, t, n, i);
    return re.transformRectangle(r, this.graph.matrix().inverse());
  }
  clientToLocalRect(e, t, n, i) {
    const r = R.create(e, t, n, i);
    return re.transformRectangle(r, this.getClientMatrix().inverse());
  }
  clientToGraphRect(e, t, n, i) {
    const r = R.create(e, t, n, i);
    return re.transformRectangle(r, this.graph.matrix().multiply(this.getClientMatrix().inverse()));
  }
  pageToLocalRect(e, t, n, i) {
    const r = R.create(e, t, n, i), o = this.getPageOffset();
    return r.x -= o.x, r.y -= o.y, this.graphToLocalRect(r);
  }
}
var F3 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class vo extends He {
  constructor() {
    super(...arguments), this.highlights = {};
  }
  init() {
    this.startListening();
  }
  startListening() {
    this.graph.on("cell:highlight", this.onCellHighlight, this), this.graph.on("cell:unhighlight", this.onCellUnhighlight, this);
  }
  stopListening() {
    this.graph.off("cell:highlight", this.onCellHighlight, this), this.graph.off("cell:unhighlight", this.onCellUnhighlight, this);
  }
  onCellHighlight({ view: e, magnet: t, options: n = {} }) {
    const i = this.resolveHighlighter(n);
    if (!i)
      return;
    const r = this.getHighlighterId(t, i);
    if (!this.highlights[r]) {
      const o = i.highlighter;
      o.highlight(e, t, Object.assign({}, i.args)), this.highlights[r] = {
        cellView: e,
        magnet: t,
        highlighter: o,
        args: i.args
      };
    }
  }
  onCellUnhighlight({ magnet: e, options: t = {} }) {
    const n = this.resolveHighlighter(t);
    if (!n)
      return;
    const i = this.getHighlighterId(e, n);
    this.unhighlight(i);
  }
  resolveHighlighter(e) {
    const t = this.options;
    let n = e.highlighter;
    if (n == null) {
      const a = e.type;
      n = a && t.highlighting[a] || t.highlighting.default;
    }
    if (n == null)
      return null;
    const i = typeof n == "string" ? {
      name: n
    } : n, r = i.name, o = on.registry.get(r);
    return o == null ? on.registry.onNotFound(r) : (on.check(r, o), {
      name: r,
      highlighter: o,
      args: i.args || {}
    });
  }
  getHighlighterId(e, t) {
    return Jl(e), t.name + e.id + JSON.stringify(t.args);
  }
  unhighlight(e) {
    const t = this.highlights[e];
    t && (t.highlighter.unhighlight(t.cellView, t.magnet, t.args), delete this.highlights[e]);
  }
  dispose() {
    Object.keys(this.highlights).forEach((e) => this.unhighlight(e)), this.stopListening();
  }
}
F3([
  vo.dispose()
], vo.prototype, "dispose", null);
var z3 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class Ag extends He {
  getScroller() {
    const e = this.graph.getPlugin("scroller");
    return e && e.options.enabled ? e : null;
  }
  getContainer() {
    const e = this.getScroller();
    return e ? e.container.parentElement : this.graph.container.parentElement;
  }
  getSensorTarget() {
    const e = this.options.autoResize;
    if (e)
      return typeof e == "boolean" ? this.getContainer() : e;
  }
  init() {
    if (this.options.autoResize) {
      const t = this.getSensorTarget();
      t && uo.bind(t, () => {
        const n = t.offsetWidth, i = t.offsetHeight;
        this.resize(n, i);
      });
    }
  }
  resize(e, t) {
    const n = this.getScroller();
    n ? n.resize(e, t) : this.graph.transform.resize(e, t);
  }
  dispose() {
    uo.clear(this.graph.container);
  }
}
z3([
  He.dispose()
], Ag.prototype, "dispose", null);
var V3 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
};
class Ye extends ft {
  get container() {
    return this.options.container;
  }
  get [Symbol.toStringTag]() {
    return Ye.toStringTag;
  }
  constructor(e) {
    super(), this.installedPlugins = /* @__PURE__ */ new Set(), this.options = rr.get(e), this.css = new ll(this), this.view = new qt(this), this.defs = new Eg(this), this.coord = new Sg(this), this.transform = new xg(this), this.highlight = new vo(this), this.grid = new sc(this), this.background = new ic(this), this.options.model ? this.model = this.options.model : (this.model = new Tt(), this.model.graph = this), this.renderer = new ac(this), this.panning = new rc(this), this.mousewheel = new oc(this), this.virtualRender = new Cg(this), this.size = new Ag(this);
  }
  // #region model
  isNode(e) {
    return e.isNode();
  }
  isEdge(e) {
    return e.isEdge();
  }
  resetCells(e, t = {}) {
    return this.model.resetCells(e, t), this;
  }
  clearCells(e = {}) {
    return this.model.clear(e), this;
  }
  toJSON(e = {}) {
    return this.model.toJSON(e);
  }
  parseJSON(e) {
    return this.model.parseJSON(e);
  }
  fromJSON(e, t = {}) {
    return this.model.fromJSON(e, t), this;
  }
  getCellById(e) {
    return this.model.getCell(e);
  }
  addNode(e, t = {}) {
    return this.model.addNode(e, t);
  }
  addNodes(e, t = {}) {
    return this.addCell(e.map((n) => Re.isNode(n) ? n : this.createNode(n)), t);
  }
  createNode(e) {
    return this.model.createNode(e);
  }
  removeNode(e, t = {}) {
    return this.model.removeCell(e, t);
  }
  addEdge(e, t = {}) {
    return this.model.addEdge(e, t);
  }
  addEdges(e, t = {}) {
    return this.addCell(e.map((n) => Ee.isEdge(n) ? n : this.createEdge(n)), t);
  }
  removeEdge(e, t = {}) {
    return this.model.removeCell(e, t);
  }
  createEdge(e) {
    return this.model.createEdge(e);
  }
  addCell(e, t = {}) {
    return this.model.addCell(e, t), this;
  }
  removeCell(e, t = {}) {
    return this.model.removeCell(e, t);
  }
  removeCells(e, t = {}) {
    return this.model.removeCells(e, t);
  }
  removeConnectedEdges(e, t = {}) {
    return this.model.removeConnectedEdges(e, t);
  }
  disconnectConnectedEdges(e, t = {}) {
    return this.model.disconnectConnectedEdges(e, t), this;
  }
  hasCell(e) {
    return this.model.has(e);
  }
  getCells() {
    return this.model.getCells();
  }
  getCellCount() {
    return this.model.total();
  }
  /**
   * Returns all the nodes in the graph.
   */
  getNodes() {
    return this.model.getNodes();
  }
  /**
   * Returns all the edges in the graph.
   */
  getEdges() {
    return this.model.getEdges();
  }
  /**
   * Returns all outgoing edges for the node.
   */
  getOutgoingEdges(e) {
    return this.model.getOutgoingEdges(e);
  }
  /**
   * Returns all incoming edges for the node.
   */
  getIncomingEdges(e) {
    return this.model.getIncomingEdges(e);
  }
  /**
   * Returns edges connected with cell.
   */
  getConnectedEdges(e, t = {}) {
    return this.model.getConnectedEdges(e, t);
  }
  /**
   * Returns an array of all the roots of the graph.
   */
  getRootNodes() {
    return this.model.getRoots();
  }
  /**
   * Returns an array of all the leafs of the graph.
   */
  getLeafNodes() {
    return this.model.getLeafs();
  }
  /**
   * Returns `true` if the node is a root node, i.e.
   * there is no  edges coming to the node.
   */
  isRootNode(e) {
    return this.model.isRoot(e);
  }
  /**
   * Returns `true` if the node is a leaf node, i.e.
   * there is no edges going out from the node.
   */
  isLeafNode(e) {
    return this.model.isLeaf(e);
  }
  /**
   * Returns all the neighbors of node in the graph. Neighbors are all
   * the nodes connected to node via either incoming or outgoing edge.
   */
  getNeighbors(e, t = {}) {
    return this.model.getNeighbors(e, t);
  }
  /**
   * Returns `true` if `cell2` is a neighbor of `cell1`.
   */
  isNeighbor(e, t, n = {}) {
    return this.model.isNeighbor(e, t, n);
  }
  getSuccessors(e, t = {}) {
    return this.model.getSuccessors(e, t);
  }
  /**
   * Returns `true` if `cell2` is a successor of `cell1`.
   */
  isSuccessor(e, t, n = {}) {
    return this.model.isSuccessor(e, t, n);
  }
  getPredecessors(e, t = {}) {
    return this.model.getPredecessors(e, t);
  }
  /**
   * Returns `true` if `cell2` is a predecessor of `cell1`.
   */
  isPredecessor(e, t, n = {}) {
    return this.model.isPredecessor(e, t, n);
  }
  getCommonAncestor(...e) {
    return this.model.getCommonAncestor(...e);
  }
  /**
   * Returns an array of cells that result from finding nodes/edges that
   * are connected to any of the cells in the cells array. This function
   * loops over cells and if the current cell is a edge, it collects its
   * source/target nodes; if it is an node, it collects its incoming and
   * outgoing edges if both the edge terminal (source/target) are in the
   * cells array.
   */
  getSubGraph(e, t = {}) {
    return this.model.getSubGraph(e, t);
  }
  /**
   * Clones the whole subgraph (including all the connected links whose
   * source/target is in the subgraph). If `options.deep` is `true`, also
   * take into account all the embedded cells of all the subgraph cells.
   *
   * Returns a map of the form: { [original cell ID]: [clone] }.
   */
  cloneSubGraph(e, t = {}) {
    return this.model.cloneSubGraph(e, t);
  }
  cloneCells(e) {
    return this.model.cloneCells(e);
  }
  getNodesFromPoint(e, t) {
    return this.model.getNodesFromPoint(e, t);
  }
  getNodesInArea(e, t, n, i, r) {
    return this.model.getNodesInArea(e, t, n, i, r);
  }
  getNodesUnderNode(e, t = {}) {
    return this.model.getNodesUnderNode(e, t);
  }
  searchCell(e, t, n = {}) {
    return this.model.search(e, t, n), this;
  }
  /** *
   * Returns an array of IDs of nodes on the shortest
   * path between source and target.
   */
  getShortestPath(e, t, n = {}) {
    return this.model.getShortestPath(e, t, n);
  }
  /**
   * Returns the bounding box that surrounds all cells in the graph.
   */
  getAllCellsBBox() {
    return this.model.getAllCellsBBox();
  }
  /**
   * Returns the bounding box that surrounds all the given cells.
   */
  getCellsBBox(e, t = {}) {
    return this.model.getCellsBBox(e, t);
  }
  startBatch(e, t = {}) {
    this.model.startBatch(e, t);
  }
  stopBatch(e, t = {}) {
    this.model.stopBatch(e, t);
  }
  batchUpdate(e, t, n) {
    const i = typeof e == "string" ? e : "update", r = typeof e == "string" ? t : e, o = typeof t == "function" ? n : t;
    this.startBatch(i, o);
    const a = r();
    return this.stopBatch(i, o), a;
  }
  updateCellId(e, t) {
    return this.model.updateCellId(e, t);
  }
  // #endregion
  // #region view
  findView(e) {
    return te.isCell(e) ? this.findViewByCell(e) : this.findViewByElem(e);
  }
  findViews(e) {
    return R.isRectangleLike(e) ? this.findViewsInArea(e) : S.isPointLike(e) ? this.findViewsFromPoint(e) : [];
  }
  findViewByCell(e) {
    return this.renderer.findViewByCell(e);
  }
  findViewByElem(e) {
    return this.renderer.findViewByElem(e);
  }
  findViewsFromPoint(e, t) {
    const n = typeof e == "number" ? { x: e, y: t } : e;
    return this.renderer.findViewsFromPoint(n);
  }
  findViewsInArea(e, t, n, i, r) {
    const o = typeof e == "number" ? {
      x: e,
      y: t,
      width: n,
      height: i
    } : e, a = typeof e == "number" ? r : t;
    return this.renderer.findViewsInArea(o, a);
  }
  matrix(e) {
    return typeof e > "u" ? this.transform.getMatrix() : (this.transform.setMatrix(e), this);
  }
  resize(e, t) {
    const n = this.getPlugin("scroller");
    return n ? n.resize(e, t) : this.transform.resize(e, t), this;
  }
  scale(e, t = e, n = 0, i = 0) {
    return typeof e > "u" ? this.transform.getScale() : (this.transform.scale(e, t, n, i), this);
  }
  zoom(e, t) {
    const n = this.getPlugin("scroller");
    if (n) {
      if (typeof e > "u")
        return n.zoom();
      n.zoom(e, t);
    } else {
      if (typeof e > "u")
        return this.transform.getZoom();
      this.transform.zoom(e, t);
    }
    return this;
  }
  zoomTo(e, t = {}) {
    const n = this.getPlugin("scroller");
    return n ? n.zoom(e, Object.assign(Object.assign({}, t), { absolute: !0 })) : this.transform.zoom(e, Object.assign(Object.assign({}, t), { absolute: !0 })), this;
  }
  zoomToRect(e, t = {}) {
    const n = this.getPlugin("scroller");
    return n ? n.zoomToRect(e, t) : this.transform.zoomToRect(e, t), this;
  }
  zoomToFit(e = {}) {
    const t = this.getPlugin("scroller");
    return t ? t.zoomToFit(e) : this.transform.zoomToFit(e), this;
  }
  rotate(e, t, n) {
    return typeof e > "u" ? this.transform.getRotation() : (this.transform.rotate(e, t, n), this);
  }
  translate(e, t) {
    return typeof e > "u" ? this.transform.getTranslation() : (this.transform.translate(e, t), this);
  }
  translateBy(e, t) {
    const n = this.translate(), i = n.tx + e, r = n.ty + t;
    return this.translate(i, r);
  }
  getGraphArea() {
    return this.transform.getGraphArea();
  }
  getContentArea(e = {}) {
    return this.transform.getContentArea(e);
  }
  getContentBBox(e = {}) {
    return this.transform.getContentBBox(e);
  }
  fitToContent(e, t, n, i) {
    return this.transform.fitToContent(e, t, n, i);
  }
  scaleContentToFit(e = {}) {
    return this.transform.scaleContentToFit(e), this;
  }
  /**
   * Position the center of graph to the center of the viewport.
   */
  center(e) {
    return this.centerPoint(e);
  }
  centerPoint(e, t, n) {
    const i = this.getPlugin("scroller");
    return i ? i.centerPoint(e, t, n) : this.transform.centerPoint(e, t), this;
  }
  centerContent(e) {
    const t = this.getPlugin("scroller");
    return t ? t.centerContent(e) : this.transform.centerContent(e), this;
  }
  centerCell(e, t) {
    const n = this.getPlugin("scroller");
    return n ? n.centerCell(e, t) : this.transform.centerCell(e), this;
  }
  positionPoint(e, t, n, i = {}) {
    const r = this.getPlugin("scroller");
    return r ? r.positionPoint(e, t, n, i) : this.transform.positionPoint(e, t, n), this;
  }
  positionRect(e, t, n) {
    const i = this.getPlugin("scroller");
    return i ? i.positionRect(e, t, n) : this.transform.positionRect(e, t), this;
  }
  positionCell(e, t, n) {
    const i = this.getPlugin("scroller");
    return i ? i.positionCell(e, t, n) : this.transform.positionCell(e, t), this;
  }
  positionContent(e, t) {
    const n = this.getPlugin("scroller");
    return n ? n.positionContent(e, t) : this.transform.positionContent(e, t), this;
  }
  snapToGrid(e, t) {
    return this.coord.snapToGrid(e, t);
  }
  pageToLocal(e, t, n, i) {
    return R.isRectangleLike(e) ? this.coord.pageToLocalRect(e) : typeof e == "number" && typeof t == "number" && typeof n == "number" && typeof i == "number" ? this.coord.pageToLocalRect(e, t, n, i) : this.coord.pageToLocalPoint(e, t);
  }
  localToPage(e, t, n, i) {
    return R.isRectangleLike(e) ? this.coord.localToPageRect(e) : typeof e == "number" && typeof t == "number" && typeof n == "number" && typeof i == "number" ? this.coord.localToPageRect(e, t, n, i) : this.coord.localToPagePoint(e, t);
  }
  clientToLocal(e, t, n, i) {
    return R.isRectangleLike(e) ? this.coord.clientToLocalRect(e) : typeof e == "number" && typeof t == "number" && typeof n == "number" && typeof i == "number" ? this.coord.clientToLocalRect(e, t, n, i) : this.coord.clientToLocalPoint(e, t);
  }
  localToClient(e, t, n, i) {
    return R.isRectangleLike(e) ? this.coord.localToClientRect(e) : typeof e == "number" && typeof t == "number" && typeof n == "number" && typeof i == "number" ? this.coord.localToClientRect(e, t, n, i) : this.coord.localToClientPoint(e, t);
  }
  localToGraph(e, t, n, i) {
    return R.isRectangleLike(e) ? this.coord.localToGraphRect(e) : typeof e == "number" && typeof t == "number" && typeof n == "number" && typeof i == "number" ? this.coord.localToGraphRect(e, t, n, i) : this.coord.localToGraphPoint(e, t);
  }
  graphToLocal(e, t, n, i) {
    return R.isRectangleLike(e) ? this.coord.graphToLocalRect(e) : typeof e == "number" && typeof t == "number" && typeof n == "number" && typeof i == "number" ? this.coord.graphToLocalRect(e, t, n, i) : this.coord.graphToLocalPoint(e, t);
  }
  clientToGraph(e, t, n, i) {
    return R.isRectangleLike(e) ? this.coord.clientToGraphRect(e) : typeof e == "number" && typeof t == "number" && typeof n == "number" && typeof i == "number" ? this.coord.clientToGraphRect(e, t, n, i) : this.coord.clientToGraphPoint(e, t);
  }
  // #endregion
  // #region defs
  defineFilter(e) {
    return this.defs.filter(e);
  }
  defineGradient(e) {
    return this.defs.gradient(e);
  }
  defineMarker(e) {
    return this.defs.marker(e);
  }
  // #endregion
  // #region grid
  getGridSize() {
    return this.grid.getGridSize();
  }
  setGridSize(e) {
    return this.grid.setGridSize(e), this;
  }
  showGrid() {
    return this.grid.show(), this;
  }
  hideGrid() {
    return this.grid.hide(), this;
  }
  clearGrid() {
    return this.grid.clear(), this;
  }
  drawGrid(e) {
    return this.grid.draw(e), this;
  }
  // #endregion
  // #region background
  updateBackground() {
    return this.background.update(), this;
  }
  drawBackground(e, t) {
    const n = this.getPlugin("scroller");
    return n != null && (this.options.background == null || !t) ? n.drawBackground(e, t) : this.background.draw(e), this;
  }
  clearBackground(e) {
    const t = this.getPlugin("scroller");
    return t != null && (this.options.background == null || !e) ? t.clearBackground(e) : this.background.clear(), this;
  }
  // #endregion
  // #region virtual-render
  enableVirtualRender() {
    return this.virtualRender.enableVirtualRender(), this;
  }
  disableVirtualRender() {
    return this.virtualRender.disableVirtualRender(), this;
  }
  // #endregion
  // #region mousewheel
  isMouseWheelEnabled() {
    return !this.mousewheel.disabled;
  }
  enableMouseWheel() {
    return this.mousewheel.enable(), this;
  }
  disableMouseWheel() {
    return this.mousewheel.disable(), this;
  }
  toggleMouseWheel(e) {
    return e == null ? this.isMouseWheelEnabled() ? this.disableMouseWheel() : this.enableMouseWheel() : e ? this.enableMouseWheel() : this.disableMouseWheel(), this;
  }
  // #endregion
  // #region panning
  isPannable() {
    const e = this.getPlugin("scroller");
    return e ? e.isPannable() : this.panning.pannable;
  }
  enablePanning() {
    const e = this.getPlugin("scroller");
    return e ? e.enablePanning() : this.panning.enablePanning(), this;
  }
  disablePanning() {
    const e = this.getPlugin("scroller");
    return e ? e.disablePanning() : this.panning.disablePanning(), this;
  }
  togglePanning(e) {
    return e == null ? this.isPannable() ? this.disablePanning() : this.enablePanning() : e !== this.isPannable() && (e ? this.enablePanning() : this.disablePanning()), this;
  }
  // #endregion
  // #region plugin
  use(e, ...t) {
    return this.installedPlugins.has(e) || (this.installedPlugins.add(e), e.init(this, ...t)), this;
  }
  getPlugin(e) {
    return Array.from(this.installedPlugins).find((t) => t.name === e);
  }
  getPlugins(e) {
    return Array.from(this.installedPlugins).filter((t) => e.includes(t.name));
  }
  enablePlugins(e) {
    let t = e;
    Array.isArray(t) || (t = [t]);
    const n = this.getPlugins(t);
    return n == null || n.forEach((i) => {
      var r;
      (r = i == null ? void 0 : i.enable) === null || r === void 0 || r.call(i);
    }), this;
  }
  disablePlugins(e) {
    let t = e;
    Array.isArray(t) || (t = [t]);
    const n = this.getPlugins(t);
    return n == null || n.forEach((i) => {
      var r;
      (r = i == null ? void 0 : i.disable) === null || r === void 0 || r.call(i);
    }), this;
  }
  isPluginEnabled(e) {
    var t;
    const n = this.getPlugin(e);
    return (t = n == null ? void 0 : n.isEnabled) === null || t === void 0 ? void 0 : t.call(n);
  }
  disposePlugins(e) {
    let t = e;
    Array.isArray(t) || (t = [t]);
    const n = this.getPlugins(t);
    return n == null || n.forEach((i) => {
      i.dispose(), this.installedPlugins.delete(i);
    }), this;
  }
  // #endregion
  // #region dispose
  dispose(e = !0) {
    e && this.model.dispose(), this.css.dispose(), this.defs.dispose(), this.grid.dispose(), this.coord.dispose(), this.transform.dispose(), this.highlight.dispose(), this.background.dispose(), this.mousewheel.dispose(), this.panning.dispose(), this.view.dispose(), this.renderer.dispose(), this.installedPlugins.forEach((t) => {
      t.dispose();
    });
  }
}
V3([
  ft.dispose()
], Ye.prototype, "dispose", null);
(function(s) {
  s.View = qt, s.Renderer = ac, s.MouseWheel = oc, s.DefsManager = Eg, s.GridManager = sc, s.CoordManager = Sg, s.TransformManager = xg, s.HighlightManager = vo, s.BackgroundManager = ic, s.PanningManager = rc;
})(Ye || (Ye = {}));
(function(s) {
  s.toStringTag = "X6.".concat(s.name);
  function e(t) {
    if (t == null)
      return !1;
    if (t instanceof s)
      return !0;
    const n = t[Symbol.toStringTag];
    return n == null || n === s.toStringTag;
  }
  s.isGraph = e;
})(Ye || (Ye = {}));
(function(s) {
  function e(t, n) {
    const i = t instanceof HTMLElement ? new s({ container: t }) : new s(t);
    return n != null && i.fromJSON(n), i;
  }
  s.render = e;
})(Ye || (Ye = {}));
(function(s) {
  s.registerNode = Re.registry.register, s.registerEdge = Ee.registry.register, s.registerView = Pe.registry.register, s.registerAttr = Ut.registry.register, s.registerGrid = Sn.registry.register, s.registerFilter = Ys.registry.register, s.registerNodeTool = Ks.registry.register, s.registerEdgeTool = Qs.registry.register, s.registerBackground = er.registry.register, s.registerHighlighter = on.registry.register, s.registerPortLayout = ns.registry.register, s.registerPortLabelLayout = Xs.registry.register, s.registerMarker = Dn.registry.register, s.registerRouter = An.registry.register, s.registerConnector = ss.registry.register, s.registerAnchor = ei.registry.register, s.registerEdgeAnchor = ti.registry.register, s.registerConnectionPoint = ni.registry.register;
})(Ye || (Ye = {}));
(function(s) {
  s.unregisterNode = Re.registry.unregister, s.unregisterEdge = Ee.registry.unregister, s.unregisterView = Pe.registry.unregister, s.unregisterAttr = Ut.registry.unregister, s.unregisterGrid = Sn.registry.unregister, s.unregisterFilter = Ys.registry.unregister, s.unregisterNodeTool = Ks.registry.unregister, s.unregisterEdgeTool = Qs.registry.unregister, s.unregisterBackground = er.registry.unregister, s.unregisterHighlighter = on.registry.unregister, s.unregisterPortLayout = ns.registry.unregister, s.unregisterPortLabelLayout = Xs.registry.unregister, s.unregisterMarker = Dn.registry.unregister, s.unregisterRouter = An.registry.unregister, s.unregisterConnector = ss.registry.unregister, s.unregisterAnchor = ei.registry.unregister, s.unregisterEdgeAnchor = ti.registry.unregister, s.unregisterConnectionPoint = ni.registry.unregister;
})(Ye || (Ye = {}));
var H3 = globalThis && globalThis.__decorate || function(s, e, t, n) {
  var i = arguments.length, r = i < 3 ? e : n === null ? n = Object.getOwnPropertyDescriptor(e, t) : n, o;
  if (typeof Reflect == "object" && typeof Reflect.decorate == "function")
    r = Reflect.decorate(s, e, t, n);
  else
    for (var a = s.length - 1; a >= 0; a--)
      (o = s[a]) && (r = (i < 3 ? o(r) : i > 3 ? o(e, t, r) : o(e, t)) || r);
  return i > 3 && r && Object.defineProperty(e, t, r), r;
}, U3 = globalThis && globalThis.__rest || function(s, e) {
  var t = {};
  for (var n in s)
    Object.prototype.hasOwnProperty.call(s, n) && e.indexOf(n) < 0 && (t[n] = s[n]);
  if (s != null && typeof Object.getOwnPropertySymbols == "function")
    for (var i = 0, n = Object.getOwnPropertySymbols(s); i < n.length; i++)
      e.indexOf(n[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, n[i]) && (t[n[i]] = s[n[i]]);
  return t;
};
class gs extends Re {
}
(function(s) {
  class e extends It {
    init() {
      super.init(), this.cell.on("change:*", this.onCellChangeAny, this);
    }
    onCellChangeAny({ key: n }) {
      const i = s.shapeMaps[this.cell.shape];
      if (i) {
        const { effect: r } = i;
        (!r || r.includes(n)) && this.renderHTMLComponent();
      }
    }
    confirmUpdate(n) {
      const i = super.confirmUpdate(n);
      return this.handleAction(i, e.action, () => this.renderHTMLComponent());
    }
    renderHTMLComponent() {
      const n = this.selectors && this.selectors.foContent;
      if (n) {
        pr(n);
        const i = s.shapeMaps[this.cell.shape];
        if (!i)
          return;
        let { html: r } = i;
        typeof r == "function" && (r = r(this.cell)), r && (typeof r == "string" ? n.innerHTML = r : mr(n, r));
      }
    }
    dispose() {
      this.cell.off("change:*", this.onCellChangeAny, this);
    }
  }
  H3([
    e.dispose()
  ], e.prototype, "dispose", null), s.View = e, function(t) {
    t.action = "html", t.config({
      bootstrap: [t.action],
      actions: {
        html: t.action
      }
    }), It.registry.register("html-view", t, !0);
  }(e = s.View || (s.View = {}));
})(gs || (gs = {}));
(function(s) {
  s.config({
    view: "html-view",
    markup: [
      {
        tagName: "rect",
        selector: "body"
      },
      Object.assign({}, ge.getForeignObjectMarkup()),
      {
        tagName: "text",
        selector: "label"
      }
    ],
    attrs: {
      body: {
        fill: "none",
        stroke: "none",
        refWidth: "100%",
        refHeight: "100%"
      },
      fo: {
        refWidth: "100%",
        refHeight: "100%"
      }
    }
  }), Re.registry.register("html", s, !0);
})(gs || (gs = {}));
(function(s) {
  s.shapeMaps = {};
  function e(t) {
    const { shape: n, html: i, effect: r, inherit: o } = t, a = U3(t, ["shape", "html", "effect", "inherit"]);
    if (!n)
      throw new Error("should specify shape in config");
    s.shapeMaps[n] = {
      html: i,
      effect: r
    }, Ye.registerNode(n, Object.assign({ inherit: o || "html" }, a), !0);
  }
  s.register = e;
})(gs || (gs = {}));
var R7 = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function q3(s) {
  return s && s.__esModule && Object.prototype.hasOwnProperty.call(s, "default") ? s.default : s;
}
function G3(s, e, t, n) {
  return n === void 0 && (n = "height"), t === "center" ? (s[n] + e[n]) / 2 : s.height;
}
var Vn = {
  assign: Object.assign,
  getHeight: G3
}, Mg = Vn, lc = 18, W3 = lc * 2, $h = lc, J3 = {
  getId: function(e) {
    return e.id || e.name;
  },
  getPreH: function(e) {
    return e.preH || 0;
  },
  getPreV: function(e) {
    return e.preV || 0;
  },
  getHGap: function(e) {
    return e.hgap || $h;
  },
  getVGap: function(e) {
    return e.vgap || $h;
  },
  getChildren: function(e) {
    return e.children;
  },
  getHeight: function(e) {
    return e.height || W3;
  },
  getWidth: function(e) {
    var t = e.label || " ";
    return e.width || t.split("").length * lc;
  }
};
function xo(s, e) {
  var t = this;
  if (t.vgap = t.hgap = 0, s instanceof xo)
    return s;
  t.data = s;
  var n = e.getHGap(s), i = e.getVGap(s);
  return t.preH = e.getPreH(s), t.preV = e.getPreV(s), t.width = e.getWidth(s), t.height = e.getHeight(s), t.width += t.preH, t.height += t.preV, t.id = e.getId(s), t.x = t.y = 0, t.depth = 0, t.children || (t.children = []), t.addGap(n, i), t;
}
Mg.assign(xo.prototype, {
  isRoot: function() {
    return this.depth === 0;
  },
  isLeaf: function() {
    return this.children.length === 0;
  },
  addGap: function(e, t) {
    var n = this;
    n.hgap += e, n.vgap += t, n.width += 2 * e, n.height += 2 * t;
  },
  eachNode: function(e) {
    for (var t = this, n = [t], i; i = n.shift(); )
      e(i), n = i.children.concat(n);
  },
  DFTraverse: function(e) {
    this.eachNode(e);
  },
  BFTraverse: function(e) {
    for (var t = this, n = [t], i; i = n.shift(); )
      e(i), n = n.concat(i.children);
  },
  getBoundingBox: function() {
    var e = {
      left: Number.MAX_VALUE,
      top: Number.MAX_VALUE,
      width: 0,
      height: 0
    };
    return this.eachNode(function(t) {
      e.left = Math.min(e.left, t.x), e.top = Math.min(e.top, t.y), e.width = Math.max(e.width, t.x + t.width), e.height = Math.max(e.height, t.y + t.height);
    }), e;
  },
  // translate
  translate: function(e, t) {
    e === void 0 && (e = 0), t === void 0 && (t = 0), this.eachNode(function(n) {
      n.x += e, n.y += t, n.x += n.preH, n.y += n.preV;
    });
  },
  right2left: function() {
    var e = this, t = e.getBoundingBox();
    e.eachNode(function(n) {
      n.x = n.x - (n.x - t.left) * 2 - n.width;
    }), e.translate(t.width, 0);
  },
  bottom2top: function() {
    var e = this, t = e.getBoundingBox();
    e.eachNode(function(n) {
      n.y = n.y - (n.y - t.top) * 2 - n.height;
    }), e.translate(0, t.height);
  }
});
function Y3(s, e, t) {
  e === void 0 && (e = {}), e = Mg.assign({}, J3, e);
  var n = new xo(s, e), i = [n], r;
  if (!t && !s.collapsed) {
    for (; r = i.shift(); )
      if (!r.data.collapsed) {
        var o = e.getChildren(r.data), a = o ? o.length : 0;
        if (r.children = new Array(a), o && a)
          for (var l = 0; l < a; l++) {
            var c = new xo(o[l], e);
            r.children[l] = c, i.push(c), c.parent = r, c.depth = r.depth + 1;
          }
      }
  }
  return n;
}
var kg = Y3, X3 = kg, Z3 = /* @__PURE__ */ function() {
  function s(t, n) {
    n === void 0 && (n = {});
    var i = this;
    i.options = n, i.rootNode = X3(t, n);
  }
  var e = s.prototype;
  return e.execute = function() {
    throw new Error("please override this method");
  }, s;
}(), Wo = Z3;
function Ai(s, e, t, n) {
  n === void 0 && (n = []);
  var i = this;
  i.w = s || 0, i.h = e || 0, i.y = t || 0, i.x = 0, i.c = n || [], i.cs = n.length, i.prelim = 0, i.mod = 0, i.shift = 0, i.change = 0, i.tl = null, i.tr = null, i.el = null, i.er = null, i.msel = 0, i.mser = 0;
}
Ai.fromNode = function(s, e) {
  if (!s)
    return null;
  var t = [];
  return s.children.forEach(function(n) {
    t.push(Ai.fromNode(n, e));
  }), e ? new Ai(s.height, s.width, s.x, t) : new Ai(s.width, s.height, s.y, t);
};
function Pg(s, e, t) {
  t ? s.y += e : s.x += e, s.children.forEach(function(n) {
    Pg(n, e, t);
  });
}
function _g(s, e) {
  var t = e ? s.y : s.x;
  return s.children.forEach(function(n) {
    t = Math.min(_g(n, e), t);
  }), t;
}
function K3(s, e) {
  var t = _g(s, e);
  Pg(s, -t, e);
}
function Og(s, e, t) {
  t ? e.y = s.x : e.x = s.x, s.c.forEach(function(n, i) {
    Og(n, e.children[i], t);
  });
}
function Tg(s, e, t) {
  t === void 0 && (t = 0), e ? (s.x = t, t += s.width) : (s.y = t, t += s.height), s.children.forEach(function(n) {
    Tg(n, e, t);
  });
}
var Q3 = function(s, e) {
  e === void 0 && (e = {});
  var t = e.isHorizontal;
  function n(y) {
    if (y.cs === 0) {
      i(y);
      return;
    }
    n(y.c[0]);
    for (var b = w(c(y.c[0].el), 0, null), x = 1; x < y.cs; ++x) {
      n(y.c[x]);
      var C = c(y.c[x].er);
      r(y, x, b), b = w(C, x, b);
    }
    d(y), i(y);
  }
  function i(y) {
    y.cs === 0 ? (y.el = y, y.er = y, y.msel = y.mser = 0) : (y.el = y.c[0].el, y.msel = y.c[0].msel, y.er = y.c[y.cs - 1].er, y.mser = y.c[y.cs - 1].mser);
  }
  function r(y, b, x) {
    for (var C = y.c[b - 1], A = C.mod, P = y.c[b], O = P.mod; C !== null && P !== null; ) {
      c(C) > x.low && (x = x.nxt);
      var k = A + C.prelim + C.w - (O + P.prelim);
      k > 0 && (O += k, o(y, b, x.index, k));
      var D = c(C), L = c(P);
      D <= L && (C = l(C), C !== null && (A += C.mod)), D >= L && (P = a(P), P !== null && (O += P.mod));
    }
    !C && P ? u(y, b, P, O) : C && !P && f(y, b, C, A);
  }
  function o(y, b, x, C) {
    y.c[b].mod += C, y.c[b].msel += C, y.c[b].mser += C, p(y, b, x, C);
  }
  function a(y) {
    return y.cs === 0 ? y.tl : y.c[0];
  }
  function l(y) {
    return y.cs === 0 ? y.tr : y.c[y.cs - 1];
  }
  function c(y) {
    return y.y + y.h;
  }
  function u(y, b, x, C) {
    var A = y.c[0].el;
    A.tl = x;
    var P = C - x.mod - y.c[0].msel;
    A.mod += P, A.prelim -= P, y.c[0].el = y.c[b].el, y.c[0].msel = y.c[b].msel;
  }
  function f(y, b, x, C) {
    var A = y.c[b].er;
    A.tr = x;
    var P = C - x.mod - y.c[b].mser;
    A.mod += P, A.prelim -= P, y.c[b].er = y.c[b - 1].er, y.c[b].mser = y.c[b - 1].mser;
  }
  function d(y) {
    y.prelim = (y.c[0].prelim + y.c[0].mod + y.c[y.cs - 1].mod + y.c[y.cs - 1].prelim + y.c[y.cs - 1].w) / 2 - y.w / 2;
  }
  function g(y, b) {
    b += y.mod, y.x = y.prelim + b, m(y);
    for (var x = 0; x < y.cs; x++)
      g(y.c[x], b);
  }
  function p(y, b, x, C) {
    if (x !== b - 1) {
      var A = b - x;
      y.c[x + 1].shift += C / A, y.c[b].shift -= C / A, y.c[b].change -= C - C / A;
    }
  }
  function m(y) {
    for (var b = 0, x = 0, C = 0; C < y.cs; C++)
      b += y.c[C].shift, x += b + y.c[C].change, y.c[C].mod += x;
  }
  function w(y, b, x) {
    for (; x !== null && y >= x.low; )
      x = x.nxt;
    return {
      low: y,
      index: b,
      nxt: x
    };
  }
  Tg(s, t);
  var v = Ai.fromNode(s, t);
  return n(v), g(v, 0), Og(v, s, t), K3(s, t), s;
}, Fh = kg, Lg = function(s, e) {
  for (var t = Fh(s.data, e, !0), n = Fh(s.data, e, !0), i = s.children.length, r = Math.round(i / 2), o = e.getSide || function(u, f) {
    return f < r ? "right" : "left";
  }, a = 0; a < i; a++) {
    var l = s.children[a], c = o(l, a);
    c === "right" ? n.children.push(l) : t.children.push(l);
  }
  return t.eachNode(function(u) {
    u.isRoot() || (u.side = "left");
  }), n.eachNode(function(u) {
    u.isRoot() || (u.side = "right");
  }), {
    left: t,
    right: n
  };
}, e8 = Lg, wn = [
  "LR",
  // left to right
  "RL",
  // right to left
  "TB",
  // top to bottom
  "BT",
  // bottom to top
  "H",
  // horizontal
  "V"
  // vertical
], t8 = ["LR", "RL", "H"], n8 = function(e) {
  return t8.indexOf(e) > -1;
}, s8 = wn[0], cc = function(s, e, t) {
  var n = e.direction || s8;
  if (e.isHorizontal = n8(n), n && wn.indexOf(n) === -1)
    throw new TypeError("Invalid direction: " + n);
  if (n === wn[0])
    t(s, e);
  else if (n === wn[1])
    t(s, e), s.right2left();
  else if (n === wn[2])
    t(s, e);
  else if (n === wn[3])
    t(s, e), s.bottom2top();
  else if (n === wn[4] || n === wn[5]) {
    var i = e8(s, e), r = i.left, o = i.right;
    t(r, e), t(o, e), e.isHorizontal ? r.right2left() : r.bottom2top(), o.translate(r.x - o.x, r.y - o.y), s.x = r.x, s.y = o.y;
    var a = s.getBoundingBox();
    e.isHorizontal ? a.top < 0 && s.translate(0, -a.top) : a.left < 0 && s.translate(-a.left, 0);
  }
  var l = e.fixedRoot;
  return l === void 0 && (l = !0), l && s.translate(-(s.x + s.width / 2 + s.hgap), -(s.y + s.height / 2 + s.vgap)), s;
};
function i8(s, e) {
  s.prototype = Object.create(e.prototype), s.prototype.constructor = s, cl(s, e);
}
function cl(s, e) {
  return cl = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, cl(s, e);
}
var r8 = Wo, o8 = Q3, a8 = cc, l8 = Vn, c8 = /* @__PURE__ */ function(s) {
  function e() {
    return s.apply(this, arguments) || this;
  }
  i8(e, s);
  var t = e.prototype;
  return t.execute = function() {
    var i = this;
    return a8(i.rootNode, i.options, o8);
  }, e;
}(r8), h8 = {};
function u8(s, e) {
  return e = l8.assign({}, h8, e), new c8(s, e).execute();
}
var d8 = u8, f8 = Vn;
function g8(s, e) {
  e === void 0 && (e = []);
  var t = this;
  t.x = t.y = 0, t.leftChild = t.rightChild = null, t.height = 0, t.children = e;
}
var p8 = {
  isHorizontal: !0,
  nodeSep: 20,
  nodeSize: 20,
  rankSep: 200,
  subTreeSep: 10
};
function Dg(s, e, t) {
  t ? (e.x = s.x, e.y = s.y) : (e.x = s.y, e.y = s.x), s.children.forEach(function(n, i) {
    Dg(n, e.children[i], t);
  });
}
var m8 = function(s, e) {
  e === void 0 && (e = {}), e = f8.assign({}, p8, e);
  var t = 0;
  function n(l) {
    if (!l)
      return null;
    l.width = 0, l.depth && l.depth > t && (t = l.depth);
    var c = l.children, u = c.length, f = new g8(l.height, []);
    return c.forEach(function(d, g) {
      var p = n(d);
      f.children.push(p), g === 0 && (f.leftChild = p), g === u - 1 && (f.rightChild = p);
    }), f.originNode = l, f.isLeaf = l.isLeaf(), f;
  }
  function i(l) {
    if (l.isLeaf || l.children.length === 0)
      l.drawingDepth = t;
    else {
      var c = l.children.map(function(f) {
        return i(f);
      }), u = Math.min.apply(null, c);
      l.drawingDepth = u - 1;
    }
    return l.drawingDepth;
  }
  var r;
  function o(l) {
    l.x = l.drawingDepth * e.rankSep, l.isLeaf ? (l.y = 0, r && (l.y = r.y + r.height + e.nodeSep, l.originNode.parent !== r.originNode.parent && (l.y += e.subTreeSep)), r = l) : (l.children.forEach(function(c) {
      o(c);
    }), l.y = (l.leftChild.y + l.rightChild.y) / 2);
  }
  var a = n(s);
  return i(a), o(a), Dg(a, s, e.isHorizontal), s;
};
function w8(s, e) {
  s.prototype = Object.create(e.prototype), s.prototype.constructor = s, hl(s, e);
}
function hl(s, e) {
  return hl = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, hl(s, e);
}
var y8 = Wo, b8 = m8, v8 = cc, x8 = Vn, C8 = /* @__PURE__ */ function(s) {
  function e() {
    return s.apply(this, arguments) || this;
  }
  w8(e, s);
  var t = e.prototype;
  return t.execute = function() {
    var i = this;
    return i.rootNode.width = 0, v8(i.rootNode, i.options, b8);
  }, e;
}(y8), E8 = {};
function S8(s, e) {
  return e = x8.assign({}, E8, e), new C8(s, e).execute();
}
var A8 = S8, zh = Vn;
function M8(s, e, t, n, i) {
  var r = typeof t == "function" ? t(s) : t * s.depth;
  if (!n)
    try {
      if (s.id === s.parent.children[0].id) {
        s.x += r, s.y = e ? e.y : 0;
        return;
      }
    } catch (l) {
    }
  if (s.x += r, e) {
    if (s.y = e.y + zh.getHeight(e, s, i), e.parent && s.parent.id !== e.parent.id) {
      var o = e.parent, a = o.y + zh.getHeight(o, s, i);
      s.y = a > s.y ? a : s.y;
    }
  } else
    s.y = 0;
}
var k8 = function(s, e, t, n) {
  var i = null;
  s.eachNode(function(r) {
    M8(r, i, e, t, n), i = r;
  });
};
function P8(s, e) {
  s.prototype = Object.create(e.prototype), s.prototype.constructor = s, ul(s, e);
}
function ul(s, e) {
  return ul = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, ul(s, e);
}
var _8 = Wo, Rr = k8, O8 = Lg, T8 = Vn, Mi = [
  "LR",
  // left to right
  "RL",
  // right to left
  "H"
  // horizontal
], L8 = Mi[0], D8 = /* @__PURE__ */ function(s) {
  function e() {
    return s.apply(this, arguments) || this;
  }
  P8(e, s);
  var t = e.prototype;
  return t.execute = function() {
    var i = this, r = i.options, o = i.rootNode;
    r.isHorizontal = !0;
    var a = r.indent, l = a === void 0 ? 20 : a, c = r.dropCap, u = c === void 0 ? !0 : c, f = r.direction, d = f === void 0 ? L8 : f, g = r.align;
    if (d && Mi.indexOf(d) === -1)
      throw new TypeError("Invalid direction: " + d);
    if (d === Mi[0])
      Rr(o, l, u, g);
    else if (d === Mi[1])
      Rr(o, l, u, g), o.right2left();
    else if (d === Mi[2]) {
      var p = O8(o, r), m = p.left, w = p.right;
      Rr(m, l, u, g), m.right2left(), Rr(w, l, u, g);
      var v = m.getBoundingBox();
      w.translate(v.width, 0), o.x = w.x - o.width / 2;
    }
    return o;
  }, e;
}(_8), N8 = {};
function I8(s, e) {
  return e = T8.assign({}, N8, e), new D8(s, e).execute();
}
var j8 = I8, R8 = Vn;
function Ng(s, e) {
  var t = 0;
  return s.children.length ? s.children.forEach(function(n) {
    t += Ng(n, e);
  }) : t = s.height, s._subTreeSep = e.getSubTreeSep(s.data), s.totalHeight = Math.max(s.height, t) + 2 * s._subTreeSep, s.totalHeight;
}
function Ig(s) {
  var e = s.children, t = e.length;
  if (t) {
    e.forEach(function(l) {
      Ig(l);
    });
    var n = e[0], i = e[t - 1], r = i.y - n.y + i.height, o = 0;
    if (e.forEach(function(l) {
      o += l.totalHeight;
    }), r > s.height)
      s.y = n.y + r / 2 - s.height / 2;
    else if (e.length !== 1 || s.height > o) {
      var a = s.y + (s.height - r) / 2 - n.y;
      e.forEach(function(l) {
        l.translate(0, a);
      });
    } else
      s.y = (n.y + n.height / 2 + i.y + i.height / 2) / 2 - s.height / 2;
  }
}
var B8 = {
  getSubTreeSep: function() {
    return 0;
  }
}, $8 = function(s, e) {
  e === void 0 && (e = {}), e = R8.assign({}, B8, e), s.parent = {
    x: 0,
    width: 0,
    height: 0,
    y: 0
  }, s.BFTraverse(function(t) {
    t.x = t.parent.x + t.parent.width;
  }), s.parent = null, Ng(s, e), s.startY = 0, s.y = s.totalHeight / 2 - s.height / 2, s.eachNode(function(t) {
    var n = t.children, i = n.length;
    if (i) {
      var r = n[0];
      if (r.startY = t.startY + t._subTreeSep, i === 1)
        r.y = t.y + t.height / 2 - r.height / 2;
      else {
        r.y = r.startY + r.totalHeight / 2 - r.height / 2;
        for (var o = 1; o < i; o++) {
          var a = n[o];
          a.startY = n[o - 1].startY + n[o - 1].totalHeight, a.y = a.startY + a.totalHeight / 2 - a.height / 2;
        }
      }
    }
  }), Ig(s);
};
function F8(s, e) {
  s.prototype = Object.create(e.prototype), s.prototype.constructor = s, dl(s, e);
}
function dl(s, e) {
  return dl = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function(n, i) {
    return n.__proto__ = i, n;
  }, dl(s, e);
}
var z8 = Wo, V8 = $8, H8 = cc, U8 = Vn, q8 = /* @__PURE__ */ function(s) {
  function e() {
    return s.apply(this, arguments) || this;
  }
  F8(e, s);
  var t = e.prototype;
  return t.execute = function() {
    var i = this;
    return H8(i.rootNode, i.options, V8);
  }, e;
}(z8), G8 = {};
function W8(s, e) {
  return e = U8.assign({}, G8, e), new q8(s, e).execute();
}
var J8 = W8, Y8 = {
  compactBox: d8,
  dendrogram: A8,
  indented: j8,
  mindmap: J8
}, X8 = Y8;
const Z8 = /* @__PURE__ */ q3(X8);
class jg {
  constructor(e) {
    /**
     * 当前x6图形实例
     *
     * @author chitanda
     * @date 2023-11-09 18:11:46
     * @type {Graph}
     */
    E(this, "g");
    this.g = e;
  }
  /**
   * 由外部调用进行初始化(不可以重写)
   *
   * @return {*}  {Promise<void>}
   */
  init() {
    return this.onInit();
  }
  /**
   * 初始化(子类重写)
   *
   * @protected
   * @return {*}  {void}
   */
  onInit() {
  }
  /**
   * 监听消息变更
   *
   * @protected
   * @param {IPortalMessage} msg
   * @return {*}  {void}
   */
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  onMessageChange(e) {
  }
  /**
   * 销毁
   *
   * @return {*}  {void}
   */
  destroy() {
  }
  /**
   * 加载图形数据
   *
   * @return {*}  {Promise<void>}
   */
  load() {
  }
  /**
   * 初始化数据
   */
  initData(e) {
    return e && e.length ? e.map((t) => t.shape === "mind-map" ? this.getMindMap(t) : t) : [];
  }
  /**
   * 获取思维导图
   */
  getMindMap(e) {
    return Z8.mindmap(e, {
      direction: "H",
      getHeight(t) {
        return t.height;
      },
      getWidth(t) {
        return t.width;
      },
      getHGap() {
        return 40;
      },
      getVGap() {
        return 20;
      },
      getSide: () => "right"
    });
  }
}
class K8 extends jg {
  constructor(t, n, i) {
    super(t);
    E(this, "ns");
    E(this, "nodeModel", {});
    E(this, "opt", {});
    // 默认初始化数据
    E(this, "items", []);
    E(this, "nodeKey");
    // 父控制器
    E(this, "x6Ctrl");
    this.nodeModel = i, this.x6Ctrl = n, this.nodeKey = this.nodeModel.nodeKey, this.ns = this.nodeModel.ns, this.register(), this.init();
  }
  onInit() {
    super.onInit();
  }
  register() {
    const t = this, { readonly: n } = this.nodeModel;
    gs.register({
      effect: ["data"],
      ...t.opt,
      shape: "mind-map-".concat(t.nodeKey),
      html(i) {
        const r = i.getData(), o = document.createElement("div");
        if (o.className = t.ns.b("custom-html-node"), !n) {
          o.onclick = (c) => {
            t.prevent(c), t.g.emit("mind-map:click", c, r);
          }, o.ondblclick = (c) => {
            t.prevent(c), t.g.emit("mind-map:dblclick", c, r);
          };
          const l = document.createElement("div");
          l.innerHTML = '<svg t="1721380398285" class="add-node-icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="1711" width="1em" height="1em"><path d="M512 170.67c-23.56 0-42.67 19.1-42.67 42.67v256h-256c-23.56 0-42.67 19.1-42.67 42.67s19.1 42.67 42.67 42.67h256v256c0 23.56 19.1 42.67 42.67 42.67s42.67-19.1 42.67-42.67v-256h256c23.56 0 42.67-19.1 42.67-42.67s-19.1-42.67-42.67-42.67h-256v-256c0-23.57-19.11-42.67-42.67-42.67z" p-id="1712"></path></svg>', l.className = t.ns.be(
            "custom-html-node",
            "add-item-icon-box"
          ), l.onclick = (c) => {
            t.prevent(c), t.g.emit("mind-map:add-topic", c, r);
          }, o.appendChild(l);
        }
        const a = t.createReadonlyNode.bind(t)(r);
        return o.append(a), o;
      }
    }), this.g.on("mind-map:dblclick", (i, r) => {
      let { target: o } = i, { parentNode: a } = o;
      a.classList.add("is-activated");
      const l = this.createEditNode(r);
      l.onblur = (c) => {
        this.prevent(c), this.onNodeEditBlur(c, r);
      }, l.onclick = this.prevent, l.ondblclick = this.prevent, a.appendChild(l), l.focus(), l.focus(), l.setSelectionRange(0, r.label.length), o.remove(), o = null, a = null;
    }), this.g.on("mind-map:click", (i) => {
      i.target.parentNode.classList.add(
        "is-activated"
      );
    });
  }
  /**
   * 加载
   */
  load() {
    const t = this.x6Ctrl.getData();
    this.items = this.initData(t), this.g.addNodes(this.addNodes(this.items));
  }
  /**
   * 新增节点数据
   */
  addNodes(t) {
    const n = [];
    return t.forEach((i) => {
      i.data && i.data.shape === "mind-map" ? this.createMindMapCell(i).forEach((o) => {
        n.push(o);
      }) : n.push(i);
    }), n;
  }
  // 创建思维导图项
  createMindMapCell(t) {
    const n = [];
    if (t) {
      const { children: i } = t;
      n.push(this.getMindMapCellItem(t)), i && (i != null && i.length) && i.forEach((r) => {
        n.push(...this.createMindMapCell(r));
      });
    }
    return n;
  }
  // 获取思维导图cell项
  getMindMapCellItem(t) {
    const { data: n } = t;
    return {
      id: n.id,
      shape: "mind-map-".concat(this.nodeKey),
      x: t.x,
      y: t.y,
      width: n.width,
      height: n.height,
      label: n.label,
      type: n.type,
      data: n,
      attrs: {
        body: {
          strokeWidth: 1,
          fill: "#fff",
          rx: 6,
          ry: 6
        }
      }
    };
  }
  // 获取样式
  getStyle(t, n) {
    return {
      width: "".concat(t, "px"),
      height: "".concat(n, "px"),
      lineHeight: "".concat(n, "px")
    };
  }
  // 创建只读节点
  createReadonlyNode(t) {
    const { label: n, width: i, height: r } = t, o = this.getStyle(i, r), a = document.createElement("div");
    return a.className = this.ns.be("custom-html-node", "readonly-node"), Object.assign(a.style, { ...o }), a.textContent = n, "".concat(n).length > 5 && (a.title = n), a;
  }
  // 创建编辑节点
  createEditNode(t) {
    const n = document.createElement("input");
    return n.setAttribute("value", t.label), n.setAttribute("type", "text"), Object.assign(n.style, {
      ...this.getStyle(t.width, t.height),
      textAlign: "center",
      lineHeight: "100%"
    }), n.className = this.ns.be("custom-html-node", "edit-node"), n;
  }
  // 处理单个节点编辑完成后失焦
  onNodeEditBlur(t, n) {
    const i = t.target, r = i.value || "", o = i.parentNode;
    i.remove();
    const a = this.createReadonlyNode(n);
    a.textContent = r, this.g.emit("mind-map:blur", t, n, r), o.appendChild(a);
  }
  // 阻止事件
  prevent(t) {
    t.stopPropagation(), t.preventDefault();
  }
}
class Q8 extends jg {
  constructor(t, n, i = {}) {
    super(t);
    /**
     * 连线模型
     */
    E(this, "linkModel", {});
    /**
     * 连线配置参数
     */
    E(this, "opt", {
      inherit: "edge"
    });
    /**
     * 默认初始化数据
     */
    E(this, "items", []);
    /**
     * 父控制器
     */
    E(this, "x6Ctrl");
    this.linkModel = i, this.x6Ctrl = n, this.register();
  }
  onInit() {
    super.onInit();
  }
  register() {
    Ye.registerEdge(
      "mind-map-edge",
      {
        connector: {
          name: "mind-map"
        },
        attrs: {
          line: {
            targetMarker: "",
            stroke: "var(--ibiz-color-primary)",
            strokeWidth: 2
          }
        },
        zIndex: 0,
        ...this.opt
      },
      !0
    ), Ye.registerConnector("mind-map-connector", this.MindMapConnector, !0);
  }
  // 思维导图连接器计算
  MindMapConnector(t, n) {
    const i = Math.abs(n.x - t.x), r = new F();
    r.appendSegment(F.createSegment("M", t.x, t.y)), r.appendSegment(F.createSegment("L", t.x, t.y));
    const o = t.x < n.x ? t.x + i / 2 : t.x - i / 2, a = t.y, l = t.x < n.x ? n.x - i / 2 : n.x + i / 2, c = n.y;
    return r.appendSegment(
      F.createSegment("C", o, a, l, c, n.x, n.y)
    ), r.serialize();
  }
  load() {
    const t = this.x6Ctrl.getData();
    this.items = this.initData(t);
    const n = this.addEdges(this.items);
    this.g.addEdges(n);
  }
  /**
   * 新增节点数据
   */
  addEdges(t) {
    const n = [];
    return t.forEach((i) => {
      i.data && i.data.shape === "mind-map" ? i.children && i.children.length && n.push(...this.handleMindMap(i)) : n.push(i);
    }), n;
  }
  handleMindMap(t) {
    const n = [];
    return t && t.children && t.children.forEach((i) => {
      n.push(this.createMinMapCell(i, t)), i.children && i.children && n.push(...this.handleMindMap(i));
    }), n;
  }
  createMinMapCell(t, n) {
    if (t.data && t.data.shape === "mind-map") {
      const { id: i } = t;
      return {
        shape: "mind-map-edge",
        source: {
          cell: n.id,
          anchor: {
            name: "right",
            args: {
              dx: 0
            }
          }
        },
        target: {
          cell: i,
          anchor: {
            name: "left"
          }
        },
        connector: {
          name: "mind-map-connector"
          // 使用自定义连接器
        },
        data: t
      };
    }
    return t;
  }
}
class e5 {
  /**
   * Creates an instance of X6Controller.
   * @param {IPanelController} panel
   * @param {HTMLElement} dom
   * @param {X6Options} [defaultParams={}]
   */
  constructor(e, t = {}, n = {}) {
    /**
     * 事件触发器
     * @author lxm
     * @date 2023-04-25 09:36:31
     * @type {ControllerEvent}
     */
    E(this, "evt", new Jh(
      this.getEventArgs.bind(this)
    ));
    /**
     * 当前x6图形实例
     *
     * @type {IParams}
     */
    E(this, "g");
    /**
     * 节点控制器
     *
     * @type {X6NodeController}
     */
    E(this, "node");
    /**
     * 连线适控制器
     *
     * @type {X6LinkController}
     */
    E(this, "link");
    /**
     * 默认配置参数
     */
    E(this, "defaultParams");
    // 备份数据
    E(this, "backupData", []);
    // 选中数据
    E(this, "selection", []);
    /**
     * 初始化聚焦
     */
    E(this, "internalFocus", !1);
    // 默认初始化数据
    E(this, "defaultData", []);
    /**
     * x6图形配置
     *
     * @protected
     * @type {IParams}
     */
    E(this, "graphOptions", {
      connecting: {
        // 表示使用节点或图形元素上定义的锚点作为连接点
        connectionPoint: "anchor"
      },
      interacting: {
        // 禁止拖动
        nodeMovable: !1
      },
      // 平移
      panning: !0
    });
    this.defaultParams = n, this.defaultData = n.defaultData, this.backupData = Sr(this.defaultData), Object.assign(this.graphOptions, t), this.graphOptions.container = e, this.graphOptions.mousewheel = {
      enabled: !0,
      global: !0,
      modifiers: ["ctrl", "meta"],
      zoomAtMousePosition: !0,
      guard(i) {
        var r, o;
        return ((o = (r = i.target) == null ? void 0 : r.parentNode) == null ? void 0 : o.id) === "diagram-".concat(n.nodeKey);
      }
    }, this.g = new Ye(this.graphOptions), this.link = new Q8(this.g, this, {}), this.node = new K8(this.g, this, {
      nodeKey: this.defaultParams.nodeKey,
      ns: this.defaultParams.ns,
      readonly: this.defaultParams.readonly
    }), this.defaultParams.readonly || this.g.disablePanning(), this.init();
  }
  /**
   * 获取事件的基础参数
   * @author lxm
   * @date 2023-04-25 11:03:44
   * @return {*}  {Omit<EventBase, 'eventName'>}
   */
  getEventArgs() {
    return {
      context: {},
      params: {},
      data: [],
      targetName: "",
      view: {}
    };
  }
  /**
   * 初始化
   */
  init() {
    this.initEvents(), this.load();
  }
  /**
   * 初始化事件
   */
  initEvents() {
    this.g.on("mind-map:add-topic", (e, t) => {
      const { id: n } = t;
      this.addChildNode(n) && this.refresh();
    }), this.g.on("mind-map:click", (e, t) => {
      this.clearSelection(), this.selection = [{ data: t, node: e.target.parentNode }], e.target.parentNode.classList.add(
        "is-activated"
      ), this.internalFocus = !0;
    }), this.g.on(
      "mind-map:blur",
      (e, t, n) => {
        this.updateNode(t.id, n || "") || this.refresh(), this.internalFocus = !1, this.evt.emit("onNodeBlur", void 0);
      }
    );
  }
  /**
   * 清除选中
   */
  clearSelection() {
    this.selection && this.selection.length > 0 && (this.selection[0].node.classList.remove("is-activated"), this.selection[0].node = null, this.selection = []);
  }
  /**
   * 新增子节点
   */
  addChildNode(e) {
    const t = this.findItem(this.backupData, e), n = t == null ? void 0 : t.node;
    if (n) {
      const i = n.children ? n.children.length : 0, r = {
        id: "".concat(e, "-").concat(i + 1),
        type: "topic-child",
        shape: "mind-map",
        label: "",
        width: 120,
        height: 30
      };
      if (r)
        return n.children ? n.children.push(r) : Object.assign(n, { children: [r] }), this.defaultData = Sr(this.backupData), r;
    }
    return null;
  }
  /**
   * 更新节点
   */
  updateNode(e, t) {
    const n = this.findItem(this.backupData, e), i = n == null ? void 0 : n.parent;
    if (i && i.children) {
      const { children: r } = i, o = r.findIndex((a) => a.id === e);
      return r[o].label = t, this.defaultData = Sr(this.backupData), !0;
    }
    return !1;
  }
  // 遍历item
  findItem(e, t) {
    let n = null;
    return e && e.length && e.forEach((i) => {
      if (i.id === t && (n = {
        parent: null,
        node: i
      }), i.children && i.children) {
        const r = this.findItem(i.children, t);
        r && (n = {
          parent: r.parent || i,
          node: r.node
        });
      }
    }), n;
  }
  /**
   * 删除节点
   */
  removeNode(e) {
    const t = this.findItem(this.backupData, e), n = t == null ? void 0 : t.parent;
    if (n && n.children) {
      const { children: i } = n, r = i.findIndex((o) => o.id === e);
      return i.splice(r, 1), this.defaultData = Sr(this.backupData), !0;
    }
    return !1;
  }
  /**
   * 改变是否可平移状态
   */
  togglePanning() {
    this.g.togglePanning();
  }
  /**
   * 禁用平移
   */
  disablePanning() {
    this.g.disablePanning();
  }
  /**
   * 初始化
   */
  getData() {
    return this.defaultData;
  }
  /**
   * 加载
   */
  async load() {
    this.node.load(), this.link.load(), this.g.centerContent();
  }
  /**
   * 刷新
   */
  async refresh() {
    this.g.clearCells({ refresh: !0 }), await this.load();
  }
  /**
   * 销毁
   */
  destroy() {
    this.g.dispose(), this.node.destroy(), this.link.destroy();
  }
}
const t5 = /* @__PURE__ */ me({
  name: "IBizDiagramBoard",
  props: fi(),
  emits: ["change"],
  setup(s) {
    const e = we("diagram-board"), t = T(), n = T(), i = T(!1), r = T();
    r.value = jy();
    let o, a = Iy();
    if (s.data) {
      const {
        data: v
      } = s.data;
      a = v;
    }
    const l = async () => {
      o == null || o.destroy();
    }, c = () => {
      var b;
      s.isFocus && ((b = t.value) == null || b.focus());
      const {
        offsetWidth: v,
        offsetHeight: y
      } = t.value;
      o = new e5(n.value, {
        width: v,
        height: y
      }, {
        ns: e,
        nodeKey: s.nodeKey,
        readonly: s.readonly,
        defaultData: a
      }), o.evt.on("onNodeBlur", () => {
        s.change({
          data: o == null ? void 0 : o.defaultData
        }, {
          isUpdate: !0
        });
      });
    }, u = () => {
      l(), o.internalFocus = !0, s.change("", {
        isDelete: !0
      });
    }, f = (v) => {
      switch (v.type) {
        case "delete":
          u();
          break;
        case "panning":
          o.togglePanning();
          break;
      }
    }, d = () => M("div", {
      class: e.b("top-tool-bar")
    }, [r.value.map((v) => M("div", {
      class: [e.be("top-tool-bar", "item"), e.be("top-tool-bar", "item-".concat(v.type))],
      title: v.text,
      onClick: () => f(v)
    }, [M("div", {
      class: e.bem("top-tool-bar", "item", "content"),
      innerHTML: v.icon || v.text
    }, null)]))]), g = async () => {
      i.value || (i.value = !0);
    }, p = () => {
      if (o) {
        if (o.clearSelection(), o.internalFocus)
          return;
        s.change({
          data: o == null ? void 0 : o.defaultData
        }), i.value = !1;
      }
    }, m = this;
    let w = new ResizeObserver(() => {
      t.value && t.value.offsetWidth !== 0 && (c.bind(m)(), w.disconnect(), w = null);
    });
    return hn(() => {
      n.value && (w.observe(n.value), t.value.addEventListener("click", () => {
        var v;
        o.clearSelection(), (v = t.value) == null || v.focus();
      }), t.value.addEventListener("keydown", (v) => {
        o.internalFocus = !1, (v.key === "Backspace" || v.key === "Delete") && o && o.selection && o.selection.length > 0 && o.removeNode(o.selection[0].data.id) && (o.clearSelection(), o.refresh());
      }));
    }), or(() => {
      l();
    }), {
      ns: e,
      diagramRef: n,
      diagramBoxRef: t,
      diagramBoxActivate: i,
      onFocus: g,
      onBlur: p,
      renderTopToolBar: d
    };
  },
  render() {
    return M("div", {
      ref: "diagramBoxRef",
      class: [this.ns.b(), this.readonly ? this.ns.m("readonly") : "", this.ns.is("activated", this.diagramBoxActivate)],
      tabindex: "0",
      onFocus: this.onFocus,
      onBlur: this.onBlur
    }, [!this.readonly && this.diagramBoxActivate ? this.renderTopToolBar() : "", M("div", {
      id: "diagram-".concat(this.nodeKey),
      ref: "diagramRef"
    }, null)]);
  }
});
const n5 = (s, e) => {
  if (s === 0 || e === 0)
    return 0;
  let t = s / e * 100;
  return t < 0 ? t = 0 : t > 100 && (t = 100), t;
}, s5 = /* @__PURE__ */ me({
  name: "IBizAudio",
  props: fi(),
  setup(s) {
    const e = we("audio"), t = T(""), n = T(0), i = T("");
    if (s.data) {
      const {
        name: O,
        size: k,
        url: D
      } = s.data;
      t.value = O, n.value = k, i.value = D;
    }
    const r = T(!1), o = T("00:00"), a = T("00:00"), l = T(), c = T(), u = T(), f = T(0), d = T(0), g = T(0), p = Ge(() => {
      const O = n.value <= 0 ? 0 : Math.round(n.value / 1048576 * 10) / 10;
      return "".concat(O, " MB");
    }), m = () => {
      if (l.value) {
        f.value = l.value.duration, Number.isNaN(f.value) && (f.value = 0);
        const O = parseInt((f.value / 60).toString(), 10);
        let k = O.toString();
        O < 10 && (k = "0".concat(O.toString()));
        const D = Math.round(f.value % 60);
        let L = D.toString();
        D < 10 && (L = "0".concat(D.toString())), a.value = "".concat(k, ":").concat(L);
      }
    }, w = () => {
      d.value = l.value.currentTime;
      const O = Math.floor(d.value), k = parseInt((O / 60).toString(), 10);
      let D = k.toString();
      k < 10 && (D = "0".concat(k.toString()));
      const L = Math.round(O % 60);
      let B = L.toString();
      L < 10 && (B = "0".concat(L.toString())), o.value = "".concat(D, ":").concat(B), a.value === "00:00" && m();
    }, v = () => {
      r.value = !1, l.value.load(), o.value = "00:00";
    }, y = () => {
      l.value.addEventListener("timeupdate", () => {
        w(), l.value && (g.value = n5(d.value, f.value));
      }, !1), l.value.addEventListener("ended", () => {
        v();
      }), l.value.oncanplaythrough = () => {
        m();
      };
    }, b = () => {
      l.value.paused ? (l.value.play(), r.value = !0) : (l.value.pause(), r.value = !1);
    }, x = (O) => {
    };
    return hn(() => {
      l.value && y();
    }), {
      ns: e,
      realAudioTime: o,
      totalAudioTime: a,
      isPlay: r,
      audioRef: l,
      bar: c,
      slid: u,
      percentage: g,
      fileName: t,
      fileSizeText: p,
      audioSrc: i,
      play: b,
      renderStop: () => M("svg", {
        class: "icon",
        viewBox: "0 0 1024 1024",
        version: "1.1",
        xmlns: "http:// www.w3.org/2000/svg",
        "p-id": "3144",
        width: "1em",
        height: "1em"
      }, [M("path", {
        d: "M209.645253 863.934444l201.049992 0 0-703.866842L209.645253 160.067602 209.645253 863.934444zM611.804588 863.934444l201.113437 0 0-703.866842L611.804588 160.067602 611.804588 863.934444z",
        "p-id": "3145"
      }, null)]),
      renderArrowSvg: () => M("svg", {
        class: "icon",
        viewBox: "0 0 1024 1024",
        version: "1.1",
        xmlns: "http:// www.w3.org/2000/svg",
        "p-id": "2304",
        width: "1em",
        height: "1em"
      }, [M("path", {
        d: "M768 512 256 0 256 1024Z",
        "p-id": "2305"
      }, null)]),
      renderAudioSvg: () => M("svg", {
        class: "icon audio-icon",
        viewBox: "0 0 1092 1024",
        version: "1.1",
        xmlns: "http://www.w3.org/2000/svg",
        "p-id": "4287",
        width: "1em",
        height: "1em"
      }, [M("path", {
        d: "M394.24 429.056v378.368c0 83.456-67.584 150.528-150.528 150.528-83.456 0-150.528-67.584-150.528-150.528 0-83.456 67.584-150.528 150.528-150.528 25.6 0 49.152 6.144 70.144 17.408V395.776 194.048c0-19.456 13.824-36.352 33.28-39.424l550.4-95.232c24.576-4.096 47.104 14.848 47.104 39.424v611.84c0 83.456-67.584 150.528-150.528 150.528-83.456 0-150.528-67.584-150.528-150.528 0-83.456 67.584-150.528 150.528-150.528 25.6 0 49.152 6.144 70.144 17.408V347.648L394.24 429.056z m0-81.408L864.256 266.24V146.432L394.24 228.352v119.296zM243.2 877.568c38.912 0 70.144-31.744 70.144-70.144 0-38.912-31.744-70.144-70.144-70.144s-70.144 31.744-70.144 70.144c0 38.4 31.744 70.144 70.144 70.144z m550.912-96.256c38.912 0 70.144-31.744 70.144-70.144 0-38.912-31.744-70.144-70.144-70.144-38.912 0-70.144 31.744-70.144 70.144 0 38.4 31.232 70.144 70.144 70.144z",
        "p-id": "4288"
      }, null)]),
      onSliderChange: x
    };
  },
  render() {
    const s = M("div", {
      class: [this.ns.e("content")],
      ref: "componentRef"
    }, [M("div", {
      class: this.ns.e("left")
    }, [M("div", {
      class: [this.ns.e("play"), this.ns.is("active", this.isPlay)],
      onClick: () => this.play()
    }, [this.isPlay ? this.renderStop() : this.renderArrowSvg()])]), M("div", {
      class: this.ns.e("wrapper")
    }, [M("div", {
      class: this.ns.em("wrapper", "top")
    }, [M("span", null, [this.fileName]), M("span", {
      class: this.ns.em("wrapper", "file-size")
    }, [this.fileSizeText])]), M("div", {
      class: this.ns.em("wrapper", "time-bar")
    }, [M("div", {
      class: this.ns.em("wrapper", "time")
    }, [this.realAudioTime]), M("div", {
      class: this.ns.em("wrapper", "slider")
    }, [M(Ie("el-slider"), {
      modelValue: this.percentage,
      "onUpdate:modelValue": (e) => this.percentage = e,
      max: 100,
      min: 0,
      disabled: !0,
      onChange: this.onSliderChange
    }, null)]), M("div", {
      class: this.ns.em("wrapper", "time")
    }, [this.totalAudioTime])])]), M("audio", {
      ref: "audioRef",
      src: this.audioSrc
    }, null)]);
    return M("div", {
      ref: "audio",
      class: [this.ns.b(), this.disabled ? this.ns.m("disabled") : "", this.readonly ? this.ns.m("readonly") : ""]
    }, [s]);
  }
});
const i5 = /* @__PURE__ */ me({
  name: "IBizLayoutToolBar",
  props: {
    modal: {
      type: Object,
      required: !0
    }
  },
  setup(s) {
    const e = we("layout-toolbar"), t = [{
      type: "delete",
      text: "删除",
      icon: "<svg viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em'> <g stroke-width='1' fill-rule='evenodd'> <path d='M4.002 3.403V1a1 1 0 0 1 1-1h6.003a1 1 0 0 1 1 1v2.403h3.396a.6.6 0 1 1 0 1.2h-1.395V15a1 1 0 0 1-1 1H3a1 1 0 0 1-1-1V4.603H.6a.6.6 0 1 1 0-1.2h3.4zm8.804 1.205H3.2V14.8h9.605V4.608zM5.202 1.2v2.155h5.603V1.2H5.202zm.6 6.417a.6.6 0 0 1 1.201 0v4.758a.6.6 0 0 1-1.2 0V7.617zm3.202 0a.6.6 0 0 1 1.2 0v4.758a.6.6 0 0 1-1.2 0V7.617z'></path> </g></svg>"
    }], n = async () => {
      var o;
      if (s.modal) {
        const a = {
          ok: !0,
          data: [{
            value: "",
            params: {
              isDelete: !0
            }
          }]
        };
        (o = s.modal) == null || o.dismiss(a);
      }
    }, i = (o) => {
      if (o.type !== "separator")
        switch (o.type) {
          case "delete":
            n();
            break;
        }
    };
    return {
      ns: e,
      renderToolBar: () => M("div", {
        class: e.e("content")
      }, [t.map((o) => M("div", {
        class: [e.e("tool-item"), e.e("tool-item-".concat(o.type))],
        title: o.text,
        onClick: () => i(o)
      }, [M("div", {
        class: e.em("tool-item", "content"),
        innerHTML: o.icon || o.text
      }, null)]))])
    };
  },
  render() {
    return M("div", {
      class: [this.ns.b()]
    }, [this.renderToolBar()]);
  }
});
class r5 extends HTMLElement {
  constructor() {
    super(...arguments);
    E(this, "vueAppKey", rt());
    E(this, "vueApp");
  }
  // 监听的 attr
  static get observedAttributes() {
    return ["data-value"];
  }
  // 自定义元素从页面中移除
  disconnectedCallback() {
    var t;
    (t = this.vueApp) == null || t.unmount(), Ro(this.vueAppKey);
  }
  async attributeChangedCallback(t, n, i) {
    var r;
    if (t === "data-value") {
      if (i && n === i)
        return;
      const o = JSON.parse(i), { type: a, value: l, params: c = {} } = o, { readonly: u, isAdd: f } = c, d = (p) => {
        const m = new CustomEvent("dateElemEvent", {
          detail: { type: a, value: p },
          bubbles: !0,
          // 事件是否冒泡
          composed: !0
          // 事件是否能够穿过 shadow DOM 边界
        });
        this.dispatchEvent(m);
      };
      (r = this.vueApp) == null || r.unmount(), this.vueApp = ai(Y2, {
        data: l,
        nodeKey: this.vueAppKey,
        isFocus: !!f,
        readonly: !!u,
        change: (p) => d(p)
      }), this.innerHTML = "";
      const g = document.createElement("span");
      g.classList.add("elem-box"), g.part.add("container"), this.vueApp.use(Qh, {
        locale: J2
      }), this.vueApp.mount(g), this.appendChild(g);
    }
  }
}
class o5 extends HTMLElement {
  constructor() {
    super(...arguments);
    E(this, "vueAppKey", rt());
    E(this, "vueApp");
  }
  // 监听的 attr
  static get observedAttributes() {
    return ["data-value"];
  }
  // 自定义元素从页面中移除
  disconnectedCallback() {
    var t;
    (t = this.vueApp) == null || t.unmount(), Ro(this.vueAppKey);
  }
  async attributeChangedCallback(t, n, i) {
    var r;
    if (t === "data-value") {
      if (i && n === i)
        return;
      const o = JSON.parse(i), { type: a, value: l, params: c = {} } = o, { readonly: u, isAdd: f } = c, d = (p, m) => {
        const w = new CustomEvent("labelElemEvent", {
          detail: { type: a, value: p, params: m },
          bubbles: !0,
          // 事件是否冒泡
          composed: !0
          // 事件是否能够穿过 shadow DOM 边界
        });
        this.dispatchEvent(w);
      };
      (r = this.vueApp) == null || r.unmount(), this.vueApp = ai(X2, {
        data: l,
        nodeKey: this.vueAppKey,
        isFocus: !!f,
        readonly: !!u,
        change: (p, m) => d(p, m)
      }), this.innerHTML = "";
      const g = document.createElement("span");
      g.classList.add("elem-box"), g.part.add("container"), this.vueApp.use(Qh), this.vueApp.mount(g), this.appendChild(g);
    }
  }
}
class a5 extends HTMLElement {
  constructor() {
    super(...arguments);
    E(this, "vueAppKey", rt());
    E(this, "vueApp");
  }
  // 监听的 attr
  static get observedAttributes() {
    return ["data-value"];
  }
  // 自定义元素从页面中移除
  disconnectedCallback() {
    var t;
    (t = this.vueApp) == null || t.unmount();
  }
  async attributeChangedCallback(t, n, i) {
    var r;
    if (t === "data-value") {
      if (i && n === i)
        return;
      const o = JSON.parse(i), { type: a, value: l, params: c = {} } = o, { readonly: u, isAdd: f } = c, d = (p, m) => {
        const w = new CustomEvent("promptBoxElemEvent", {
          detail: { type: a, value: p, params: m },
          bubbles: !0,
          // 事件是否冒泡
          composed: !0
          // 事件是否能够穿过 shadow DOM 边界
        });
        this.dispatchEvent(w);
      };
      (r = this.vueApp) == null || r.unmount(), this.innerHTML = "", this.vueApp = ai(ty, {
        data: l,
        nodeKey: this.vueAppKey,
        isFocus: !!f,
        readonly: !!u,
        change: (p, m) => d(p, m)
      });
      const g = document.createElement("span");
      g.classList.add("elem-box"), g.part.add("container"), this.vueApp.component(uc.name, uc), this.vueApp.mount(g), this.appendChild(g);
    }
  }
}
class l5 extends HTMLElement {
  constructor() {
    super(...arguments);
    E(this, "vueAppKey", rt());
    E(this, "vueApp");
  }
  // 监听的 attr
  static get observedAttributes() {
    return ["data-value"];
  }
  // 自定义元素从页面中移除
  disconnectedCallback() {
    var t;
    (t = this.vueApp) == null || t.unmount();
  }
  async attributeChangedCallback(t, n, i) {
    var r;
    if (t === "data-value") {
      if (i && n === i)
        return;
      const o = JSON.parse(i), { type: a, value: l, params: c = {} } = o, { isUpdate: u, readonly: f, isAdd: d } = c, g = (m, w) => {
        const v = new CustomEvent("mindMapElemEvent", {
          detail: { type: a, value: m, params: w },
          bubbles: !0,
          // 事件是否冒泡
          composed: !0
          // 事件是否能够穿过 shadow DOM 边界
        });
        this.dispatchEvent(v);
      };
      (r = this.vueApp) == null || r.unmount(), this.vueApp = ai(t5, {
        data: l,
        nodeKey: this.vueAppKey,
        isFocus: !!d || !!u,
        readonly: !!f,
        change: (m, w) => g(m, w)
      }), this.innerHTML = "";
      const p = document.createElement("span");
      p.classList.add("elem-box"), p.part.add("container"), this.vueApp.mount(p), this.appendChild(p);
    }
  }
}
class c5 extends HTMLElement {
  constructor() {
    super(...arguments);
    E(this, "vueAppKey", rt());
    E(this, "vueApp");
  }
  // 监听的 attr
  static get observedAttributes() {
    return ["data-value"];
  }
  // 自定义元素从页面中移除
  disconnectedCallback() {
    var t;
    (t = this.vueApp) == null || t.unmount();
  }
  async attributeChangedCallback(t, n, i) {
    var r;
    if (t === "data-value") {
      if (i && n === i)
        return;
      const o = JSON.parse(i), { type: a, value: l, params: c = {} } = o, { readonly: u, isAdd: f } = c, d = (p) => {
        const m = new CustomEvent("audioElemEvent", {
          detail: { type: a, value: p },
          bubbles: !0,
          // 事件是否冒泡
          composed: !0
          // 事件是否能够穿过 shadow DOM 边界
        });
        this.dispatchEvent(m);
      };
      (r = this.vueApp) == null || r.unmount(), this.innerHTML = "", this.vueApp = ai(s5, {
        data: l,
        nodeKey: this.vueAppKey,
        isFocus: !!f,
        readonly: !!u,
        change: (p) => d(p)
      });
      const g = document.createElement("span");
      g.classList.add("elem-box"), g.part.add("container"), this.vueApp.component(dc.name, dc), this.vueApp.mount(g), this.appendChild(g);
    }
  }
}
class h5 extends HTMLElement {
  constructor() {
    super(...arguments);
    E(this, "vueAppKey", rt());
    E(this, "vueApp");
  }
  // 监听的 attr
  static get observedAttributes() {
    return ["data-value"];
  }
  // 自定义元素从页面中移除
  disconnectedCallback() {
    var t;
    (t = this.vueApp) == null || t.unmount(), Ro(this.vueAppKey);
  }
  async attributeChangedCallback(t, n, i) {
    var r;
    if (t === "data-value") {
      if (i && n === i)
        return;
      const o = JSON.parse(i), { type: a, value: l, params: c = {} } = o, { readonly: u, isAdd: f } = c, d = (p, m) => {
        const w = new CustomEvent("formulaElemEvent", {
          detail: { type: a, value: p, params: m },
          bubbles: !0,
          // 事件是否冒泡
          composed: !0
          // 事件是否能够穿过 shadow DOM 边界
        });
        this.dispatchEvent(w);
      };
      (r = this.vueApp) == null || r.unmount(), this.vueApp = ai(Ny, {
        data: l,
        nodeKey: this.vueAppKey,
        isFocus: !!f,
        readonly: !!u,
        change: (p, m) => d(p, m)
      }), this.innerHTML = "";
      const g = document.createElement("span");
      g.classList.add("elem-box"), g.part.add("container"), this.vueApp.component(fc.name, fc), this.vueApp.mount(g), this.appendChild(g);
    }
  }
}
class u5 extends HTMLElement {
  // eslint-disable-next-line no-useless-constructor, no-empty-function
  constructor() {
    super();
    /**
     * 是否只读
     */
    E(this, "readonly", !1);
    /**
     * 弹框
     */
    E(this, "overlay");
  }
  // 监听的 attr
  static get observedAttributes() {
    return ["data-value"];
  }
  // 处理鼠标按下
  handleMousedown(t) {
    t.button === 0 && this.classList.remove("is-activated");
  }
  // 元素创建
  connectedCallback() {
    if (this.classList.add("layout-elem"), this.readonly)
      return;
    const t = this, n = (r, o) => {
      const a = new CustomEvent("labelElemEvent", {
        detail: { type: "insert-layout", value: r, params: o },
        bubbles: !0,
        // 事件是否冒泡
        composed: !0
        // 事件是否能够穿过 shadow DOM 边界
      });
      this.dispatchEvent(a);
    }, i = async (r) => {
      t.overlay = Ds(i5, {
        placement: "top-start"
      }), await t.overlay.present(r);
      const o = await t.overlay.onWillDismiss();
      if (o.ok && o.data && o.data.length > 0) {
        const { value: a, params: l } = o.data[0];
        n(a, l);
      }
      t.overlay = null;
    };
    this.onclick = (r) => {
      var o;
      ((o = "".concat(r.target.nodeName)) == null ? void 0 : o.toLocaleLowerCase()) === "layout-elem" && !r.target.classList.contains("is-activated") && (r.target.classList.add("is-activated"), i(r.target));
    }, document.addEventListener("mousedown", this.handleMousedown.bind(this));
  }
  // 自定义元素从页面中移除
  disconnectedCallback() {
    this.overlay && (this.overlay.dismiss(), this.overlay = null), document.removeEventListener("mousedown", this.handleMousedown.bind(this));
  }
  async attributeChangedCallback(t, n, i) {
    if (t === "data-value") {
      if (i && n === i)
        return;
      const r = JSON.parse(i), { params: o = {} } = r, { readonly: a } = o;
      this.readonly = !!a;
    }
  }
}
class d5 extends HTMLElement {
  // eslint-disable-next-line no-useless-constructor, no-empty-function
  constructor() {
    super();
    E(this, "vueAppKey", rt());
    E(this, "vueApp");
  }
  // 监听的 attr
  static get observedAttributes() {
    return ["data-value"];
  }
  connectedCallback() {
    this.classList.add("layout-column-elem");
  }
  // 自定义元素从页面中移除
  disconnectedCallback() {
    var t;
    (t = this.vueApp) == null || t.unmount(), Ro(this.vueAppKey);
  }
  async attributeChangedCallback(t, n, i) {
  }
}
class f5 {
  /**
   * Creates an instance of MarkerController.
   * @param {IData} option
   * @memberof MarkerController
   */
  constructor() {
    /**
     * 模型
     *
     * @type {IEditor}
     * @memberof MarkerController
     */
    E(this, "model");
    /**
     * 上下文
     *
     * @type {IContext}
     */
    E(this, "context");
    /**
     * 视图参数
     *
     * @type {IParams}
     */
    E(this, "params");
    /**
     * 表单数据
     *
     * @type {IData}
     * @memberof MarkerController
     */
    E(this, "data", {});
    /**
     * 编辑器示例
     *
     * @type {IDomEditor}
     * @memberof MarkerController
     */
    E(this, "editor");
    /**
     * 引用请求url
     *
     * @type {string}
     * @memberof MarkerController
     */
    E(this, "quoteUrl", "");
    /**
     * 人员UI转化
     */
    E(this, "quoteFieldMap", {
      id: "id",
      name: "name"
    });
    /**
     * 代码表map
     *
     * @type {IData}
     * @memberof MarkerController
     */
    E(this, "quoteCodelistMap", /* @__PURE__ */ new Map());
    /**
     * 请求方法
     *
     * @type {('post' | 'get')}
     * @memberof MarkerController
     */
    E(this, "quoteMethod", "post");
    /**
     * 请求参数
     *
     * @type {IData}
     * @memberof MarkerController
     */
    E(this, "quoteParams", {});
    /**
     * 转换脚本
     *
     * @type {string}
     * @memberof MenTionController
     */
    E(this, "quoteScript", "`#{id=${data.id},name=${data.name},identifier=${data.identifier},icon=${data.icon}}`");
    /**
     * 逆转换脚本
     *
     * @type {string}
     * @memberof MenTionController
     */
    E(this, "quoteInScript", "value.replaceAll(/#{id=(.+?),name=(.+?),identifier=(.+?),icon=((.|[\\t\\r\\f\\n\\s])+?)}/g,(x, id, name, identifier, icon) => {return controller.getNodeInfo({ id, name, identifier, icon })})");
    /**
     * 编辑器参数
     *
     * @type {IData}
     * @memberof MarkerController
     */
    E(this, "editorParams");
    /**
     * 用户数据
     *
     * @type {IData[]}
     * @memberof MarkerController
     */
    E(this, "items", []);
    /**
     * 气泡容器
     *
     * @type {IOverlayPopoverContainer}
     * @memberof MarkerController
     */
    E(this, "overlay", null);
    /**
     * 编辑器事件
     *
     * @type {ControllerEvent<commentEvent>}
     * @memberof MarkerController
     */
    E(this, "evt");
    /**
     * 是否正在执行
     *
     * @private
     * @type {boolean}
     * @memberof MarkerController
     */
    E(this, "execting", !1);
    /**
     * 搜索字段
     *
     * @type {string}
     * @memberof MarkerController
     */
    E(this, "query", "");
    /**
     * 当前页
     *
     * @type {number}
     * @memberof MarkerController
     */
    E(this, "curPage", 0);
    /**
     * 分页条数
     *
     * @type {number}
     * @memberof MarkerController
     */
    E(this, "size", 20);
    /**
     * 预定义阻止捕获事件code
     *
     * @type {number[]}
     * @memberof MarkerController
     */
    E(this, "presetPreventEvents", [13, 38, 40]);
    /**
     * 预定义阻止冒泡事件code
     *
     * @type {number[]}
     * @memberof MarkerController
     */
    E(this, "presetPreventPropEvents", [27]);
    /**
     * 删除回调
     *
     * @type {NOOP}
     * @memberof MarkerController
     */
    E(this, "cleanup", St);
    this.registerNode();
  }
  /**
   * 声明'@'插件
   *
   * @template T
   * @param {T} editor
   * @return {*}
   * @memberof MarkerController
   */
  markerPlugin(e) {
    const { insertText: t, isInline: n, isVoid: i } = e;
    return e.insertText = (r) => {
      if (!this.editor) {
        t(r);
        return;
      }
      if (!this.editor.isFocused()) {
        t(r);
        return;
      }
      if (fe.getSelectedElems(e).some((l) => e.isVoid(l))) {
        t(r);
        return;
      }
      r === "#" && !this.execting && (this.query = "", this.showModal()), t(r);
    }, e.isInline = (r) => fe.getNodeType(r) === "marker" ? !0 : n(r), e.isVoid = (r) => fe.getNodeType(r) === "marker" ? !0 : i(r), e;
  }
  registerNode() {
    window.markerIsRegiter || (it.registerModule(_2), window.markerIsRegiter = !0), it.registerPlugin(this.markerPlugin.bind(this));
  }
  /**
   * 初始化
   *
   * @param {IDomEditor} editor
   * @memberof MarkerController
   */
  async init(e, t) {
    if (this.model = t.model, this.context = t.context, this.params = t.params, this.evt = t.evt, this.data = t.data, this.editor = e, this.editorParams = this.model.editorParams, this.editorParams) {
      const {
        QUOTEURL: i,
        QUOTEFIELDMAP: r,
        QUOTEMETHOD: o,
        QUOTESCRIPT: a,
        QUOTEINSCRIPT: l,
        QUOTEPARAMS: c,
        QUOTECODELISTMAP: u
      } = this.editorParams;
      if (i && (this.quoteUrl = i), r && (this.quoteFieldMap = JSON.parse(r)), o && (this.quoteMethod = o.toLowerCase()), c && (this.quoteParams = JSON.parse(c)), a && (this.quoteScript = a), l && (this.quoteInScript = l), u) {
        const f = JSON.parse(u);
        this.setCodeListMap(f);
      }
    }
    const n = this.editor.getEditableContainer();
    n && (this.cleanup = li(n, "keydown", (i) => {
      var r;
      this.execting && this.presetPreventEvents.includes(i.keyCode) && i.preventDefault(), this.execting && this.presetPreventPropEvents.includes(i.keyCode) && (i.stopPropagation(), (r = this.overlay) == null || r.dismiss());
    }));
  }
  onDestroyed() {
    this.cleanup !== St && this.cleanup(), this.overlay && this.overlay.dismiss();
  }
  // 设置代码表map
  async setCodeListMap(e) {
    for (const t in e) {
      const n = await this.loadCodeList(e[t]);
      n && this.quoteCodelistMap.set(t, n);
    }
  }
  // 显示弹框
  showModal() {
    if (!this.quoteUrl)
      throw new rs("未配置提及工作项QUOTEURL编辑器参数！");
    const e = document.getSelection();
    if (!e)
      return;
    const { focusNode: t } = e;
    t && this.openPopover(t.parentNode).then(
      (n) => {
        n.length > 0 && this.insertNode(n[0]);
      }
    );
  }
  findCodeListItem(e, t) {
    if (e) {
      const n = e.find((i) => i.value == t);
      if (n)
        return n;
      for (let i = 0; i < e.length; i++) {
        const r = this.findCodeListItem(
          e[i].children,
          t
        );
        if (r)
          return r;
      }
    }
  }
  /**
   * 插入@
   *
   * @param {IDomEditor} editor
   * @memberof MarkerController
   */
  insertNode(e) {
    if (this.quoteCodelistMap.has("type") && e.type) {
      const n = this.quoteCodelistMap.get("type"), i = this.findCodeListItem(n.codeListItems, e.type);
      i && i.sysImage && Object.assign(e, {
        icon: i.sysImage.rawContent
      });
    }
    const t = {
      type: "marker",
      script: this.quoteScript,
      data: e,
      children: [{ text: "" }]
    };
    this.editor.restoreSelection(), this.editor.deleteBackward("character");
    for (let n = 0; n < this.query.length; n++)
      this.editor.deleteBackward("character");
    this.editor.insertNode(t), this.editor.move(1);
  }
  /**
   * 获取节点信息
   *
   * @param {IData} data
   * @memberof MenTionController
   */
  getNodeInfo(e) {
    return Object.assign(e, { script: this.quoteScript }), '<span data-w-e-type="marker" data-w-e-is-void data-w-e-is-inline data-value="'.concat(encodeURIComponent(
      JSON.stringify(e)
    ), '"></span>');
  }
  /**
   * 解析marker节点
   *
   * @param {string} value
   * @return {*}
   * @memberof MarkerController
   */
  parseNode(e) {
    return Lt.execScriptFn(
      { value: e, controller: this },
      this.quoteInScript,
      {
        singleRowReturn: !0,
        isAsync: !1
      }
    );
  }
  /**
   * 处理公共参数
   *
   * @param {IData} data
   * @param {IContext} context
   * @param {IParams} params
   * @return {*}  {{ context: IContext; params: IParams }}
   * @memberof MarkerController
   */
  handlePublicParams(e, t, n) {
    const { navigateContexts: i, navigateParams: r } = this.model;
    let o = {};
    i && e && (o = Jr(i, e, n, t));
    const a = Object.assign(t.clone(), o);
    let l = {};
    return r && e && (l = Jr(r, e, n, t)), { context: a, params: l };
  }
  /**
   * 获取工作项信息
   *
   * @param {IData} data
   * @return {*}  {Promise<IData[]>}
   * @memberof MarkerController
   */
  load(e = {}) {
    const { context: t, params: n } = this.handlePublicParams(
      this.data,
      this.context,
      this.params
    ), i = e.isInitialLoad === !0, r = e.isLoadMore === !0;
    i ? this.curPage = 0 : r && (this.curPage += 1);
    const o = Lt.execScriptFn(
      { data: this.data, context: t, params: n },
      this.quoteUrl,
      {
        singleRowReturn: !0,
        isAsync: !1
      }
    ), a = {
      ...n,
      query: this.query,
      size: this.size,
      page: this.curPage,
      ...this.quoteParams
    };
    return ibiz.net[this.quoteMethod](o, a);
  }
  /**
   * 转换ui数据
   *
   * @param {IData[]} data
   * @return {*}  {IData[]}
   * @memberof MarkerController
   */
  toUIData(e) {
    return e.map((t) => {
      const n = {};
      return Object.keys(this.quoteFieldMap).forEach((i) => {
        n[i] = t[this.quoteFieldMap[i]];
      }), n;
    });
  }
  /**
   * 打开用户列表气泡框
   *
   * @param {HTMLElement} event
   * @memberof MarkerController
   */
  async openPopover(e) {
    this.overlay = ibiz.overlay.createPopover(
      this.createOverlayView(),
      void 0,
      {
        placement: "bottom-start",
        autoClose: !0,
        width: "300px",
        noArrow: !0
      }
    ), await this.overlay.present(e), this.execting = !0;
    const t = await this.overlay.onWillDismiss();
    return this.execting = !1, t.data || [];
  }
  createOverlayView() {
    return (e) => oi(T2, {
      controller: this,
      modal: e
    });
  }
  /**
   * 加载代码表
   *
   * @param {string} appCodeListId
   * @return {*}  {(Promise<IData | undefined>)}
   * @memberof MarkerController
   */
  async loadCodeList(e) {
    const t = ibiz.hub.getApp(this.context.srfappid), n = t.codeList.getCodeList(e), i = await t.codeList.get(
      e,
      this.context,
      this.params
    );
    return { codeList: n, codeListItems: i };
  }
}
function g5(s) {
  const { script: e = "", data: t = {} } = s, n = Lt.execScriptFn({ data: t }, e, {
    singleRowReturn: !0,
    isAsync: !1
  });
  return "".concat(n);
}
const p5 = {
  type: "mention",
  elemToHtml: g5
};
function m5(s) {
  const e = decodeURIComponent(s.getAttribute("data-value") || ""), t = JSON.parse(e);
  return {
    type: "mention",
    script: t.script,
    data: t,
    children: [{ text: "" }]
  };
}
const w5 = {
  selector: 'span[data-w-e-type="mention"]',
  parseElemHtml: m5
};
function y5(s) {
  const { data: e = {} } = s, t = {
    name: "@".concat(e.name),
    id: e.id
  };
  return gn(
    "mention-elem",
    {
      dataset: { value: JSON.stringify(t) },
      props: {
        contentEditable: !1
        // 不可编辑
      }
    },
    []
  );
}
const b5 = {
  type: "mention",
  renderElem: y5
};
class v5 {
  constructor() {
    E(this, "title", "提及成员");
    E(this, "tag", "button");
    E(this, "iconSvg", '<svg t="1705979200437" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="4218" xmlns:xlink="http://www.w3.org/1999/xlink" width="200" height="200"><path d="M23.7 555c0-339.3 247-550 533.8-550 295.6 0 442.8 165.9 442.8 401.6 0 210.8-93.5 361.7-237 361.7-63.6 0-108.5-26.2-137.2-78.6-48.6 51.1-96 79.8-174.6 79.8-116 0-178.4-77.3-178.4-193.3 0-209.5 131-323 251.9-323 64.9 0 102.3 24.9 122.2 68.6l11.2-58.6 114.7 1.2L727 510.1c-7.5 36.2-11.2 63.6-11.2 81.1 0 44.9 22.5 71.1 56.1 71.1 63.6 0 106-89.8 106-243.2 0-205.8-114.7-300.6-323-300.6-220.8 0-405.4 163.4-405.4 436.5 0 238.2 132.2 350.5 390.4 350.5 94.8 0 174.6-12.5 255.7-36.2v109.8c-88.6 26.2-177.1 39.9-263.2 39.9-329.1 0-508.7-168.4-508.7-464z m585-44.9c3.7-20 6.2-39.9 6.2-53.6 0-56.1-15-96-83.6-96-83.6 0-133.5 108.5-133.5 212 0 44.9 13.7 88.6 77.3 88.6 73.7-0.1 114.9-57.4 133.6-151z" fill="#333333" p-id="4219"></path></svg>');
  }
  // 菜单是否需要激活（如选中加粗文本，“加粗”菜单会激活），用不到则返回 false
  isActive(e) {
    return !1;
  }
  // 获取菜单执行时的 value ，用不到则返回空 字符串或 false
  getValue(e) {
    return "";
  }
  // 菜单是否需要禁用（如选中 H1 ，“引用”菜单被禁用），用不到则返回 false
  isDisabled(e) {
    return !1;
  }
  // 点击菜单时触发的函数
  exec(e, t) {
    e.insertText("@");
  }
}
const x5 = {
  key: "mention",
  factory() {
    return new v5();
  }
}, C5 = {
  renderElems: [b5],
  elemsToHtml: [p5],
  parseElemsHtml: [w5],
  menus: [x5]
};
class E5 {
  /**
   * Creates an instance of MenTionController.
   * @param {IData} option
   * @memberof MenTionController
   */
  constructor() {
    /**
     *云系统操作者Map
     *
     * @memberof MenTionController
     */
    E(this, "operatorMap", /* @__PURE__ */ new Map());
    /**
     * 模型
     *
     * @type {IEditor}
     * @memberof MenTionController
     */
    E(this, "model");
    /**
     * 上下文
     *
     * @type {IContext}
     */
    E(this, "context");
    /**
     * 视图参数
     *
     * @type {IParams}
     */
    E(this, "params");
    /**
     * 表单数据
     *
     * @type {IData}
     * @memberof MenTionController
     */
    E(this, "data", {});
    /**
     * 编辑器示例
     *
     * @type {IDomEditor}
     * @memberof MenTionController
     */
    E(this, "editor");
    /**
     * 用户请求url
     *
     * @type {string}
     * @memberof MenTionController
     */
    E(this, "userUrl", "");
    /**
     * 人员UI转化
     */
    E(this, "userFieldMap", {
      id: "id",
      name: "name"
    });
    /**
     * 请求方法
     *
     * @type {('post' | 'get')}
     * @memberof MenTionController
     */
    E(this, "userMethod", "post");
    /**
     * 转换脚本
     *
     * @type {string}
     * @memberof MenTionController
     */
    E(this, "userScript", "`@{userid=${data.id},name=${data.name}}`");
    /**
     * 逆转换脚本
     *
     * @type {string}
     * @memberof MenTionController
     */
    E(this, "userInScript", "value.replaceAll(/@{userid=(.+?),name=(.+?)}/g,(x, id, name) => {return controller.getNodeInfo({ id, name })})");
    /**
     * 编辑器参数
     *
     * @type {IData}
     * @memberof MenTionController
     */
    E(this, "editorParams");
    /**
     * 用户数据
     *
     * @type {IData[]}
     * @memberof MenTionController
     */
    E(this, "items", []);
    /**
     * 气泡容器
     *
     * @type {IOverlayPopoverContainer}
     * @memberof MenTionController
     */
    E(this, "overlay", null);
    /**
     * 编辑器事件
     *
     * @type {ControllerEvent<commentEvent>}
     * @memberof MenTionController
     */
    E(this, "evt");
    /**
     * 是否正在执行
     *
     * @private
     * @type {boolean}
     * @memberof MenTionController
     */
    E(this, "execting", !1);
    /**
     * 搜索字段
     *
     * @type {string}
     * @memberof MenTionController
     */
    E(this, "query", "");
    /**
     * 当前页
     *
     * @type {number}
     * @memberof MenTionController
     */
    E(this, "curPage", 0);
    /**
     * 分页条数
     *
     * @type {number}
     * @memberof MenTionController
     */
    E(this, "size", 20);
    /**
     * 预定义阻止捕获事件code
     *
     * @type {number[]}
     * @memberof MenTionController
     */
    E(this, "presetPreventEvents", [13, 38, 40]);
    /**
     * 预定义阻止冒泡事件code
     *
     * @type {number[]}
     * @memberof MenTionController
     */
    E(this, "presetPreventPropEvents", [27]);
    /**
     * 删除回调
     *
     * @type {NOOP}
     * @memberof MenTionController
     */
    E(this, "cleanup", St);
    this.registerNode();
  }
  /**
   * 声明'@'插件
   *
   * @template T
   * @param {T} editor
   * @return {*}
   * @memberof MenTionController
   */
  mentionPlugin(e) {
    const { insertText: t, isInline: n, isVoid: i } = e;
    return e.insertText = (r) => {
      if (!this.editor) {
        t(r);
        return;
      }
      if (!this.editor.isFocused()) {
        t(r);
        return;
      }
      if (fe.getSelectedElems(e).some((l) => e.isVoid(l))) {
        t(r);
        return;
      }
      r === "@" && !this.execting && (this.query = "", this.showModal()), t(r);
    }, e.isInline = (r) => fe.getNodeType(r) === "mention" ? !0 : n(r), e.isVoid = (r) => fe.getNodeType(r) === "mention" ? !0 : i(r), e;
  }
  registerNode() {
    window.mentionIsRegiter || (it.registerModule(C5), window.mentionIsRegiter = !0), it.registerPlugin(this.mentionPlugin.bind(this));
  }
  /**
   * 初始化
   *
   * @param {IDomEditor} editor
   * @memberof MenTionController
   */
  async init(e, t) {
    if (this.model = t.model, this.context = t.context, this.params = t.params, this.evt = t.evt, this.data = t.data, this.editor = e, this.editorParams = this.model.editorParams, this.editorParams) {
      const { USERURL: i, USERFIELDMAP: r, USERMETHOD: o, USERSCRIPT: a, USERINSCRIPT: l } = this.editorParams;
      i && (this.userUrl = i), r && (this.userFieldMap = JSON.parse(r)), o && (this.userMethod = o.toLowerCase()), a && (this.userScript = a), l && (this.userInScript = l);
    }
    const n = this.editor.getEditableContainer();
    n && (this.cleanup = li(n, "keydown", (i) => {
      var r;
      this.execting && this.presetPreventEvents.includes(i.keyCode) && i.preventDefault(), this.execting && this.presetPreventPropEvents.includes(i.keyCode) && (i.stopPropagation(), (r = this.overlay) == null || r.dismiss());
    })), await this.getOperatorUserList();
  }
  /**
   * 获取云系统操作者
   *
   * @memberof MenTionController
   */
  async getOperatorUserList() {
    const e = await ibiz.hub.getApp(this.context.srfappid);
    let t = [];
    t = await e.codeList.get(
      "SysOperator",
      this.context,
      this.params
    ), this.operatorMap = new Map(
      t.map((n) => [n.value, n])
    );
  }
  onDestroyed() {
    this.cleanup !== St && this.cleanup(), this.overlay && this.overlay.dismiss();
  }
  // 显示弹框
  showModal() {
    if (!this.userUrl)
      throw new rs("未配置提及用户USERURL编辑器参数！");
    const e = document.getSelection();
    if (!e)
      return;
    const { focusNode: t } = e;
    t && this.openUserPopover(t.parentNode).then(
      (n) => {
        n.length > 0 && this.insertNode(n[0]);
      }
    );
  }
  /**
   * 插入@
   *
   * @param {IDomEditor} editor
   * @memberof MenTionController
   */
  insertNode(e) {
    const t = {
      type: "mention",
      script: this.userScript,
      data: e,
      children: [{ text: "" }]
    };
    this.editor.restoreSelection(), this.editor.deleteBackward("character");
    for (let n = 0; n < this.query.length; n++)
      this.editor.deleteBackward("character");
    this.editor.insertNode(t), this.editor.move(1);
  }
  /**
   * 获取节点信息
   *
   * @param {IData} data
   * @memberof MenTionController
   */
  getNodeInfo(e) {
    return Object.assign(e, { script: this.userScript }), '<span data-w-e-type="mention" data-w-e-is-void data-w-e-is-inline data-value="'.concat(encodeURIComponent(
      JSON.stringify(e)
    ), '"></span>');
  }
  /**
   * 解析mention节点
   *
   * @param {string} value
   * @return {*}
   * @memberof MenTionController
   */
  parseNode(e) {
    return Lt.execScriptFn(
      { value: e, controller: this },
      this.userInScript,
      {
        singleRowReturn: !0,
        isAsync: !1
      }
    );
  }
  /**
   * 处理公共参数
   *
   * @param {IData} data
   * @param {IContext} context
   * @param {IParams} params
   * @return {*}  {{ context: IContext; params: IParams }}
   * @memberof MenTionController
   */
  handlePublicParams(e, t, n) {
    const { navigateContexts: i, navigateParams: r } = this.model;
    let o = {};
    i && e && (o = Jr(i, e, n, t));
    const a = Object.assign(t.clone(), o);
    let l = {};
    return r && e && (l = Jr(r, e, n, t)), { context: a, params: l };
  }
  /**
   * 获取用户信息
   *
   * @param {IData} data
   * @return {*}  {Promise<IData[]>}
   * @memberof MenTionController
   */
  getUsers(e = {}) {
    const { context: t, params: n } = this.handlePublicParams(
      this.data,
      this.context,
      this.params
    ), i = e.isInitialLoad === !0, r = e.isLoadMore === !0;
    i ? this.curPage = 0 : r && (this.curPage += 1);
    const o = Lt.execScriptFn(
      { data: this.data, context: t, params: n },
      this.userUrl,
      {
        singleRowReturn: !0,
        isAsync: !1
      }
    ), a = {
      ...n,
      query: this.query,
      size: this.size,
      page: this.curPage
    };
    return ibiz.net[this.userMethod](o, a);
  }
  /**
   * 转换ui数据
   *
   * @param {IData[]} data
   * @return {*}  {IData[]}
   * @memberof MenTionController
   */
  toUIData(e) {
    return e.map((t) => {
      const n = {};
      return Object.keys(this.userFieldMap).forEach((i) => {
        n[i] = t[this.userFieldMap[i]];
      }), n;
    });
  }
  /**
   * 打开用户列表气泡框
   *
   * @param {HTMLElement} event
   * @memberof MenTionController
   */
  async openUserPopover(e) {
    this.overlay = ibiz.overlay.createPopover(
      this.createOverlayView(),
      void 0,
      {
        placement: "bottom-start",
        autoClose: !0,
        width: "300px",
        noArrow: !0
      }
    ), await this.overlay.present(e), this.execting = !0;
    const t = await this.overlay.onWillDismiss();
    return this.execting = !1, t.data || [];
  }
  createOverlayView() {
    return (e) => oi(O2, {
      controller: this,
      modal: e
    });
  }
}
function S5(s) {
  const { script: e = "", data: t = {} } = s, n = Lt.execScriptFn({ data: t }, e, {
    singleRowReturn: !0,
    isAsync: !1
  });
  return "".concat(n);
}
const A5 = {
  type: "page",
  elemToHtml: S5
};
function M5(s) {
  const e = decodeURIComponent(s.getAttribute("data-value") || ""), t = JSON.parse(e);
  return {
    type: "page",
    script: t.script,
    data: t,
    children: [{ text: "" }]
  };
}
const k5 = {
  selector: 'span[data-w-e-type="page"]',
  parseElemHtml: M5
};
function P5(s) {
  const { data: e = {} } = s, t = {
    name: "".concat(e.name),
    id: e.id
  };
  return gn(
    "mention-elem",
    {
      dataset: { value: JSON.stringify(t) },
      props: {
        contentEditable: !1
        // 不可编辑
      }
    },
    []
  );
}
const _5 = {
  type: "Page",
  renderElem: P5
};
class O5 {
  constructor() {
    E(this, "title", "页面");
    E(this, "tag", "button");
    E(this, "iconSvg", '<svg t="1707293566679" class="icon" viewBox="0 0 1024 1024" version="1.1" xmlns="http://www.w3.org/2000/svg" p-id="6103" width="200" height="200"><path d="M288 512l256 0C561.92 512 576 497.92 576 480 576 462.08 561.92 448 544 448l-256 0C270.08 448 256 462.08 256 480 256 497.92 270.08 512 288 512zM768 64 192 64C121.6 64 64 121.6 64 192l0 576c0 70.4 57.6 128 128 128l576 0c70.4 0 128-57.6 128-128L896 192C896 121.6 838.4 64 768 64zM832 768c0 35.2-28.8 64-64 64L192 832c-35.2 0-64-28.8-64-64L128 192c0-35.2 28.8-64 64-64l576 0c35.2 0 64 28.8 64 64L832 768zM672 256l-384 0C270.08 256 256 270.08 256 288 256 305.92 270.08 320 288 320l384 0C689.92 320 704 305.92 704 288 704 270.08 689.92 256 672 256zM608 640l-320 0C270.08 640 256 654.08 256 672l0 0C256 689.92 270.08 704 288 704l320 0c17.92 0 32-14.08 32-32l0 0C640 654.08 625.92 640 608 640z" p-id="6104"></path></svg>');
  }
  // 菜单是否需要激活（如选中加粗文本，“加粗”菜单会激活），用不到则返回 false
  isActive(e) {
    return !1;
  }
  // 获取菜单执行时的 value ，用不到则返回空 字符串或 false
  getValue(e) {
    return "";
  }
  // 菜单是否需要禁用（如选中 H1 ，“引用”菜单被禁用），用不到则返回 false
  isDisabled(e) {
    return !1;
  }
  // 点击菜单时触发的函数
  exec(e, t) {
    throw new rs("暂未支持上传页面！");
  }
}
const T5 = {
  key: "page",
  factory() {
    return new O5();
  }
}, L5 = {
  renderElems: [_5],
  elemsToHtml: [A5],
  parseElemsHtml: [k5],
  menus: [T5]
};
class D5 {
  /**
   * Creates an instance of PageController.
   * @param {IData} option
   * @memberof PageController
   */
  constructor() {
    /**
     * 模型
     *
     * @type {IEditor}
     * @memberof PageController
     */
    E(this, "model");
    /**
     * 上下文
     *
     * @type {IContext}
     */
    E(this, "context");
    /**
     * 视图参数
     *
     * @type {IParams}
     */
    E(this, "params");
    /**
     * 表单数据
     *
     * @type {IData}
     * @memberof PageController
     */
    E(this, "data", {});
    /**
     * 编辑器示例
     *
     * @type {IDomEditor}
     * @memberof PageController
     */
    E(this, "editor");
    /**
     * 编辑器参数
     *
     * @type {IData}
     * @memberof PageController
     */
    E(this, "editorParams");
    /**
     * 用户数据
     *
     * @type {IData[]}
     * @memberof PageController
     */
    E(this, "items", []);
    /**
     * 编辑器事件
     *
     * @type {ControllerEvent<commentEvent>}
     * @memberof PageController
     */
    E(this, "evt");
    /**
     * 是否正在执行
     *
     * @private
     * @type {boolean}
     * @memberof PageController
     */
    E(this, "execting", !1);
    this.registerNode();
  }
  registerNode() {
    window.pageIsRegiter || (it.registerModule(L5), window.pageIsRegiter = !0);
  }
  /**
   * 初始化
   *
   * @param {IDomEditor} editor
   * @memberof PageController
   */
  async init(e, t) {
    this.model = t.model, this.context = t.context, this.params = t.params, this.evt = t.evt, this.data = t.data, this.editor = e, this.editorParams = this.model.editorParams;
  }
  /**
   * 控制器销毁
   *
   * @memberof PageController
   */
  onDestroyed() {
  }
  /**
   * 插入节点
   *
   * @param {IDomEditor} editor
   * @memberof PageController
   */
  insertNode(e) {
  }
  /**
   * 解析mention节点
   *
   * @param {string} value
   * @return {*}
   * @memberof PageController
   */
  parseNode(e) {
    return e;
  }
}
const N5 = {
  type: "emoji",
  renderElem: (s) => {
    const { data: e = {} } = s;
    return gn(
      "emoji-elem",
      {
        dataset: { value: e.emoji ? Pa(e.emoji) : "" },
        props: {
          contentEditable: !1
          // 不可编辑
        }
      },
      []
    );
  }
}, I5 = {
  type: "emoji",
  elemToHtml: (s) => {
    const { data: e } = s;
    return "<span data-w-e-type=\"emoji\" class='emoji'>".concat(e.emoji, "</span>");
  }
}, j5 = {
  selector: 'span[data-w-e-type="emoji"]',
  parseElemHtml: (s) => ({
    data: {
      emoji: s.innerHTML
    },
    type: "emoji",
    children: [{ text: "" }]
  })
};
class R5 {
  /**
   * Creates an instance of EmojiButtonMenu.
   * @memberof EmojiButtonMenu
   */
  constructor() {
    /**
     * 标题
     *
     * @memberof EmojiButtonMenu
     */
    E(this, "title", "表情");
    /**
     * 菜单类型
     *
     * @memberof EmojiButtonMenu
     */
    E(this, "tag", "button");
    /**
     * 菜单图标
     *
     * @memberof EmojiButtonMenu
     */
    E(this, "iconSvg", "<svg viewBox='0 0 1040 1024' version='1.1' xmlns='http://www.w3.org/2000/svg' p-id='1490' width='1em' height='1em' stroke='var(--w-e-toolbar-color)' > <path stroke-width='38' d='M512.075261 1024A511.774217 511.774217 0 1 1 730.482434 48.769072a37.630457 37.630457 0 1 1-32.061149 68.035867 436.513303 436.513303 0 1 0 250.468323 395.270322 37.630457 37.630457 0 0 1 75.260914 0 512.526826 512.526826 0 0 1-512.075261 511.924739z' p-id='1491' ></path> <path stroke-width='38' d='M333.857416 344.0929a57.348817 57.348817 0 1 0 57.348817 57.348817 57.499339 57.499339 0 0 0-57.348817-57.348817zM686.53006 344.0929a57.348817 57.348817 0 1 0 57.348817 57.348817 57.348817 57.348817 0 0 0-57.348817-57.348817zM515.236219 783.165074c-162.864619 0-262.359547-141.942084-262.359547-219.159782a30.104366 30.104366 0 0 1 60.208731 0c0 48.618551 76.314567 158.951051 202.150816 158.951051s193.571072-134.114949 193.571072-158.951051a30.104366 30.104366 0 0 1 60.208731 0c0 54.488902-90.012054 219.159782-253.779803 219.159782zM1009.549904 207.720123h-67.132735V139.985301a30.104366 30.104366 0 1 0-60.208732 0v67.734822h-67.734822a30.104366 30.104366 0 0 0-30.104366 30.104366 30.104366 30.104366 0 0 0 30.104366 30.104366h67.734822v67.734823a30.104366 30.104366 0 0 0 60.208732 0v-67.734823h67.734823a30.104366 30.104366 0 0 0 30.104365-30.104366 30.104366 30.104366 0 0 0-30.706453-30.104366z' p-id='1492' ></path> </svg>");
  }
  /**
   * 菜单是否需要激活（如选中加粗文本，“加粗”菜单会激活），用不到则返回 false
   *
   * @return {*}  {boolean}
   * @memberof EmojiButtonMenu
   */
  isActive() {
    return !1;
  }
  /**
   * 获取菜单执行时的 value ，用不到则返回空 字符串或 false
   *
   * @return {*}  {(string | boolean)}
   * @memberof EmojiButtonMenu
   */
  getValue() {
    return !1;
  }
  /**
   * 菜单是否需要禁用（如选中 H1 ，“引用”菜单被禁用），用不到则返回 false
   *
   * @return {*}  {boolean}
   * @memberof EmojiButtonMenu
   */
  isDisabled() {
    return !1;
  }
  /**
   * 点击菜单时触发的函数
   *
   * @param {IDomEditor} editor
   * @memberof EmojiButtonMenu
   */
  exec(e) {
    e.emit("openEmojiSelect");
  }
}
const B5 = {
  key: "emoji",
  factory() {
    return new R5();
  }
}, $5 = {
  renderElems: [N5],
  elemsToHtml: [I5],
  parseElemsHtml: [j5],
  menus: [B5]
};
class F5 {
  /**
   * Creates an instance of EmojiController.
   * @param {IData} option
   * @memberof EmojiController
   */
  constructor() {
    /**
     * 编辑器示例
     *
     * @type {IDomEditor}
     * @memberof EmojiController
     */
    E(this, "editor");
    /**
     * 气泡容器
     *
     * @type {IOverlayPopoverContainer}
     * @memberof EmojiController
     */
    E(this, "overlay", null);
    /**
     * 预定义阻止捕获事件code
     *
     * @type {number[]}
     * @memberof EmojiController
     */
    E(this, "presetPreventEvents", [13, 38, 40]);
    /**
     * 预定义阻止冒泡事件code
     *
     * @type {number[]}
     * @memberof EmojiController
     */
    E(this, "presetPreventPropEvents", [27]);
    /**
     * 删除回调
     *
     * @type {NOOP}
     * @memberof EmojiController
     */
    E(this, "cleanup", St);
    this.registerNode();
  }
  /**
   * 声明' :'插件
   *
   * @template T
   * @param {T} editor
   * @return {*}
   * @memberof EmojiController
   */
  emojiPlugin(e) {
    const { isInline: t, isVoid: n } = e;
    return e.isInline = (i) => fe.getNodeType(i) === "emoji" ? !0 : t(i), e.isVoid = (i) => fe.getNodeType(i) === "emoji" ? !0 : n(i), e;
  }
  registerNode() {
    window.emojiIsRegiter || (it.registerModule($5), window.emojiIsRegiter = !0), it.registerPlugin(this.emojiPlugin.bind(this));
  }
  /**
   * 初始化
   *
   * @param {IDomEditor} editor
   * @memberof EmojiController
   */
  async init(e) {
    this.editor = e, this.listenEvent();
  }
  /**
   * 监听事件
   *
   * @private
   * @memberof EmojiController
   */
  listenEvent() {
    const e = this.editor.getEditableContainer();
    this.editor.on("openEmojiSelect", () => this.openEmojiSelect()), this.cleanup = li(e, "keydown", (t) => {
      var n;
      this.overlay && this.presetPreventEvents.includes(t.keyCode) && t.preventDefault(), this.overlay && this.presetPreventPropEvents.includes(t.keyCode) && (t.stopPropagation(), (n = this.overlay) == null || n.dismiss());
    });
  }
  /**
   * 打开表情选择
   *
   * @memberof EmojiController
   */
  async openEmojiSelect() {
    const e = document.getSelection(), { focusNode: t } = e;
    t && (this.overlay = ibiz.overlay.createPopover(
      (n) => oi(L2, {
        controller: this,
        modal: n
      }),
      void 0,
      {
        width: "auto",
        noArrow: !0,
        autoClose: !0,
        placement: "bottom-start"
      }
    ), await this.overlay.present(t.parentNode), this.overlay.onWillDismiss().then((n) => {
      var o;
      const i = n, r = (o = i.data) == null ? void 0 : o[0];
      i.ok && r && this.addEmojiNode(r), this.overlay = null;
    }));
  }
  /**
   * 添加表情
   *
   * @param {string} data
   * @memberof EmojiController
   */
  addEmojiNode(e) {
    const t = {
      data: e,
      type: "emoji",
      children: [{ text: "" }]
    };
    this.editor.restoreSelection(), this.editor.insertNode(t), this.editor.move(1);
  }
  /**
   * 解析emoji节点
   *
   * @param {string} value
   * @return {*}
   * @memberof EmojiController
   */
  parseNode(e) {
    return Lt.execScriptFn(
      { value: e, controller: this },
      'value.replaceAll(/\\{\\"\\emoji\\":\\"(.+?)\\"\\}/g,(x, emoji) => {return \'<span data-w-e-type="emoji" class="emoji">\'+emoji+\'</span>\'})',
      {
        singleRowReturn: !0,
        isAsync: !1
      }
    );
  }
  onDestroyed() {
    this.cleanup !== St && this.cleanup(), this.overlay && this.overlay.dismiss();
  }
}
const z5 = {
  type: "insert",
  renderElem: (s, e) => {
    const { data: t = {} } = s;
    return gn(
      "".concat(t.type || "", "-elem"),
      {
        dataset: { value: JSON.stringify(t) },
        props: {
          contentEditable: !1
          // 不可编辑
        }
      },
      e
    );
  }
}, V5 = {
  type: "insert",
  elemToHtml: (s) => {
    const { data: e = {} } = s;
    return "<span data-w-e-type=\"insert\" class='insert'>".concat(JSON.stringify({
      type: e.type,
      value: e.value
    }), "</span>");
  }
}, H5 = {
  selector: 'span[data-w-e-type="insert"]',
  parseElemHtml: (s) => ({
    data: JSON.parse(s.innerHTML) || {},
    type: "insert",
    children: [{ text: "" }]
  })
}, U5 = {
  type: "layout",
  renderElem: (s, e) => gn(
    "layout-elem",
    {
      props: {
        class: "layout"
      }
    },
    e || []
  )
}, q5 = {
  type: "layout",
  elemToHtml: (s, e) => "<layout-elem data-w-e-type=\"layout\" class='layout'>".concat(e, "</layout-elem>")
}, G5 = {
  selector: 'layout-elem[data-w-e-type="layout"]',
  parseElemHtml: (s, e) => ({
    type: "layout",
    children: e
  })
}, W5 = {
  type: "layout-column",
  renderElem: (s, e) => gn(
    "layout-column-elem",
    {
      props: {
        class: "layout-column"
      }
    },
    e || []
  )
}, J5 = {
  type: "layout-column",
  elemToHtml: (s, e) => "<layout-column-elem data-w-e-type=\"layout-column\" class='layout-column'>".concat(e, "</layout-column-elem>")
}, Y5 = {
  selector: 'layout-column-elem[data-w-e-type="layout-column"]',
  parseElemHtml: (s, e) => ({
    type: "layout-column",
    children: e
  })
};
class X5 {
  /**
   * Creates an instance of InsertButtonMenu.
   * @memberof InsertButtonMenu
   */
  constructor() {
    /**
     * 标题
     *
     * @memberof InsertButtonMenu
     */
    E(this, "title", "插入");
    /**
     * 菜单类型
     *
     * @memberof InsertButtonMenu
     */
    E(this, "tag", "button");
    /**
     * 菜单图标
     *
     * @memberof InsertButtonMenu
     */
    E(this, "iconSvg", "<svg viewBox='0 0 16 16' xmlns='http://www.w3.org/2000/svg' height='1em' width='1em' class='insert-icon' fill='var(--ibiz-color-primary)'><g stroke-width='1' fill-rule='evenodd'> <path d='M8 16A8 8 0 1 1 8 0a8 8 0 0 1 0 16zm-.6-8.6H4v1.2h3.4V12h1.2V8.6H12V7.4H8.6V4H7.4v3.4z'></path></g></svg>");
  }
  /**
   * 菜单是否需要激活（如选中加粗文本，“加粗”菜单会激活），用不到则返回 false
   *
   * @return {*}  {boolean}
   * @memberof InsertButtonMenu
   */
  isActive() {
    return !1;
  }
  /**
   * 获取菜单执行时的 value ，用不到则返回空 字符串或 false
   *
   * @return {*}  {(string | boolean)}
   * @memberof InsertButtonMenu
   */
  getValue() {
    return !1;
  }
  /**
   * 菜单是否需要禁用（如选中 H1 ，“引用”菜单被禁用），用不到则返回 false
   *
   * @return {*}  {boolean}
   * @memberof InsertButtonMenu
   */
  isDisabled() {
    return !1;
  }
  /**
   * 点击菜单时触发的函数
   *
   * @param {IDomEditor} editor
   * @memberof InsertButtonMenu
   */
  exec(e) {
    e.emit("openInsertSelect");
  }
}
const Z5 = {
  key: "insert",
  factory() {
    return new X5();
  }
}, K5 = {
  renderElems: [
    z5,
    U5,
    W5
  ],
  elemsToHtml: [
    V5,
    q5,
    J5
  ],
  parseElemsHtml: [
    H5,
    G5,
    Y5
  ],
  menus: [Z5]
};
function Rg(s, e, t) {
  if (s.length > 0) {
    const n = e[s[0]];
    if (n && n.type === t)
      return !0;
    if (n && n.children)
      return s.splice(0, 1), Rg(s, n.children, t);
  }
  return !1;
}
function Sa(s, e) {
  const { selection: t, children: n } = s;
  if (t) {
    const { path: i } = t.anchor;
    return Rg([...i], n, e);
  }
  return !1;
}
function Q5(s, e) {
  const t = e.selection;
  if (t == null)
    return "";
  const n = ps.string(s), i = t.anchor.offset, o = n.slice(0, i).split("\n"), a = o.length;
  return a === 0 ? "" : o[a - 1];
}
function Aa(s, e, t) {
  var r;
  const n = (r = Q) == null ? void 0 : r.nodes(s, {
    at: e,
    match: (o) => fe.getNodeType(o) === t
  });
  let i = !1;
  for (const o of n)
    i = !0;
  return i;
}
function Bg(s, e) {
  if (s.length > 0)
    for (let t = 0; t < s.length; t++) {
      const n = s[t];
      if (n.type === e || n.data && n.data && n.data.type === e)
        return n;
      if (n.children)
        return Bg(n.children || [], e);
    }
}
function Ma(s, e, t, n = !1) {
  for (let i of s.values())
    if (i.isInline === n && Bg([t[e[0]]], i.type))
      return !0;
  return !1;
}
function Vh(s) {
  const { selection: e, children: t } = s;
  if (e) {
    const { path: n } = e.anchor, i = t[n[0]] || {};
    return i && i.children && i.children.length === 1 ? !i.children[0].text : !(i && i.children && i.children.length > 1);
  }
  return !0;
}
function Hh(s) {
  const { selection: e, children: t } = s;
  if (e) {
    const { path: n } = e.anchor, i = t[n[0] + 1] || {};
    return i && i.children && i.children.length === 1 ? !i.children[0].text : !(i && i.children && i.children.length > 1);
  }
  return !0;
}
function Br(s, e) {
  $e.removeNodes(s, {
    at: e
  });
  let t = setTimeout(() => {
    s.move(1), s.focus(), clearTimeout(t), t = null;
  }, 0);
}
function e7(s, e, t) {
  $e.setNodes(
    s,
    {
      children: [{ text: "" }],
      data: t,
      type: "insert"
    },
    {
      at: e
    }
  ), s.move(1), s.focus();
}
function Uh(s, e) {
  const { selection: t } = s;
  if (t == null || st.isExpanded(t))
    return !1;
  const n = fe.getSelectedNodeByType(s, e);
  if (n === null)
    return !1;
  const { children: i } = n;
  if (i.length !== 1)
    return !1;
  const { text: r } = i[0];
  return r === "";
}
const $g = (s) => {
  const { selection: e } = s;
  return e && st.isCollapsed(e) ? Q.above(s, {
    match: (n) => Ri.isElementType(n, "layout-column")
  }) : null;
}, qh = (s) => {
  const e = $g(s);
  if (e) {
    const [, t] = e, n = Q.start(s, t);
    return Yr.equals(s.selection.anchor, n);
  }
  return !1;
}, t7 = (s) => {
  const e = $g(s);
  if (e) {
    const [, t] = e, n = Q.end(s, t);
    return Yr.equals(s.selection.anchor, n);
  }
  return !1;
}, n7 = (s) => {
  const { selection: e } = s;
  if (e && st.isCollapsed(e)) {
    const [t] = Q.node(s, e);
    if (de.isText(t) && /^(\s*\n\s*)+$/.test(t.text))
      return !0;
  }
  return !1;
}, s7 = (s) => {
  const { selection: e } = s;
  if (e && st.isCollapsed(e)) {
    const [t] = Q.node(s, e);
    if (de.isText(t) && t.text === "")
      return !0;
  }
  return !1;
};
class i7 {
  /**
   * Creates an instance of InsertController.
   * @memberof InsertController
   */
  constructor() {
    /**
     * 模型
     *
     * @type {IEditor}
     * @memberof MenTionController
     */
    E(this, "model");
    /**
     * 上下文
     *
     * @type {IContext}
     */
    E(this, "context");
    /**
     * 视图参数
     *
     * @type {IParams}
     */
    E(this, "params");
    /**
     * 表单数据
     *
     * @type {IData}
     * @memberof MenTionController
     */
    E(this, "data", {});
    /**
     * 编辑器示例
     *
     * @type {IDomEditor}
     * @memberof MenTionController
     */
    E(this, "editor");
    /**
     * 编辑器参数
     *
     * @type {IData}
     * @memberof MenTionController
     */
    E(this, "editorParams");
    /**
     * 编辑器示例
     *
     * @type {IDomEditor}
     * @memberof InsertController
     */
    E(this, "wangEditor");
    /**
     * 编辑内容区
     */
    E(this, "container");
    /**
     * 气泡容器
     *
     * @type {IOverlayPopoverContainer}
     * @memberof InsertController
     */
    E(this, "overlay", null);
    /**
     * 预定义阻止捕获事件code
     *
     * @type {number[]}
     * @memberof InsertController
     */
    E(this, "presetPreventEvents", [13, 38, 40]);
    /**
     * 预定义阻止冒泡事件code
     *
     * @type {number[]}
     * @memberof InsertController
     */
    E(this, "presetPreventPropEvents", [27]);
    /**
     * 插入项
     *
     * @type {number[]}
     * @memberof InsertController
     */
    E(this, "insertMap", Fd());
    /**
     * 删除回调
     *
     * @type {NOOP}
     * @memberof InsertController
     */
    E(this, "cleanup", St);
    this.registerNode();
  }
  /**
   * 声明插件
   *
   * @template T
   * @param {T} editor
   * @return {*}
   * @memberof InsertController
   */
  insertPlugin(e) {
    const {
      isInline: t,
      isVoid: n,
      insertBreak: i,
      insertNode: r,
      deleteBackward: o,
      normalizeNode: a,
      deleteForward: l
    } = e;
    return e.isInline = (c) => fe.getNodeType(c) === "insert" ? !0 : t(c), e.isVoid = (c) => fe.getNodeType(c) === "insert" ? !0 : n(c), e.insertBreak = () => {
      const c = fe.getSelectedNodeByType(e, "layout");
      if (c) {
        const u = Q5(
          c,
          e
        );
        if (u) {
          const f = u.match(/^\s+/);
          if (f !== null && f[0] != null) {
            const d = f[0];
            e.insertText("\n".concat(d));
            return;
          }
        }
        e.insertText("\n");
        return;
      }
      i();
    }, e.insertNode = (c) => {
      const { maxLength: u } = e.getConfig(), f = fe.getSelectedNodeByType(e, "layout");
      if (f && c.type && c.type === "layout")
        return;
      if (f) {
        const p = this.insertMap.find(
          (m) => m.type === c.data.type
        );
        p && p.isInline && (n7(e) || qh(e) && s7(e)) && e.insertText(" ");
      }
      if (!u) {
        r(c);
        return;
      }
      const d = fe.getLeftLengthOfMaxLength(e);
      if (d <= 0)
        return;
      const g = ps.string(c);
      d < g.length || r(c);
    }, e.normalizeNode = ([c, u]) => {
      if (fe.getNodeType(c) === "layout" && fe.isLastNode(e, c)) {
        const g = fe.genEmptyParagraph();
        $e.insertNodes(e, g, { at: [u[0] + 1] });
        return;
      }
      return a([c, u]);
    }, e.deleteBackward = (c) => {
      const u = fe.getSelectedNodeByType(e, "layout"), { selection: f } = e;
      if (!u && f) {
        const d = Q.before(e, f);
        if (d && (Aa(
          e,
          d,
          "layout"
        ) || !u && Ma(this.insertMap, d.path, e.children))) {
          Br(e, [d.path[0]]);
          return;
        }
      }
      u && Uh(e, "layout-column") || qh(e) || o(c);
    }, e.deleteForward = (c) => {
      const u = fe.getSelectedNodeByType(e, "layout"), { selection: f } = e;
      if (!u && f) {
        const d = Q.after(e, f);
        if (d) {
          const g = Aa(
            e,
            d,
            "layout"
          ), p = Vh(e), m = p ? f.focus.path[0] : d.path[0];
          if (g) {
            Br(e, [m]);
            return;
          }
          if (Ma(this.insertMap, d.path, e.children)) {
            Br(e, [m]), p && e.moveReverse(1), this.handleMove(39);
            return;
          }
        }
      }
      u && Uh(e, "layout-column") || t7(e) || l(c);
    }, e;
  }
  registerNode() {
    window.insertIsRegiter || (it.registerModule(K5), window.insertIsRegiter = !0), it.registerPlugin(this.insertPlugin.bind(this));
  }
  /**
   * 初始化
   *
   * @param {IDomEditor} editor
   * @memberof InsertController
   */
  async init(e, t) {
    this.model = t.model, this.context = t.context, this.params = t.params, this.data = t.data, this.editorParams = this.model.editorParams, this.wangEditor = e, this.listenEvent();
  }
  /**
   * 监听事件
   *
   * @private
   * @memberof InsertController
   */
  listenEvent() {
    const e = this.wangEditor.getEditableContainer();
    this.cleanup = li(e, "keydown", (t) => {
      var n;
      this.overlay && this.presetPreventEvents.includes(t.keyCode) && t.preventDefault(), this.overlay && this.presetPreventPropEvents.includes(t.keyCode) && (t.stopPropagation(), (n = this.overlay) == null || n.dismiss());
    }), e.addEventListener("keyup", this.handleKeyup.bind(this)), e.addEventListener("mouseup", this.handleMouseup.bind(this)), this.wangEditor.on("openInsertSelect", () => this.openInsertSelect()), e.addEventListener(
      "dateElemEvent",
      this.handleInsertChange.bind(this)
    ), e.addEventListener(
      "labelElemEvent",
      this.handleInsertChange.bind(this)
    ), e.addEventListener(
      "promptBoxElemEvent",
      this.handleInsertChange.bind(this)
    ), e.addEventListener(
      "mindMapElemEvent",
      this.handleInsertChange.bind(this)
    ), e.addEventListener(
      "audioElemEvent",
      this.handleInsertChange.bind(this)
    ), e.addEventListener(
      "formulaElemEvent",
      this.handleInsertChange.bind(this)
    ), e.addEventListener(
      "layoutElemEvent",
      this.handleInsertChange.bind(this)
    ), this.container = e;
  }
  /**
   * 处理按键抬起
   */
  handleKeyup(e) {
    this.handleMove(e.keyCode);
  }
  /**
   * 处理鼠标抬起
   */
  handleMouseup() {
    this.handleMove(39);
  }
  /**
   * 处理移动
   * 37, 38, 39, 40 上下左右键
   */
  handleMove(e) {
    if ([37, 38, 39, 40].includes(e) && this.wangEditor.selection) {
      const { children: t, selection: n } = this.wangEditor;
      if (n && n.focus.path && !Aa(this.wangEditor, n.focus.path, "layout") && Ma(this.insertMap, n.focus.path, t)) {
        if ([37, 38].includes(e) ? this.wangEditor.moveReverse(2) : [39, 40].includes(e) && this.wangEditor.move(2), n.focus.path[0] === 0) {
          this.handleMove(39);
          return;
        }
        this.handleMove(e);
      }
    }
  }
  /**
   * 处理插入项值改变
   */
  handleInsertChange(e) {
    const t = this.getCustomNodePath(e.target), { params: n } = e.detail;
    if (n && n.isDelete) {
      Br(this.wangEditor, t);
      return;
    }
    e.detail && e7(this.wangEditor, t, e.detail);
  }
  /**
   * 获取自定义元素path
   *
   * @param {Element} element 自定义元素节点
   * @memberof InsertController
   * @returns {number[]}
   */
  getCustomNodePath(e) {
    const t = fe.toSlateNode(this.wangEditor, e);
    return fe.findPath(this.wangEditor, t);
  }
  /**
   * 打开插入选择
   *
   * @memberof InsertController
   */
  async openInsertSelect() {
    let e;
    const t = fe.getToolbar(this.wangEditor);
    if (t) {
      const i = t.toolbarItems.find((r) => {
        const { $elem: o } = r, l = o[0].querySelectorAll("[data-menu-key]")[0];
        return (l ? l.getAttribute("data-menu-key") : "") === "insert" ? l : !1;
      });
      e = i ? i.$button[0] : !1;
    }
    if (e) {
      const n = await this.openPopover(
        e
      );
      n.ok && n.data && n.data.length > 0 && (n.data.length > 1 && (this.wangEditor.focus(), !Hh(this.wangEditor) && !Sa(this.wangEditor, "layout") && (this.wangEditor.insertBreak(), this.wangEditor.moveReverse(1))), n.data.forEach((i, r) => {
        setTimeout(() => {
          this.addNode(i, "insert");
        }, 200 * r);
      })), this.overlay = null;
    }
  }
  /**
   * 添加节点
   *
   * @param {IData} data
   * @param {string} type
   * @memberof InsertController
   */
  addNode(e, t) {
    const n = { data: e, type: t, children: [{ text: "" }] };
    switch (this.wangEditor.restoreSelection(), e.type) {
      case "prompt-box":
      case "mind-map":
      case "audio":
        !Vh(this.wangEditor) && !Sa(this.wangEditor, "layout") && this.wangEditor.insertBreak(), this.wangEditor.insertNode(n), Hh(this.wangEditor) && !Sa(this.wangEditor, "layout") && this.wangEditor.insertBreak();
        break;
      case "layout":
        Object.assign(n, {
          type: "layout",
          children: [
            { type: "layout-column", children: [{ text: "" }] },
            { type: "layout-column", children: [{ text: "" }] }
          ]
        }), this.wangEditor.insertNode(n);
        break;
      default:
        this.wangEditor.insertNode(n), this.wangEditor.move(1);
        break;
    }
    this.handleMove(39);
  }
  /**
   * 打开弹窗
   *
   * @param {HTMLElement} target
   * @returns {Promise<IModalData>}
   */
  async openPopover(e, t = {}) {
    return this.overlay = ibiz.overlay.createPopover(
      this.createOverlayView(),
      void 0,
      {
        width: "auto",
        noArrow: !0,
        autoClose: !0,
        placement: "bottom-start",
        ...t
      }
    ), await this.overlay.present(e), await this.overlay.onWillDismiss();
  }
  /**
   * 创建弹窗内元素
   *
   * @param {JSX.Element | string} component
   * @returns {VNode}
   */
  createOverlayView() {
    return (e) => oi(W2, {
      modal: e,
      context: this.context,
      viewParams: this.params,
      actionParams: this.editorParams
    });
  }
  /**
   * 解析emoji节点
   *
   * @param {string} value
   * @return {*}
   * @memberof InsertController
   * @memberof InsertController
   */
  parseNode(e) {
    return e;
  }
  /**
   * 销毁
   *
   * @memberof InsertController
   */
  onDestroyed() {
    this.container && (this.container.removeEventListener("keyup", this.handleKeyup.bind(this)), this.container.removeEventListener(
      "mouseup",
      this.handleMouseup.bind(this)
    ), this.container.removeEventListener(
      "dateElemEvent",
      this.handleInsertChange.bind(this)
    ), this.container.removeEventListener(
      "labelElemEvent",
      this.handleInsertChange.bind(this)
    ), this.container.removeEventListener(
      "promptBoxElemEvent",
      this.handleInsertChange.bind(this)
    ), this.container.removeEventListener(
      "mindMapElemEvent",
      this.handleInsertChange.bind(this)
    ), this.container.removeEventListener(
      "audioElemEvent",
      this.handleInsertChange.bind(this)
    ), this.container.removeEventListener(
      "formulaElemEvent",
      this.handleInsertChange.bind(this)
    ), this.container.removeEventListener(
      "layoutElemEvent",
      this.handleInsertChange.bind(this)
    ), this.container = null), this.cleanup !== St && this.cleanup(), this.overlay && this.overlay.dismiss();
  }
}
class xn {
  /**
   * 初始化
   *
   * @static
   * @memberof CustomNodeFactory
   */
  static init(e) {
    this.registerMap.set("mention", E5), this.registerMap.set("marker", f5), this.registerMap.set("attachments", h2), this.registerMap.set("codesnippet", v2), this.registerMap.set("page", D5), this.registerMap.set("emoji", F5), this.registerMap.set("insert", i7), this.presetNodes.forEach((t) => {
      this.registerPlugin({
        type: t,
        id: "".concat(t).concat(e)
      });
    });
  }
  /**
   * 注册节点适配器
   *
   * @public
   * @memberof CustomNodeFactory
   */
  static registerPlugin(e) {
    const { type: t, id: n } = e;
    if (this.customNodeMap.has(n))
      return this.customNodeMap.get(n);
    const i = this.registerMap.get(t);
    if (i) {
      const r = new i();
      return this.customNodeMap.set(n, r), r;
    }
  }
  /**
   * 根据uuid获取注册插件
   *
   * @static
   * @param {string} id
   * @return {*}
   * @memberof CustomNodeFactory
   */
  static getPluginsById(e) {
    const t = [];
    return this.presetNodes.forEach((n) => {
      this.customNodeMap.has("".concat(n).concat(e)) && t.push(this.customNodeMap.get("".concat(n).concat(e)));
    }), t;
  }
  /**
   * 卸载节点适配器
   *
   * @public
   * @memberof CustomNodeFactory
   */
  static unregisterPlugin(e) {
    const { id: t } = e;
    this.customNodeMap.has(t) && this.customNodeMap.delete(t);
  }
  /**
   * 初始化
   *
   * @static
   * @memberof CustomNodeFactory
   */
  static destroy(e) {
    this.presetNodes.forEach((t) => {
      this.unregisterPlugin({
        id: "".concat(t).concat(e)
      });
    }), this.registerMap.delete("mention"), this.registerMap.delete("marker"), this.registerMap.delete("attachments"), this.registerMap.delete("codesnippet"), this.registerMap.delete("page"), this.registerMap.delete("emoji"), this.registerMap.delete("insert");
  }
}
/**
 * 自定义节点
 *
 * @static
 * @type {IData}
 * @memberof CustomNodeFactory
 */
E(xn, "customNodeMap", /* @__PURE__ */ new Map()), /**
 * 预置注册表
 *
 * @type {Map<string, any>}
 * @memberof CustomNodeFactory
 */
E(xn, "registerMap", /* @__PURE__ */ new Map()), /**
 * 预置注册节点
 *
 * @static
 * @memberof CustomNodeFactory
 */
E(xn, "presetNodes", [
  "mention",
  "marker",
  "attachments",
  "codesnippet",
  "page",
  "emoji",
  "insert"
]);
class r7 extends HTMLElement {
  // 监听的 attr
  static get observedAttributes() {
    return ["data-value"];
  }
  attributeChangedCallback(e, t, n) {
    if (e === "data-value") {
      if (n && t === n)
        return;
      const i = JSON.parse(n), r = this.attachShadow({ mode: "open" }), o = r.ownerDocument;
      if (i.icon) {
        const l = o.createElement("span");
        l.part.add("svg"), l.innerHTML = i.icon, r.appendChild(l);
      }
      if (i.identifier) {
        const l = o.createElement("span");
        l.part.add("identifier"), l.innerHTML = i.identifier, r.appendChild(l);
      }
      if (i.name) {
        const l = o.createElement("span");
        l.part.add("name"), l.innerHTML = i.name, r.appendChild(l);
      }
      const a = o.createElement("style");
      a.innerHTML = "\n      svg {\n        height: 1em;\n        width: 1em;\n      }\n    ", r.appendChild(a);
    }
  }
}
class o7 extends HTMLElement {
  // 监听的 attr
  static get observedAttributes() {
    return ["data-value"];
  }
  attributeChangedCallback(e, t, n) {
    if (e === "data-value") {
      if (n && t === n)
        return;
      const i = this.attachShadow({ mode: "open" }), o = i.ownerDocument.createElement("span");
      o.innerHTML = n, o.part.add("box"), o.classList.add("emoji-elem_box"), i.appendChild(o);
    }
  }
}
class a7 {
  constructor() {
    E(this, "title", "格式刷");
    E(this, "tag", "button");
    E(this, "fragment", []);
    E(this, "format", {});
    E(this, "editor", null);
    E(this, "excting", !1);
    E(this, "iconSvg", '<svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg" fit="" height="1em" width="1em" preserveAspectRatio="xMidYMid meet" focusable="false"><g id="aqseditor/paintformat" stroke-width="1" fill-rule="evenodd"><path d="M3 5.24h10V2H3v3.24zM13.299 1H2.701A.701.701 0 0 0 2 1.701v3.838c0 .387.314.701.701.701h6.236L7.621 7.438h-.002v2.233h-.768v5.184L9.404 13.1V9.671h-.585V7.97l1.9-1.73h2.58A.701.701 0 0 0 14 5.539V1.701A.701.701 0 0 0 13.299 1z" id="aqsFill-1"></path></g></svg>');
    E(this, "setPaintFormat", () => {
      if (!this.editor)
        return;
      const e = this.editor.getSelectionText();
      if (e && Object.keys(this.format).length > 0) {
        const t = { ...this.format, text: e };
        this.editor.insertNode(t), this.excting || this.clearFormat();
      }
    });
    E(this, "onPaintFormat", wl(this.setPaintFormat, 500, !1));
    E(this, "throttleHandle", this.throttle(this.handle, 300));
  }
  // 菜单是否需要激活（如选中加粗文本，“加粗”菜单会激活），用不到则返回 false
  isActive(e) {
    return Object.keys(this.format).length > 0;
  }
  // 获取菜单执行时的 value ，用不到则返回空 字符串或 false
  getValue(e) {
    return "";
  }
  // 菜单是否需要禁用（如选中 H1 ，“引用”菜单被禁用），用不到则返回 false
  isDisabled(e) {
    return !1;
  }
  calcFormat(e) {
    if (e.length > 0) {
      const { children: t } = e[0];
      t.forEach((n) => {
        Object.assign(this.format, n);
      });
    }
  }
  clearFormat() {
    this.format = {};
    const e = this.editor.getEditableContainer();
    e && e.classList.remove("is-paint-format");
    const t = document.querySelector(
      "button[data-menu-key='paintformat']"
    );
    t && t.classList.remove("active");
  }
  throttle(e, t) {
    let n = null;
    return function(...i) {
      n || (n = setTimeout(() => {
        e.apply(this, i), n = null, this.excting = !0;
      }, t));
    };
  }
  handle(e) {
    if (this.excting) {
      this.clearFormat(), this.excting = !1;
      return;
    }
    const t = e.getFragment();
    this.calcFormat(t), this.editor = e;
    const n = this.editor.getEditableContainer();
    n && n.classList.add("is-paint-format"), e.deselect(), e.on("change", this.onPaintFormat), e.on("clickOutside", () => {
      this.clearFormat(), this.excting = !1;
    });
  }
  // 点击菜单时触发的函数
  exec(e) {
    this.throttleHandle(e);
  }
}
const l7 = {
  key: "paintformat",
  factory() {
    return new a7();
  }
};
class c7 {
  constructor() {
    // TS 语法
    E(this, "title", "AI询问");
    E(this, "iconSvg", '<svg xmlns="http://www.w3.org/2000/svg" version="1.1"> <text x="0" y="13" font-size="16" fill="black">AI</text></svg>');
    E(this, "tag", "button");
  }
  // 菜单是否需要激活（如选中加粗文本，“加粗”菜单会激活），用不到则返回 false
  isActive(e) {
    return !1;
  }
  // 获取菜单执行时的 value ，用不到则返回空 字符串或 false
  getValue(e) {
    return "aichart";
  }
  // 菜单是否需要禁用（如选中 H1 ，“引用”菜单被禁用），用不到则返回 false
  isDisabled(e) {
    return !1;
  }
  // 点击菜单时触发的函数
  exec(e, t) {
    e.emit("aiClick");
  }
}
function h7(s) {
  const { url: e, children: t } = s;
  let n = "_blank";
  return e.startsWith("./#/") && (n = "_self"), '<a href="'.concat(e, '" target="').concat(n, '">').concat(t[0].text, "</a>");
}
const u7 = {
  type: "link",
  elemToHtml: h7
};
class d7 {
  constructor() {
    E(this, "title", "查看连接");
    E(this, "iconSvg", '<svg viewBox="0 0 1024 1024"><path d="M924.402464 1023.068211H0.679665V99.345412h461.861399v98.909208H99.596867v725.896389h725.896389V561.206811h98.909208z" p-id="10909"></path><path d="M930.805104 22.977336l69.965436 69.965436-453.492405 453.492404-69.965435-69.901489z" p-id="10910"></path><path d="M1022.464381 304.030081h-98.917201V99.345412H709.230573V0.428211h313.233808z"></path></svg>');
    E(this, "tag", "button");
  }
  getSelectedLinkElem(e) {
    const t = fe.getSelectedNodeByType(e, "link");
    return t == null ? null : t;
  }
  getValue(e) {
    const t = this.getSelectedLinkElem(e);
    return t && t.url || "";
  }
  isActive() {
    return !1;
  }
  isDisabled(e) {
    return e.selection == null || this.getSelectedLinkElem(e) == null;
  }
  exec(e, t) {
    if (!this.isDisabled(e)) {
      if (!t || typeof t != "string")
        throw new Error("打开链接失败, 路径为 '".concat(t, "'"));
      t.toString().startsWith("./#/") ? window.open("".concat(window.location.pathname).concat(t.slice(1)), "_self") : window.open(t, "_blank");
    }
  }
}
const f7 = {
  key: "customViewLink",
  factory() {
    return new d7();
  }
}, g7 = {
  menus: [f7],
  elemsToHtml: [u7]
};
class p7 extends Jg {
  constructor() {
    super(...arguments);
    /**
     * 用户头像数据
     *
     * @type {string}
     * @memberof HtmlCommentController
     */
    E(this, "userAvatar", "");
    /**
     * 上传参数
     */
    E(this, "uploadParams");
    /**
     * 下载参数
     */
    E(this, "exportParams");
    /**
     * 最小高度
     *
     * @type {number}
     * @memberof HtmlCommentController
     */
    E(this, "minHeight", 48);
    /**
     * 最大高度
     *
     * @type {number}
     * @memberof HtmlCommentController
     */
    E(this, "maxHeight", 315);
    /**
     * 是否折叠
     *
     * @type {Ref<boolean>}
     * @memberof HtmlCommentController
     */
    E(this, "collapsed", T(!0));
    /**
     * 是否隐藏
     *
     * @type {Ref<boolean>}
     * @memberof HtmlCommentController
     */
    E(this, "hidden", T(!1));
    /**
     * 回复
     *
     * @type {string}
     * @memberof HtmlCommentController
     */
    E(this, "reply", T(""));
    /**
     * 回复脚本
     *
     * @type {string}
     * @memberof HtmlCommentController
     */
    E(this, "replyScript", "");
    /**
     * 编辑器模式
     *
     * @type {('comment' | 'default')}
     * @memberof HtmlCommentController
     */
    E(this, "mode", "comment");
    /**
     * 插入工具栏项
     *
     * @type {IData[]}
     * @memberof HtmlCommentController
     */
    E(this, "insertKeys", []);
    /**
     * 绘制模式
     *
     * @type {IData[]}
     * @memberof HtmlCommentController
     */
    E(this, "renderMode", "HTML");
    /**
     * 保存间隔
     *
     * @type {IData[]}
     * @memberof HtmlCommentController
     */
    E(this, "saveInterval", 3e3);
    /**
     * 抛值模式
     *
     * @type {IData[]}
     * @memberof HtmlCommentController
     */
    E(this, "emitMode", "BUTTON");
    /**
     * 唯一标识
     *
     * @type {string}
     * @memberof HtmlCommentController
     */
    E(this, "uuid", rt());
    /**
     * 实时编辑（协同编辑）
     */
    E(this, "enableRealtime", !1);
    /**
     * 编辑器实例
     */
    E(this, "editor");
    /**
     * 自动保存间隔
     * - 默认30秒
     * @private
     * @type {number}
     * @memberof HtmlCommentController
     */
    E(this, "autoSaveInterval", 3e4);
    /**
     * 定时器
     *
     * @private
     * @type {(NodeJS.Timeout | null)}
     * @memberof HtmlCommentController
     */
    E(this, "timer", null);
    /**
     * 应用实体服务
     *
     * @type {IAppDEService}
     * @memberof HtmlCommentController
     */
    E(this, "deService");
    /**
     * 自填模式
     *
     * @author chitanda
     * @date 2023-10-12 10:10:52
     * @type {IAppDEACMode}
     */
    E(this, "deACMode");
    /**
     * AI 聊天自填模式
     *
     * @author chitanda
     * @date 2023-10-12 10:10:37
     * @type {boolean}
     */
    E(this, "chatCompletion", !1);
    E(this, "evt", new Jh(
      this.getEventArgs.bind(this)
    ));
  }
  getEventArgs() {
    return {
      context: this.context,
      params: this.params,
      data: [],
      eventArg: "",
      targetName: this.model.name,
      view: this.getView()
    };
  }
  async onInit() {
    await super.onInit(), await this.getCurrentUserAvatar();
    const { model: t } = this;
    if (t.appDEACModeId && (this.deACMode = await Yg(
      t.appDEACModeId,
      t.appDataEntityId,
      this.context.srfappid
    ), this.deACMode && this.deACMode.actype === "CHATCOMPLETION" && (this.deService = await ibiz.hub.getApp(t.appId).deService.getService(this.context, t.appDataEntityId), this.chatCompletion = !0)), this.registerCustomElem(), this.editorParams) {
      const {
        uploadParams: n,
        exportParams: i,
        MINHEIGHT: r,
        MAXHEIGHT: o,
        REPLYSCRIPT: a,
        MODE: l,
        INSERTKEYS: c,
        RENDERMODE: u,
        SAVEINTERVAL: f,
        EMITMODE: d,
        DEFAULTCOLLAPSE: g,
        ENABLEREALTIME: p
      } = this.editorParams;
      if (n)
        try {
          this.uploadParams = JSON.parse(n);
        } catch (m) {
          ibiz.log.error(
            "编辑器[".concat(ibiz.log.error(
              m
            ), "]编辑器参数 uploadParams 非 json 格式")
          );
        }
      if (i)
        try {
          this.exportParams = JSON.parse(i);
        } catch (m) {
          ibiz.log.error(
            "编辑器[".concat(ibiz.log.error(
              m
            ), "]编辑器参数 exportParams 非 json 格式")
          );
        }
      r && (this.minHeight = Number(r)), o && (this.maxHeight = Number(o)), a && (this.replyScript = a), l && (this.mode = l.toLowerCase()), c && (this.insertKeys = JSON.parse(c)), u && (this.renderMode = u), f && (this.saveInterval = gp(f)), d && (this.emitMode = d), g && (this.collapsed.value = !Object.is(g, "TRUE") && !Object.is(g, "true")), p && (this.enableRealtime = Object.is(p, "TRUE") || Object.is(p, "true"));
    }
    xn.init(this.uuid), this.evt.on("onChange", () => {
      if (this.parent.form)
        return;
      const n = ibiz.uiDomainManager.get(this.context.srfsessionid);
      n && n.dataChange();
    }), this.listenViewDestroyed();
  }
  /**
   * 注册自定义元素
   *
   * @private
   * @memberof HtmlCommentController
   */
  registerCustomElem() {
    window.customElements.get("mention-elem") || window.customElements.define("mention-elem", r7), window.customElements.get("emoji-elem") || window.customElements.define("emoji-elem", o7), window.paintFormatIsRegiter || (it.registerMenu(l7), window.paintFormatIsRegiter = !0), window.aichartRegister || (it.registerMenu({
      key: "aichart",
      factory() {
        return new c7();
      }
    }), window.aichartRegister = !0), window.customLinkIsRegiter || (it.registerModule(g7), window.customLinkIsRegiter = !0);
  }
  /**
   * 初始化
   *
   * @param {IDomEditor} editor
   * @memberof HtmlCommentController
   */
  onCreated(t, n, i) {
    xn.getPluginsById(this.uuid).forEach((o) => {
      o.init(t, {
        model: this.model,
        data: n,
        toolbarConfig: i,
        context: this.context,
        params: this.params,
        evt: this.evt
      });
    });
  }
  /**
   * 组件销毁
   *
   * @memberof HtmlCollapseController
   */
  onDestroyed() {
    xn.getPluginsById(this.uuid).forEach((n) => {
      n.onDestroyed();
    }), xn.destroy(this.uuid);
  }
  /**
   * 处理视图销毁
   *
   * @memberof HtmlCommentController
   */
  listenViewDestroyed() {
    const t = this.getView();
    t && t.evt.on("onDestroyed", () => {
      this.onDestroyed();
    });
  }
  /**
   * 解析所有注册节点
   *
   * @param {string} value
   * @return {*}
   * @memberof HtmlCommentController
   */
  parseNode(t) {
    let n = t;
    return xn.getPluginsById(this.uuid).forEach((r) => {
      n = r.parseNode(n);
    }), n;
  }
  /**
   * 设置html
   *
   * @param {string} value
   * @memberof HtmlCommentController
   */
  async setValue(t) {
    this.collapsed.value = !1, this.hidden.value = !0, await ht(), this.hidden.value = !1, await ht();
    const n = this.parseNode(t);
    this.evt.emit("setHtml", {
      eventArg: n
    });
  }
  /**
   * 设置回复,data: {name: string, content: string}
   *
   * @param {IData} data
   * @memberof HtmlCommentController
   */
  setReply(t) {
    this.reply.value = zs.getEmojiCustomHtml(
      "".concat(t.name, ": ").concat(t.content)
    ), this.evt.emit("onSetReply", {
      eventArg: this.reply.value
    });
  }
  /**
   * 删除回复
   *
   * @memberof HtmlCommentController
   */
  removeReply() {
    this.reply.value = "", this.evt.emit("onRemoveReply", {
      eventArg: this.reply.value
    });
  }
  /**
   * 清空
   *
   * @memberof HtmlCommentController
   */
  clear() {
    this.reply.value = "", this.evt.emit("onRemoveReply", {
      eventArg: this.reply.value
    }), this.evt.emit("clear", {
      eventArg: ""
    }), this.collapsed.value = !0;
  }
  /**
   * 请求url获取文件流，并用JS触发文件下载
   *
   * @author lxm
   * @date 2022-11-17 14:11:09
   * @param {string} url
   * @param {IData} file
   */
  fileDownload(t) {
    ibiz.net.request(t.url, {
      method: "get",
      responseType: "blob",
      baseURL: ""
      // 已经有baseURL了，这里无需再写
    }).then((n) => {
      if (n.status !== 200)
        throw new rs("下载文件失败");
      if (n.data) {
        const i = t.name;
        ip(n.data, i);
      } else
        throw new rs("文件流数据不存在");
    });
  }
  /**
   * 切换折叠
   *
   * @memberof HtmlCommentController
   */
  toggleCollapse(t) {
    this.collapsed.value = !t && !this.collapsed.value;
  }
  /**
   * 绘制模式为json时，需要将返回数据的json内容转html
   *
   * @author ljx
   * @date 2024-03-09 15:11:09
   * @param {string} url
   * @param {IData} file
   */
  jsonToHtml(t) {
    let n = "";
    try {
      const i = JSON.parse(t);
      n = ep({
        content: i
      }).getHtml();
    } catch (i) {
      n = t, ibiz.log.error("JSON字符串转换错误", i);
    }
    return n;
  }
  /**
   * 绘制模式为json时，处理抛值数据
   *
   * @author ljx
   * @date 2024-03-09 15:11:09
   * @param {string} url
   * @param {IData} file
   */
  toJson(t = []) {
    let n = "";
    try {
      n = JSON.stringify(t);
    } catch (i) {
      ibiz.log.error("JSON字符串转换错误");
    }
    return n;
  }
  /**
   * 获取当前用户头像
   *
   * @memberof HtmlCommentController
   */
  async getCurrentUserAvatar() {
    var i, r;
    const t = await ibiz.hub.getApp(this.context.srfappid);
    let n = [];
    if (n = await t.codeList.get(
      "SysOperator",
      this.context,
      this.params
    ), this.context.srfuserid) {
      const o = n.filter((a) => a.value === this.context.srfuserid);
      o && o.length > 0 && (this.userAvatar = ((r = (i = o[0]) == null ? void 0 : i.data) == null ? void 0 : r.iconurl) || "");
    }
  }
  /**
   * 获取当前视图
   *
   * @return {*}
   * @memberof HtmlCommentController
   */
  getView() {
    const t = this.parent.form || this.parent.grid || this.parent.panel;
    if (t)
      return t.view;
  }
}
class m7 {
  constructor() {
    E(this, "formEditor", "HtmlComment");
    E(this, "gridEditor", "HtmlComment");
  }
  async createController(e, t) {
    const n = new p7(e, t);
    return await n.init(), n;
  }
}
const w7 = Qg(ga, function(s) {
  window.customElements.get("layout-elem") || window.customElements.define("layout-elem", u5), window.customElements.get("layout-column-elem") || window.customElements.define("layout-column-elem", d5), window.customElements.get("date-elem") || window.customElements.define("date-elem", r5), window.customElements.get("label-elem") || window.customElements.define("label-elem", o5), window.customElements.get("prompt-box-elem") || window.customElements.define("prompt-box-elem", a5), window.customElements.get("mind-map-elem") || window.customElements.define("mind-map-elem", l5), window.customElements.get("audio-elem") || window.customElements.define("audio-elem", c5), window.customElements.get("formula-elem") || window.customElements.define("formula-elem", h5), s.component(Ya.name, Ya), s.component(Xr.name, Xr), s.component(ga.name, ga), Xg(
    "EDITOR_CUSTOMSTYLE_COMMENT",
    () => new m7()
  );
}), B7 = {
  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types, @typescript-eslint/explicit-function-return-type
  install(s) {
    s.use(w7), s.component(
      "IBizHtmlContent",
      qg(() => Promise.resolve().then(() => pp))
    );
  }
};
export {
  w7 as I,
  R7 as c,
  q3 as g,
  B7 as i
};
